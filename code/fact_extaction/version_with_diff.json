{
    "5.0.2": {
        "- `Base64`: Fix issue where dirty memory located just after the input buffer is affecting the result. ([#4926](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4926))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4926": {
                    "add": [
                        "contract Base64Dirty {",
                        "    struct A {",
                        "        uint256 value;",
                        "    }",
                        "    function encode(bytes memory input) public pure returns (string memory) {",
                        "        A memory unused = A({value: type(uint256).max});",
                        "        unused;",
                        "        return Base64.encode(input);",
                        "    }",
                        "}",
                        "            let resultPtr := add(result, 0x20)",
                        "            let dataPtr := data",
                        "            let endPtr := add(data, mload(data))",
                        "            let afterPtr := add(endPtr, 0x20)",
                        "            let afterCache := mload(afterPtr)",
                        "            mstore(afterPtr, 0x00)",
                        "            mstore(afterPtr, afterCache)"
                    ],
                    "del": [
                        "            let resultPtr := add(result, 32)",
                        "                let dataPtr := data",
                        "                let endPtr := add(data, mload(data))"
                    ]
                }
            }
        ]
    },
    "4.9.6": {
        "- `Base64`: Fix issue where dirty memory located just after the input buffer is affecting the result. ([#4929](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4929))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4929": {
                    "add": [
                        "contract Base64Dirty {",
                        "    struct A {",
                        "        uint256 value;",
                        "    }",
                        "    function encode(bytes memory input) public pure returns (string memory) {",
                        "        A memory unused = A({value: type(uint256).max});",
                        "        unused;",
                        "        return Base64.encode(input);",
                        "    }",
                        "}",
                        "            let resultPtr := add(result, 0x20)",
                        "            let dataPtr := data",
                        "            let endPtr := add(data, mload(data))",
                        "            let afterPtr := add(endPtr, 0x20)",
                        "            let afterCache := mload(afterPtr)",
                        "            mstore(afterPtr, 0x00)",
                        "            mstore(afterPtr, afterCache)"
                    ],
                    "del": [
                        "            let resultPtr := add(result, 32)",
                        "                let dataPtr := data",
                        "                let endPtr := add(data, mload(data))"
                    ]
                }
            }
        ]
    },
    "4.9.5": {
        "- `Multicall`: Make aware of non-canonical context (i.e. `msg.sender` is not `_msgSender()`), allowing compatibility with `ERC2771Context`. Patch duplicated `Address.functionDelegateCall` in v4.9.4 (removed).": []
    },
    "5.0.1": {
        "- `ERC2771Context` and `Context`: Introduce a `_contextPrefixLength()` getter, used to trim extra information appended to `msg.data`.\r": [],
        "- `Multicall`: Make aware of non-canonical context (i.e. `msg.sender` is not `_msgSender()`), allowing compatibility with `ERC2771Context`.": []
    },
    "4.9.4": {
        "- `ERC2771Context` and `Context`: Introduce a `_contextPrefixLength()` getter, used to trim extra information appended to `msg.data`.\r": [],
        "- `Multicall`: Make aware of non-canonical context (i.e. `msg.sender` is not `_msgSender()`), allowing compatibility with `ERC2771Context`.": []
    },
    "5.0.0": {
        "  - `GovernorTimelockAccess`: An adapter for time-locking governance proposals using an `AccessManager`.\r": [],
        "- `Nonces`: An abstraction for managing account nonces.\r": [],
        "- `Address.isContract` (because of its ambiguous nature and potential for misuse)\r": [],
        "- `ERC20Snapshot`\r": [],
        "- `ERC165Storage` (in favor of inheritance based approach)\r": [],
        "- `ERC777`\r": [],
        "- `GovernorProposalThreshold` (deprecated since 4.4)\r": [],
        "- `PullPayment`\r": [],
        "- `SafeMath`\r": [],
        "- `SignedSafeMath`\r": [],
        "- `TokenTimelock` (in favor of `VestingWallet`)\r": [],
        "- All cross-chain contracts, including `AccessControlCrossChain` and all the vendored bridge interfaces\r": [],
        "- Replaced revert strings and require statements with custom errors. ([#4261](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4261))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4261": {
                    "add": [
                        "            revert AccessControlUnauthorizedAccount(account, role);",
                        "     * - the caller must be `callerConfirmation`.",
                        "    function renounceRole(bytes32 role, address callerConfirmation) public virtual {",
                        "        if (callerConfirmation != _msgSender()) {",
                        "            revert AccessControlBadConfirmation();",
                        "        }",
                        "        _revokeRole(role, callerConfirmation);",
                        "        if (initialDefaultAdmin == address(0)) {",
                        "            revert AccessControlInvalidDefaultAdmin(address(0));",
                        "        }",
                        "        if (role == DEFAULT_ADMIN_ROLE) {",
                        "            revert AccessControlEnforcedDefaultAdminRules();",
                        "        }",
                        "        if (role == DEFAULT_ADMIN_ROLE) {",
                        "            revert AccessControlEnforcedDefaultAdminRules();",
                        "        }",
                        "            if (newDefaultAdmin != address(0) || !_isScheduleSet(schedule) || !_hasSchedulePassed(schedule)) {",
                        "                revert AccessControlEnforcedDefaultAdminDelay(schedule);",
                        "            }",
                        "            if (defaultAdmin() != address(0)) {",
                        "                revert AccessControlEnforcedDefaultAdminRules();",
                        "            }",
                        "        if (role == DEFAULT_ADMIN_ROLE) {",
                        "            revert AccessControlEnforcedDefaultAdminRules();",
                        "        }",
                        "        if (_msgSender() != newDefaultAdmin) {",
                        "            revert AccessControlInvalidDefaultAdmin(_msgSender());",
                        "        }",
                        "        if (!_isScheduleSet(schedule) || !_hasSchedulePassed(schedule)) {",
                        "            revert AccessControlEnforcedDefaultAdminDelay(schedule);",
                        "        }",
                        "    /**",
                        "     * @dev The `account` is missing a role.",
                        "     */",
                        "    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);",
                        "    /**",
                        "     * @dev The caller of a function is not the expected one.",
                        "     *",
                        "     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.",
                        "     */",
                        "    error AccessControlBadConfirmation();",
                        "     * - the caller must be `callerConfirmation`.",
                        "    function renounceRole(bytes32 role, address callerConfirmation) external;",
                        "    /**",
                        "     * @dev The new default admin is not a valid default admin.",
                        "     */",
                        "    error AccessControlInvalidDefaultAdmin(address defaultAdmin);",
                        "    /**",
                        "     * @dev At least one of the following rules was violated:",
                        "     *",
                        "     * - The `DEFAULT_ADMIN_ROLE` must only be managed by itself.",
                        "     * - The `DEFAULT_ADMIN_ROLE` must only be held by one account at the time.",
                        "     * - Any `DEFAULT_ADMIN_ROLE` transfer must be in two delayed steps.",
                        "     */",
                        "    error AccessControlEnforcedDefaultAdminRules();",
                        "    /**",
                        "     * @dev The delay for transferring the default admin delay is enforced and",
                        "     * the operation must wait until `schedule`.",
                        "     *",
                        "     * NOTE: `schedule` can be 0 indicating there's no transfer scheduled.",
                        "     */",
                        "    error AccessControlEnforcedDefaultAdminDelay(uint48 schedule);",
                        "    /**",
                        "     * @dev The caller account is not authorized to perform an operation.",
                        "     */",
                        "    error OwnableUnauthorizedAccount(address account);",
                        "    /**",
                        "     * @dev The owner is not a valid owner account. (eg. `address(0)`)",
                        "     */",
                        "    error OwnableInvalidOwner(address owner);",
                        "        if (owner() != _msgSender()) {",
                        "            revert OwnableUnauthorizedAccount(_msgSender());",
                        "        }",
                        "        if (newOwner == address(0)) {",
                        "            revert OwnableInvalidOwner(address(0));",
                        "        }",
                        "        if (pendingOwner() != sender) {",
                        "            revert OwnableUnauthorizedAccount(sender);",
                        "        }",
                        "    /**",
                        "     * @dev The `beneficiary` is not a valid account.",
                        "     */",
                        "    error VestingWalletInvalidBeneficiary(address beneficiary);",
                        "        if (beneficiaryAddress == address(0)) {",
                        "            revert VestingWalletInvalidBeneficiary(address(0));",
                        "        }",
                        "    bytes32 private constant _ALL_PROPOSAL_STATES_BITMAP = bytes32((2 ** (uint8(type(ProposalState).max) + 1)) - 1);",
                        "        if (_msgSender() != _executor()) {",
                        "            revert GovernorOnlyExecutor(_msgSender());",
                        "        }",
                        "        if (_executor() != address(this)) {",
                        "            revert GovernorDisabledDeposit();",
                        "        }",
                        "            revert GovernorNonexistentProposal(proposalId);",
                        "        {",
                        "            uint256 proposerVotes = getVotes(proposer, currentTimepoint - 1);",
                        "            uint256 votesThreshold = proposalThreshold();",
                        "            if (proposerVotes < votesThreshold) {",
                        "                revert GovernorInsufficientProposerVotes(proposer, proposerVotes, votesThreshold);",
                        "            }",
                        "        }",
                        "        if (targets.length != values.length || targets.length != calldatas.length || targets.length == 0) {",
                        "            revert GovernorInvalidProposalLength(targets.length, calldatas.length, values.length);",
                        "        }",
                        "        if (_proposals[proposalId].voteStart != 0) {",
                        "            revert GovernorUnexpectedProposalState(proposalId, state(proposalId), bytes32(0));",
                        "        }",
                        "        if (currentState != ProposalState.Succeeded && currentState != ProposalState.Queued) {",
                        "            revert GovernorUnexpectedProposalState(",
                        "                proposalId,",
                        "                currentState,",
                        "                _encodeStateBitmap(ProposalState.Succeeded) | _encodeStateBitmap(ProposalState.Queued)",
                        "            );",
                        "        }",
                        "        ProposalState currentState = state(proposalId);",
                        "        if (currentState != ProposalState.Pending) {",
                        "            revert GovernorUnexpectedProposalState(proposalId, currentState, _encodeStateBitmap(ProposalState.Pending));",
                        "        }",
                        "        if (_msgSender() != proposalProposer(proposalId)) {",
                        "            revert GovernorOnlyProposer(_msgSender());",
                        "        }",
                        "            Address.verifyCallResult(success, returndata);",
                        "        bytes32 forbiddenStates = _encodeStateBitmap(ProposalState.Canceled) |",
                        "            _encodeStateBitmap(ProposalState.Expired) |",
                        "            _encodeStateBitmap(ProposalState.Executed);",
                        "        if (forbiddenStates & _encodeStateBitmap(currentState) != 0) {",
                        "            revert GovernorUnexpectedProposalState(",
                        "                proposalId,",
                        "                currentState,",
                        "                _ALL_PROPOSAL_STATES_BITMAP ^ forbiddenStates",
                        "            );",
                        "        }",
                        "        ProposalState currentState = state(proposalId);",
                        "        if (currentState != ProposalState.Active) {",
                        "            revert GovernorUnexpectedProposalState(proposalId, currentState, _encodeStateBitmap(ProposalState.Active));",
                        "        }",
                        "        Address.verifyCallResult(success, returndata);",
                        "     * @dev Encodes a `ProposalState` into a `bytes32` representation where each bit enabled corresponds to",
                        "     * the underlying position in the `ProposalState` enum. For example:",
                        "     *",
                        "     * 0x000...10000",
                        "     *   ^^^^^^------ ...",
                        "     *         ^----- Succeeded",
                        "     *          ^---- Defeated",
                        "     *           ^--- Canceled",
                        "     *            ^-- Active",
                        "     *             ^- Pending",
                        "     */",
                        "    function _encodeStateBitmap(ProposalState proposalState) internal pure returns (bytes32) {",
                        "        return bytes32(1 << uint8(proposalState));",
                        "    }",
                        "    /*",
                        "    /**",
                        "     * @dev Empty proposal or a mismatch between the parameters length for a proposal call.",
                        "     */",
                        "    error GovernorInvalidProposalLength(uint256 targets, uint256 calldatas, uint256 values);",
                        "    /**",
                        "     * @dev The vote was already cast.",
                        "     */",
                        "    error GovernorAlreadyCastVote(address voter);",
                        "    /**",
                        "     * @dev Token deposits are disabled in this contract.",
                        "     */",
                        "    error GovernorDisabledDeposit();",
                        "    /**",
                        "     * @dev The `account` is not a proposer.",
                        "     */",
                        "    error GovernorOnlyProposer(address account);",
                        "    /**",
                        "     * @dev The `account` is not the governance executor.",
                        "     */",
                        "    error GovernorOnlyExecutor(address account);",
                        "    /**",
                        "     * @dev The `proposalId` doesn't exist.",
                        "     */",
                        "    error GovernorNonexistentProposal(uint256 proposalId);",
                        "    /**",
                        "     * @dev The current state of a proposal is not the required for performing an operation.",
                        "     * The `expectedStates` is a bitmap with the bits enabled for each ProposalState enum position",
                        "     * counting from right to left.",
                        "     *",
                        "     * NOTE: If `expectedState` is `bytes32(0)`, the proposal is expected to not be in any state (i.e. not exist).",
                        "     * This is the case when a proposal that is expected to be unset is already initiated (the proposal is duplicated).",
                        "     *",
                        "     * See {Governor-_encodeStateBitmap}.",
                        "     */",
                        "    error GovernorUnexpectedProposalState(uint256 proposalId, ProposalState current, bytes32 expectedStates);",
                        "    /**",
                        "     * @dev The voting period set is not a valid period.",
                        "     */",
                        "    error GovernorInvalidVotingPeriod(uint256 votingPeriod);",
                        "    /**",
                        "     * @dev The `proposer` does not have the required votes to operate on a proposal.",
                        "     */",
                        "    error GovernorInsufficientProposerVotes(address proposer, uint256 votes, uint256 threshold);",
                        "    /**",
                        "     * @dev The vote type used is not valid for the corresponding counting module.",
                        "     */",
                        "    error GovernorInvalidVoteType();",
                        "    enum OperationState {",
                        "        Unset,",
                        "        Pending,",
                        "        Ready,",
                        "        Done",
                        "    }",
                        "    /**",
                        "     * @dev Mismatch between the parameters length for an operation call.",
                        "     */",
                        "    error TimelockInvalidOperationLength(uint256 targets, uint256 payloads, uint256 values);",
                        "    /**",
                        "     * @dev The schedule operation doesn't meet the minimum delay.",
                        "     */",
                        "    error TimelockInsufficientDelay(uint256 delay, uint256 minDelay);",
                        "    /**",
                        "     * @dev The current state of an operation is not as required.",
                        "     */",
                        "    error TimelockUnexpectedOperationState(bytes32 operationId, OperationState expected);",
                        "    /**",
                        "     * @dev The predecessor to an operation not yet done.",
                        "     */",
                        "    error TimelockUnexecutedPredecessor(bytes32 predecessorId);",
                        "    /**",
                        "     * @dev The caller account is not authorized.",
                        "     */",
                        "    error TimelockUnauthorizedCaller(address caller);",
                        "        if (targets.length != values.length || targets.length != payloads.length) {",
                        "            revert TimelockInvalidOperationLength(targets.length, payloads.length, values.length);",
                        "        }",
                        "        if (isOperation(id)) {",
                        "            revert TimelockUnexpectedOperationState(id, OperationState.Unset);",
                        "        }",
                        "        uint256 minDelay = getMinDelay();",
                        "        if (delay < minDelay) {",
                        "            revert TimelockInsufficientDelay(delay, minDelay);",
                        "        }",
                        "        if (!isOperationPending(id)) {",
                        "            revert TimelockUnexpectedOperationState(id, OperationState.Pending);",
                        "        }",
                        "        if (targets.length != values.length || targets.length != payloads.length) {",
                        "            revert TimelockInvalidOperationLength(targets.length, payloads.length, values.length);",
                        "        }",
                        "        (bool success, bytes memory returndata) = target.call{value: value}(data);",
                        "        Address.verifyCallResult(success, returndata);",
                        "        if (!isOperationReady(id)) {",
                        "            revert TimelockUnexpectedOperationState(id, OperationState.Ready);",
                        "        }",
                        "        if (predecessor != bytes32(0) && !isOperationDone(predecessor)) {",
                        "            revert TimelockUnexecutedPredecessor(predecessor);",
                        "        }",
                        "        if (!isOperationReady(id)) {",
                        "            revert TimelockUnexpectedOperationState(id, OperationState.Ready);",
                        "        }",
                        "        if (msg.sender != address(this)) {",
                        "            revert TimelockUnauthorizedCaller(msg.sender);",
                        "        }",
                        "        if (signatures.length != calldatas.length) {",
                        "            revert GovernorInvalidSignaturesLength(signatures.length, calldatas.length);",
                        "        }",
                        "        uint256 proposerVotes = getVotes(proposer, clock() - 1);",
                        "        uint256 votesThreshold = proposalThreshold();",
                        "        if (_msgSender() != proposer && proposerVotes >= votesThreshold) {",
                        "            revert GovernorInsufficientProposerVotes(proposer, proposerVotes, votesThreshold);",
                        "        }",
                        "        if (receipt.hasVoted) {",
                        "            revert GovernorAlreadyCastVote(account);",
                        "        }",
                        "            revert GovernorInvalidVoteType();",
                        "    /**",
                        "     * @dev Mismatch between the parameters length for a proposal call.",
                        "     */",
                        "    error GovernorInvalidSignaturesLength(uint256 signatures, uint256 calldatas);",
                        "        if (proposalVote.hasVoted[account]) {",
                        "            revert GovernorAlreadyCastVote(account);",
                        "        }",
                        "            revert GovernorInvalidVoteType();",
                        "        if (newVotingPeriod == 0) {",
                        "            revert GovernorInvalidVotingPeriod(0);",
                        "        }",
                        "        ProposalState currentState = state(proposalId);",
                        "        if (currentState != ProposalState.Succeeded) {",
                        "            revert GovernorUnexpectedProposalState(",
                        "                proposalId,",
                        "                currentState,",
                        "                _encodeStateBitmap(ProposalState.Succeeded)",
                        "            );",
                        "        }",
                        "            if (_timelock.queuedTransactions(keccak256(abi.encode(targets[i], values[i], \"\", calldatas[i], eta)))) {",
                        "                revert GovernorAlreadyQueuedProposal(proposalId);",
                        "            }",
                        "        if (eta == 0) {",
                        "            revert GovernorNotQueuedProposal(proposalId);",
                        "        }",
                        "        ProposalState currentState = state(proposalId);",
                        "        if (currentState != ProposalState.Succeeded) {",
                        "            revert GovernorUnexpectedProposalState(",
                        "                proposalId,",
                        "                currentState,",
                        "                _encodeStateBitmap(ProposalState.Succeeded)",
                        "            );",
                        "        }",
                        "    /**",
                        "     * @dev The quorum set is not a valid fraction.",
                        "     */",
                        "    error GovernorInvalidQuorumFraction(uint256 quorumNumerator, uint256 quorumDenominator);",
                        "        uint256 denominator = quorumDenominator();",
                        "        if (newQuorumNumerator > denominator) {",
                        "            revert GovernorInvalidQuorumFraction(newQuorumNumerator, denominator);",
                        "        }",
                        "    /**",
                        "     * @dev The proposal hasn't been queued yet.",
                        "     */",
                        "    error GovernorNotQueuedProposal(uint256 proposalId);",
                        "    /**",
                        "     * @dev The proposal has already been queued.",
                        "     */",
                        "    error GovernorAlreadyQueuedProposal(uint256 proposalId);",
                        "    /**",
                        "     * @dev The signature used has expired.",
                        "     */",
                        "    error VotesExpiredSignature(uint256 expiry);",
                        "    /**",
                        "     * @dev The clock was incorrectly modified.",
                        "     */",
                        "    error ERC6372InconsistentClock();",
                        "    /**",
                        "     * @dev Lookup to future votes is not available.",
                        "     */",
                        "    error ERC5805FutureLookup(uint256 timepoint, uint48 clock);",
                        "        if (clock() != block.number) {",
                        "            revert ERC6372InconsistentClock();",
                        "        }",
                        "        uint48 currentTimepoint = clock();",
                        "        if (timepoint >= currentTimepoint) {",
                        "            revert ERC5805FutureLookup(timepoint, currentTimepoint);",
                        "        }",
                        "        uint48 currentTimepoint = clock();",
                        "        if (timepoint >= currentTimepoint) {",
                        "            revert ERC5805FutureLookup(timepoint, currentTimepoint);",
                        "        }",
                        "        if (block.timestamp > expiry) {",
                        "            revert VotesExpiredSignature(expiry);",
                        "        }",
                        "        _useCheckedNonce(signer, nonce);",
                        "/**",
                        " * @dev Standard ERC20 Errors",
                        " * Interface of the ERC6093 custom errors for ERC20 tokens",
                        " * as defined in https://eips.ethereum.org/EIPS/eip-6093",
                        " */",
                        "interface IERC20Errors {",
                        "    /**",
                        "     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.",
                        "     * @param sender Address whose tokens are being transferred.",
                        "     * @param balance Current balance for the interacting account.",
                        "     * @param needed Minimum amount required to perform a transfer.",
                        "     */",
                        "    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);",
                        "    /**",
                        "     * @dev Indicates a failure with the token `sender`. Used in transfers.",
                        "     * @param sender Address whose tokens are being transferred.",
                        "     */",
                        "    error ERC20InvalidSender(address sender);",
                        "    /**",
                        "     * @dev Indicates a failure with the token `receiver`. Used in transfers.",
                        "     * @param receiver Address to which tokens are being transferred.",
                        "     */",
                        "    error ERC20InvalidReceiver(address receiver);",
                        "    /**",
                        "     * @dev Indicates a failure with the `spender`\u2019s `allowance`. Used in transfers.",
                        "     * @param spender Address that may be allowed to operate on tokens without being their owner.",
                        "     * @param allowance Amount of tokens a `spender` is allowed to operate with.",
                        "     * @param needed Minimum amount required to perform a transfer.",
                        "     */",
                        "    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);",
                        "    /**",
                        "     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.",
                        "     * @param approver Address initiating an approval operation.",
                        "     */",
                        "    error ERC20InvalidApprover(address approver);",
                        "    /**",
                        "     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.",
                        "     * @param spender Address that may be allowed to operate on tokens without being their owner.",
                        "     */",
                        "    error ERC20InvalidSpender(address spender);",
                        "}",
                        "/**",
                        " * @dev Standard ERC721 Errors",
                        " * Interface of the ERC6093 custom errors for ERC721 tokens",
                        " * as defined in https://eips.ethereum.org/EIPS/eip-6093",
                        " */",
                        "interface IERC721Errors {",
                        "    /**",
                        "     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.",
                        "     * Used in balance queries.",
                        "     * @param owner Address of the current owner of a token.",
                        "     */",
                        "    error ERC721InvalidOwner(address owner);",
                        "    /**",
                        "     * @dev Indicates a `tokenId` whose `owner` is the zero address.",
                        "     * @param tokenId Identifier number of a token.",
                        "     */",
                        "    error ERC721NonexistentToken(uint256 tokenId);",
                        "    /**",
                        "     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.",
                        "     * @param sender Address whose tokens are being transferred.",
                        "     * @param tokenId Identifier number of a token.",
                        "     * @param owner Address of the current owner of a token.",
                        "     */",
                        "    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);",
                        "    /**",
                        "     * @dev Indicates a failure with the token `sender`. Used in transfers.",
                        "     * @param sender Address whose tokens are being transferred.",
                        "     */",
                        "    error ERC721InvalidSender(address sender);",
                        "    /**",
                        "     * @dev Indicates a failure with the token `receiver`. Used in transfers.",
                        "     * @param receiver Address to which tokens are being transferred.",
                        "     */",
                        "    error ERC721InvalidReceiver(address receiver);",
                        "    /**",
                        "     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.",
                        "     * @param operator Address that may be allowed to operate on tokens without being their owner.",
                        "     * @param tokenId Identifier number of a token.",
                        "     */",
                        "    error ERC721InsufficientApproval(address operator, uint256 tokenId);",
                        "    /**",
                        "     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.",
                        "     * @param approver Address initiating an approval operation.",
                        "     */",
                        "    error ERC721InvalidApprover(address approver);",
                        "    /**",
                        "     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.",
                        "     * @param operator Address that may be allowed to operate on tokens without being their owner.",
                        "     */",
                        "    error ERC721InvalidOperator(address operator);",
                        "}",
                        "/**",
                        " * @dev Standard ERC1155 Errors",
                        " * Interface of the ERC6093 custom errors for ERC1155 tokens",
                        " * as defined in https://eips.ethereum.org/EIPS/eip-6093",
                        " */",
                        "interface IERC1155Errors {",
                        "    /**",
                        "     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.",
                        "     * @param sender Address whose tokens are being transferred.",
                        "     * @param balance Current balance for the interacting account.",
                        "     * @param needed Minimum amount required to perform a transfer.",
                        "     */",
                        "    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);",
                        "    /**",
                        "     * @dev Indicates a failure with the token `sender`. Used in transfers.",
                        "     * @param sender Address whose tokens are being transferred.",
                        "     */",
                        "    error ERC1155InvalidSender(address sender);",
                        "    /**",
                        "     * @dev Indicates a failure with the token `receiver`. Used in transfers.",
                        "     * @param receiver Address to which tokens are being transferred.",
                        "     */",
                        "    error ERC1155InvalidReceiver(address receiver);",
                        "    /**",
                        "     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.",
                        "     * @param operator Address that may be allowed to operate on tokens without being their owner.",
                        "     * @param owner Address of the current owner of a token.",
                        "     */",
                        "    error ERC1155InsufficientApprovalForAll(address operator, address owner);",
                        "    /**",
                        "     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.",
                        "     * @param approver Address initiating an approval operation.",
                        "     */",
                        "    error ERC1155InvalidApprover(address approver);",
                        "    /**",
                        "     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.",
                        "     * @param operator Address that may be allowed to operate on tokens without being their owner.",
                        "     */",
                        "    error ERC1155InvalidOperator(address operator);",
                        "    /**",
                        "     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.",
                        "     * Used in batch transfers.",
                        "     * @param idsLength Length of the array of token identifiers",
                        "     * @param valuesLength Length of the array of token amounts",
                        "     */",
                        "    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);",
                        "}",
                        "    /**",
                        "     * @dev The request `from` doesn't match with the recovered `signer`.",
                        "     */",
                        "    error MinimalForwarderInvalidSigner(address signer, address from);",
                        "    /**",
                        "     * @dev The request nonce doesn't match with the `current` nonce for the request signer.",
                        "     */",
                        "    error MinimalForwarderInvalidNonce(address signer, uint256 current);",
                        "        address signer = _recover(req, signature);",
                        "        (bool correctFrom, bool correctNonce) = _validateReq(req, signer);",
                        "        return correctFrom && correctNonce;",
                        "        address signer = _recover(req, signature);",
                        "        (bool correctFrom, bool correctNonce) = _validateReq(req, signer);",
                        "        if (!correctFrom) {",
                        "            revert MinimalForwarderInvalidSigner(signer, req.from);",
                        "        }",
                        "        if (!correctNonce) {",
                        "            revert MinimalForwarderInvalidNonce(signer, _nonces[req.from]);",
                        "        }",
                        "    function _recover(ForwardRequest calldata req, bytes calldata signature) internal view returns (address) {",
                        "        return",
                        "            _hashTypedDataV4(",
                        "                keccak256(abi.encode(_TYPEHASH, req.from, req.to, req.value, req.gas, req.nonce, keccak256(req.data)))",
                        "            ).recover(signature);",
                        "    }",
                        "    function _validateReq(",
                        "        ForwardRequest calldata req,",
                        "        address signer",
                        "    ) internal view returns (bool correctFrom, bool correctNonce) {",
                        "        return (signer == req.from, _nonces[req.from] == req.nonce);",
                        "    }",
                        "/**",
                        " * @dev A mock to expose `Address`'s functions with function pointers.",
                        " */",
                        "contract AddressFnPointerMock {",
                        "    error CustomRevert();",
                        "    function functionCall(address target, bytes memory data) external returns (bytes memory) {",
                        "        return Address.functionCall(target, data, _customRevert);",
                        "    }",
                        "    function functionCallWithValue(address target, bytes memory data, uint256 value) external returns (bytes memory) {",
                        "        return Address.functionCallWithValue(target, data, value, _customRevert);",
                        "    }",
                        "    function functionStaticCall(address target, bytes memory data) external view returns (bytes memory) {",
                        "        return Address.functionStaticCall(target, data, _customRevert);",
                        "    }",
                        "    function functionDelegateCall(address target, bytes memory data) external returns (bytes memory) {",
                        "        return Address.functionDelegateCall(target, data, _customRevert);",
                        "    }",
                        "    function verifyCallResultFromTarget(",
                        "        address target,",
                        "        bool success,",
                        "        bytes memory returndata",
                        "    ) external view returns (bytes memory) {",
                        "        return Address.verifyCallResultFromTarget(target, success, returndata, _customRevert);",
                        "    }",
                        "    function verifyCallResult(bool success, bytes memory returndata) external view returns (bytes memory) {",
                        "        return Address.verifyCallResult(success, returndata, _customRevert);",
                        "    }",
                        "    function verifyCallResultVoid(bool success, bytes memory returndata) external view returns (bytes memory) {",
                        "        return Address.verifyCallResult(success, returndata, _customRevertVoid);",
                        "    }",
                        "    function _customRevert() internal pure {",
                        "        revert CustomRevert();",
                        "    }",
                        "    function _customRevertVoid() internal pure {}",
                        "}",
                        "    /**",
                        "     * @dev A clone instance deployment failed.",
                        "     */",
                        "    error ERC1167FailedCreateClone();",
                        "        if (instance == address(0)) {",
                        "            revert ERC1167FailedCreateClone();",
                        "        }",
                        "        if (instance == address(0)) {",
                        "            revert ERC1167FailedCreateClone();",
                        "        }",
                        "    /**",
                        "     * @dev The `implementation` of the proxy is invalid.",
                        "     */",
                        "    error ERC1967InvalidImplementation(address implementation);",
                        "    /**",
                        "     * @dev The `admin` of the proxy is invalid.",
                        "     */",
                        "    error ERC1967InvalidAdmin(address admin);",
                        "    /**",
                        "     * @dev The `beacon` of the proxy is invalid.",
                        "     */",
                        "    error ERC1967InvalidBeacon(address beacon);",
                        "    /**",
                        "     * @dev The storage `slot` is unsupported as a UUID.",
                        "     */",
                        "    error ERC1967UnsupportedProxiableUUID(bytes32 slot);",
                        "        if (newImplementation.code.length == 0) {",
                        "            revert ERC1967InvalidImplementation(newImplementation);",
                        "        }",
                        "                if (slot != _IMPLEMENTATION_SLOT) {",
                        "                    revert ERC1967UnsupportedProxiableUUID(slot);",
                        "                }",
                        "                revert ERC1967InvalidImplementation(newImplementation);",
                        "        if (newAdmin == address(0)) {",
                        "            revert ERC1967InvalidAdmin(address(0));",
                        "        }",
                        "        if (newBeacon.code.length == 0) {",
                        "            revert ERC1967InvalidBeacon(newBeacon);",
                        "        }",
                        "        address beaconImplementation = IBeacon(newBeacon).implementation();",
                        "        if (beaconImplementation.code.length == 0) {",
                        "            revert ERC1967InvalidImplementation(beaconImplementation);",
                        "        }",
                        "    /**",
                        "     * @dev The `implementation` of the beacon is invalid.",
                        "     */",
                        "    error BeaconInvalidImplementation(address implementation);",
                        "        if (newImplementation.code.length == 0) {",
                        "            revert BeaconInvalidImplementation(newImplementation);",
                        "        }",
                        "    /**",
                        "     * @dev The proxy caller is the current admin, and can't fallback to the proxy target.",
                        "     */",
                        "    error ProxyDeniedAdminAccess();",
                        "    /**",
                        "     * @dev msg.value is not 0.",
                        "     */",
                        "    error ProxyNonPayableFunction();",
                        "                revert ProxyDeniedAdminAccess();",
                        "        if (msg.value != 0) {",
                        "            revert ProxyNonPayableFunction();",
                        "        }",
                        "    /**",
                        "     * @dev The contract is already initialized.",
                        "     */",
                        "    error AlreadyInitialized();",
                        "    /**",
                        "     * @dev The contract is not initializing.",
                        "     */",
                        "    error NotInitializing();",
                        "        if (!(isTopLevelCall && _initialized < 1) && !(address(this).code.length == 0 && _initialized == 1)) {",
                        "            revert AlreadyInitialized();",
                        "        }",
                        "        if (_initializing || _initialized >= version) {",
                        "            revert AlreadyInitialized();",
                        "        }",
                        "        if (!_initializing) {",
                        "            revert NotInitializing();",
                        "        }",
                        "        if (_initializing) {",
                        "            revert AlreadyInitialized();",
                        "        }",
                        "    /**",
                        "     * @dev The call is from an unauthorized context.",
                        "     */",
                        "    error UUPSUnauthorizedCallContext();",
                        "        if (address(this) == __self) {",
                        "            revert UUPSUnauthorizedCallContext();",
                        "        }",
                        "        if (_getImplementation() != __self) {",
                        "            revert UUPSUnauthorizedCallContext();",
                        "        }",
                        "        if (address(this) != __self) {",
                        "            revert UUPSUnauthorizedCallContext();",
                        "        }",
                        "    bool private _paused;",
                        "    /**",
                        "     * @dev The operation failed because the contract is paused.",
                        "     */",
                        "    error EnforcedPause();",
                        "    /**",
                        "     * @dev The operation failed because the contract is not paused.",
                        "     */",
                        "    error ExpectedPause();",
                        "        if (paused()) {",
                        "            revert EnforcedPause();",
                        "        }",
                        "        if (!paused()) {",
                        "            revert ExpectedPause();",
                        "        }",
                        "    /**",
                        "     * @dev Unauthorized reentrant call.",
                        "     */",
                        "    error ReentrancyGuardReentrantCall();",
                        "        if (_status == _ENTERED) {",
                        "            revert ReentrancyGuardReentrantCall();",
                        "        }",
                        "contract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI, IERC1155Errors {",
                        "        if (accounts.length != ids.length) {",
                        "            revert ERC1155InvalidArrayLength(ids.length, accounts.length);",
                        "        }",
                        "        if (from != _msgSender() && !isApprovedForAll(from, _msgSender())) {",
                        "            revert ERC1155InsufficientApprovalForAll(_msgSender(), from);",
                        "        }",
                        "        if (from != _msgSender() && !isApprovedForAll(from, _msgSender())) {",
                        "            revert ERC1155InsufficientApprovalForAll(_msgSender(), from);",
                        "        }",
                        "        if (ids.length != amounts.length) {",
                        "            revert ERC1155InvalidArrayLength(ids.length, amounts.length);",
                        "        }",
                        "                if (fromBalance < amount) {",
                        "                    revert ERC1155InsufficientBalance(from, fromBalance, amount, id);",
                        "                }",
                        "        if (to == address(0)) {",
                        "            revert ERC1155InvalidReceiver(address(0));",
                        "        }",
                        "        if (from == address(0)) {",
                        "            revert ERC1155InvalidSender(address(0));",
                        "        }",
                        "        if (to == address(0)) {",
                        "            revert ERC1155InvalidReceiver(address(0));",
                        "        }",
                        "        if (from == address(0)) {",
                        "            revert ERC1155InvalidSender(address(0));",
                        "        }",
                        "        if (to == address(0)) {",
                        "            revert ERC1155InvalidReceiver(address(0));",
                        "        }",
                        "        if (to == address(0)) {",
                        "            revert ERC1155InvalidReceiver(address(0));",
                        "        }",
                        "        if (from == address(0)) {",
                        "            revert ERC1155InvalidSender(address(0));",
                        "        }",
                        "        if (from == address(0)) {",
                        "            revert ERC1155InvalidSender(address(0));",
                        "        }",
                        "        if (owner == operator) {",
                        "            revert ERC1155InvalidOperator(operator);",
                        "        }",
                        "                    revert ERC1155InvalidReceiver(to);",
                        "                revert ERC1155InvalidReceiver(to);",
                        "                    revert ERC1155InvalidReceiver(to);",
                        "                revert ERC1155InvalidReceiver(to);",
                        "        if (account != _msgSender() && !isApprovedForAll(account, _msgSender())) {",
                        "            revert ERC1155InsufficientApprovalForAll(_msgSender(), account);",
                        "        }",
                        "        if (account != _msgSender() && !isApprovedForAll(account, _msgSender())) {",
                        "            revert ERC1155InsufficientApprovalForAll(_msgSender(), account);",
                        "        }",
                        "    ) internal virtual override whenNotPaused {",
                        "                _totalSupply[id] -= amount;",
                        "contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {",
                        "    /**",
                        "     * @dev Indicates a failed `decreaseAllowance` request.",
                        "     */",
                        "    error ERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);",
                        "     * `requestedDecrease`.",
                        "    function decreaseAllowance(address spender, uint256 requestedDecrease) public virtual returns (bool) {",
                        "        if (currentAllowance < requestedDecrease) {",
                        "            revert ERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);",
                        "        }",
                        "            _approve(owner, spender, currentAllowance - requestedDecrease);",
                        "        if (from == address(0)) {",
                        "            revert ERC20InvalidSender(address(0));",
                        "        }",
                        "        if (to == address(0)) {",
                        "            revert ERC20InvalidReceiver(address(0));",
                        "        }",
                        "            if (fromBalance < amount) {",
                        "                revert ERC20InsufficientBalance(from, fromBalance, amount);",
                        "            }",
                        "        if (account == address(0)) {",
                        "            revert ERC20InvalidReceiver(address(0));",
                        "        }",
                        "        if (account == address(0)) {",
                        "            revert ERC20InvalidSender(address(0));",
                        "        }",
                        "        if (owner == address(0)) {",
                        "            revert ERC20InvalidApprover(address(0));",
                        "        }",
                        "        if (spender == address(0)) {",
                        "            revert ERC20InvalidSpender(address(0));",
                        "        }",
                        "            if (currentAllowance < amount) {",
                        "                revert ERC20InsufficientAllowance(spender, currentAllowance, amount);",
                        "            }",
                        "    /**",
                        "     * @dev Total supply cap has been exceeded.",
                        "     */",
                        "    error ERC20ExceededCap(uint256 increasedSupply, uint256 cap);",
                        "    /**",
                        "     * @dev The supplied cap is not a valid cap.",
                        "     */",
                        "    error ERC20InvalidCap(uint256 cap);",
                        "        if (cap_ == 0) {",
                        "            revert ERC20InvalidCap(0);",
                        "        }",
                        "        super._update(from, to, amount);",
                        "            uint256 maxSupply = cap();",
                        "            uint256 supply = totalSupply();",
                        "            if (supply > maxSupply) {",
                        "                revert ERC20ExceededCap(supply, maxSupply);",
                        "            }",
                        "    /**",
                        "     * @dev The loan token is not valid.",
                        "     */",
                        "    error ERC3156UnsupportedToken(address token);",
                        "    /**",
                        "     * @dev The requested loan exceeds the max loan amount for `token`.",
                        "     */",
                        "    error ERC3156ExceededMaxLoan(uint256 maxLoan);",
                        "    /**",
                        "     * @dev The receiver of a flashloan is not a valid {onFlashLoan} implementer.",
                        "     */",
                        "    error ERC3156InvalidReceiver(address receiver);",
                        "        if (token != address(this)) {",
                        "            revert ERC3156UnsupportedToken(token);",
                        "        }",
                        "        uint256 maxLoan = maxFlashLoan(token);",
                        "        if (amount > maxLoan) {",
                        "            revert ERC3156ExceededMaxLoan(maxLoan);",
                        "        }",
                        "        if (receiver.onFlashLoan(msg.sender, token, amount, fee, data) != _RETURN_VALUE) {",
                        "            revert ERC3156InvalidReceiver(address(receiver));",
                        "        }",
                        "    function _update(address from, address to, uint256 amount) internal virtual override whenNotPaused {",
                        "    /**",
                        "     * @dev Permit deadline has expired.",
                        "     */",
                        "    error ERC2612ExpiredSignature(uint256 deadline);",
                        "    /**",
                        "     * @dev Mismatched signature.",
                        "     */",
                        "    error ERC2612InvalidSigner(address signer, address owner);",
                        "        if (block.timestamp > deadline) {",
                        "            revert ERC2612ExpiredSignature(deadline);",
                        "        }",
                        "        if (signer != owner) {",
                        "            revert ERC2612InvalidSigner(signer, owner);",
                        "        }",
                        "    /**",
                        "     * @dev Total supply cap has been exceeded, introducing a risk of votes overflowing.",
                        "     */",
                        "    error ERC20ExceededSafeSupply(uint256 increasedSupply, uint256 cap);",
                        "            uint256 supply = totalSupply();",
                        "            uint256 cap = _maxSupply();",
                        "            if (supply > cap) {",
                        "                revert ERC20ExceededSafeSupply(supply, cap);",
                        "            }",
                        "    /**",
                        "     * @dev The underlying token couldn't be wrapped.",
                        "     */",
                        "    error ERC20InvalidUnderlying(address token);",
                        "        if (underlyingToken == this) {",
                        "            revert ERC20InvalidUnderlying(address(this));",
                        "        }",
                        "        if (sender == address(this)) {",
                        "            revert ERC20InvalidSender(address(this));",
                        "        }",
                        "    /**",
                        "     * @dev Attempted to deposit more assets than the max amount for `receiver`.",
                        "     */",
                        "    error ERC4626ExceededMaxDeposit(address receiver, uint256 assets, uint256 max);",
                        "    /**",
                        "     * @dev Attempted to mint more shares than the max amount for `receiver`.",
                        "     */",
                        "    error ERC4626ExceededMaxMint(address receiver, uint256 shares, uint256 max);",
                        "    /**",
                        "     * @dev Attempted to withdraw more assets than the max amount for `receiver`.",
                        "     */",
                        "    error ERC4626ExceededMaxWithdraw(address owner, uint256 assets, uint256 max);",
                        "    /**",
                        "     * @dev Attempted to redeem more shares than the max amount for `receiver`.",
                        "     */",
                        "    error ERC4626ExceededMaxRedeem(address owner, uint256 shares, uint256 max);",
                        "        uint256 maxAssets = maxDeposit(receiver);",
                        "        if (assets > maxAssets) {",
                        "            revert ERC4626ExceededMaxDeposit(receiver, assets, maxAssets);",
                        "        }",
                        "        uint256 maxShares = maxMint(receiver);",
                        "        if (shares > maxShares) {",
                        "            revert ERC4626ExceededMaxMint(receiver, shares, maxShares);",
                        "        }",
                        "        uint256 maxAssets = maxWithdraw(owner);",
                        "        if (assets > maxAssets) {",
                        "            revert ERC4626ExceededMaxWithdraw(owner, assets, maxAssets);",
                        "        }",
                        "        uint256 maxShares = maxRedeem(owner);",
                        "        if (shares > maxShares) {",
                        "            revert ERC4626ExceededMaxRedeem(owner, shares, maxShares);",
                        "        }",
                        "    /**",
                        "     * @dev An operation with an ERC20 token failed.",
                        "     */",
                        "    error SafeERC20FailedOperation(address token);",
                        "    /**",
                        "     * @dev Indicates a failed `decreaseAllowance` request.",
                        "     */",
                        "    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);",
                        "     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no value,",
                        "    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {",
                        "            uint256 currentAllowance = token.allowance(address(this), spender);",
                        "            if (currentAllowance < requestedDecrease) {",
                        "                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);",
                        "            }",
                        "            forceApprove(token, spender, currentAllowance - requestedDecrease);",
                        "        if (nonceAfter != nonceBefore + 1) {",
                        "            revert SafeERC20FailedOperation(address(token));",
                        "        }",
                        "        bytes memory returndata = address(token).functionCall(data);",
                        "        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {",
                        "            revert SafeERC20FailedOperation(address(token));",
                        "        }",
                        "contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Errors {",
                        "        if (owner == address(0)) {",
                        "            revert ERC721InvalidOwner(address(0));",
                        "        }",
                        "        if (owner == address(0)) {",
                        "            revert ERC721NonexistentToken(tokenId);",
                        "        }",
                        "        if (to == owner) {",
                        "            revert ERC721InvalidOperator(owner);",
                        "        }",
                        "        if (_msgSender() != owner && !isApprovedForAll(owner, _msgSender())) {",
                        "            revert ERC721InvalidApprover(_msgSender());",
                        "        }",
                        "        if (!_isApprovedOrOwner(_msgSender(), tokenId)) {",
                        "            revert ERC721InsufficientApproval(_msgSender(), tokenId);",
                        "        }",
                        "        if (!_isApprovedOrOwner(_msgSender(), tokenId)) {",
                        "            revert ERC721InsufficientApproval(_msgSender(), tokenId);",
                        "        }",
                        "        if (!_checkOnERC721Received(from, to, tokenId, data)) {",
                        "            revert ERC721InvalidReceiver(to);",
                        "        }",
                        "        if (!_checkOnERC721Received(address(0), to, tokenId, data)) {",
                        "            revert ERC721InvalidReceiver(to);",
                        "        }",
                        "        if (to == address(0)) {",
                        "            revert ERC721InvalidReceiver(address(0));",
                        "        }",
                        "        if (_exists(tokenId)) {",
                        "            revert ERC721InvalidSender(address(0));",
                        "        }",
                        "        if (_exists(tokenId)) {",
                        "            revert ERC721InvalidSender(address(0));",
                        "        }",
                        "        address owner = ownerOf(tokenId);",
                        "        if (owner != from) {",
                        "            revert ERC721IncorrectOwner(from, tokenId, owner);",
                        "        }",
                        "        if (to == address(0)) {",
                        "            revert ERC721InvalidReceiver(address(0));",
                        "        }",
                        "        owner = ownerOf(tokenId);",
                        "        if (owner != from) {",
                        "            revert ERC721IncorrectOwner(from, tokenId, owner);",
                        "        }",
                        "        if (owner == operator) {",
                        "            revert ERC721InvalidOperator(owner);",
                        "        }",
                        "        if (!_exists(tokenId)) {",
                        "            revert ERC721NonexistentToken(tokenId);",
                        "        }",
                        "                    revert ERC721InvalidReceiver(to);",
                        "        if (!_isApprovedOrOwner(_msgSender(), tokenId)) {",
                        "            revert ERC721InsufficientApproval(_msgSender(), tokenId);",
                        "        }",
                        "    /**",
                        "     * @dev Batch mint is restricted to the constructor.",
                        "     * Any batch mint not emitting the {IERC721-Transfer} event outside of the constructor",
                        "     * is non-ERC721 compliant.",
                        "     */",
                        "    error ERC721ForbiddenBatchMint();",
                        "    /**",
                        "     * @dev Exceeds the max amount of mints per batch.",
                        "     */",
                        "    error ERC721ExceededMaxBatchMint(uint256 batchSize, uint256 maxBatch);",
                        "    /**",
                        "     * @dev Individual minting is not allowed.",
                        "     */",
                        "    error ERC721ForbiddenMint();",
                        "    /**",
                        "     * @dev Batch burn is not supported.",
                        "     */",
                        "    error ERC721ForbiddenBatchBurn();",
                        "            if (address(this).code.length > 0) {",
                        "                revert ERC721ForbiddenBatchMint();",
                        "            }",
                        "            if (to == address(0)) {",
                        "                revert ERC721InvalidReceiver(address(0));",
                        "            }",
                        "            uint256 maxBatchSize = _maxBatchSize();",
                        "            if (batchSize > maxBatchSize) {",
                        "                revert ERC721ExceededMaxBatchMint(batchSize, maxBatchSize);",
                        "            }",
                        "        if (address(this).code.length == 0) {",
                        "            revert ERC721ForbiddenMint();",
                        "        }",
                        "            if (batchSize != 1) {",
                        "                revert ERC721ForbiddenBatchBurn();",
                        "            }",
                        "    /**",
                        "     * @dev An `owner`'s token query was out of bounds for `index`.",
                        "     *",
                        "     * NOTE: The owner being `address(0)` indicates a global out of bounds index.",
                        "     */",
                        "    error ERC721OutOfBoundsIndex(address owner, uint256 index);",
                        "    /**",
                        "     * @dev Batch mint is not allowed.",
                        "     */",
                        "    error ERC721EnumerableForbiddenBatchMint();",
                        "        if (index >= balanceOf(owner)) {",
                        "            revert ERC721OutOfBoundsIndex(owner, index);",
                        "        }",
                        "        if (index >= totalSupply()) {",
                        "            revert ERC721OutOfBoundsIndex(address(0), index);",
                        "        }",
                        "            revert ERC721EnumerableForbiddenBatchMint();",
                        "        _requireNotPaused();",
                        "        if (!_exists(tokenId)) {",
                        "            revert ERC721NonexistentToken(tokenId);",
                        "        }",
                        "    /**",
                        "     * @dev The received ERC721 token couldn't be wrapped.",
                        "     */",
                        "    error ERC721UnsupportedToken(address token);",
                        "            if (!_isApprovedOrOwner(_msgSender(), tokenId)) {",
                        "                revert ERC721InsufficientApproval(_msgSender(), tokenId);",
                        "            }",
                        "        if (address(underlying()) != _msgSender()) {",
                        "            revert ERC721UnsupportedToken(_msgSender());",
                        "        }",
                        "        address owner = underlying().ownerOf(tokenId);",
                        "        if (owner != address(this)) {",
                        "            revert ERC721IncorrectOwner(address(this), tokenId, owner);",
                        "        }",
                        "    /**",
                        "     * @dev The default royalty set is invalid (eg. (numerator / denominator) >= 1).",
                        "     */",
                        "    error ERC2981InvalidDefaultRoyalty(uint256 numerator, uint256 denominator);",
                        "    /**",
                        "     * @dev The default royalty receiver is invalid.",
                        "     */",
                        "    error ERC2981InvalidDefaultRoyaltyReceiver(address receiver);",
                        "    /**",
                        "     * @dev The royalty set for an specific `tokenId` is invalid (eg. (numerator / denominator) >= 1).",
                        "     */",
                        "    error ERC2981InvalidTokenRoyalty(uint256 tokenId, uint256 numerator, uint256 denominator);",
                        "    /**",
                        "     * @dev The royalty receiver for `tokenId` is invalid.",
                        "     */",
                        "    error ERC2981InvalidTokenRoyaltyReceiver(uint256 tokenId, address receiver);",
                        "        uint256 denominator = _feeDenominator();",
                        "        if (feeNumerator > denominator) {",
                        "            revert ERC2981InvalidDefaultRoyalty(feeNumerator, denominator);",
                        "        }",
                        "        if (receiver == address(0)) {",
                        "            revert ERC2981InvalidDefaultRoyaltyReceiver(address(0));",
                        "        }",
                        "        uint256 denominator = _feeDenominator();",
                        "        if (feeNumerator > denominator) {",
                        "            revert ERC2981InvalidTokenRoyalty(tokenId, feeNumerator, denominator);",
                        "        }",
                        "        if (receiver == address(0)) {",
                        "            revert ERC2981InvalidTokenRoyaltyReceiver(tokenId, address(0));",
                        "        }",
                        "    /**",
                        "     * @dev The ETH balance of the account is not enough to perform the operation.",
                        "     */",
                        "    error AddressInsufficientBalance(address account);",
                        "    /**",
                        "     * @dev There's no code at `target` (it is not a contract).",
                        "     */",
                        "    error AddressEmptyCode(address target);",
                        "    /**",
                        "     * @dev A call to an address target failed. The target may have reverted.",
                        "     */",
                        "    error FailedInnerCall();",
                        "        if (address(this).balance < amount) {",
                        "            revert AddressInsufficientBalance(address(this));",
                        "        }",
                        "        if (!success) {",
                        "            revert FailedInnerCall();",
                        "        }",
                        "        return functionCallWithValue(target, data, 0, defaultRevert);",
                        "     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with a",
                        "     * `customRevert` function as a fallback when `target` reverts.",
                        "     * Requirements:",
                        "     *",
                        "     * - `customRevert` must be a reverting function.",
                        "     *",
                        "     * _Available since v5.0._",
                        "        function() internal view customRevert",
                        "        return functionCallWithValue(target, data, 0, customRevert);",
                        "        return functionCallWithValue(target, data, value, defaultRevert);",
                        "     * with a `customRevert` function as a fallback revert reason when `target` reverts.",
                        "     * Requirements:",
                        "     *",
                        "     * - `customRevert` must be a reverting function.",
                        "     *",
                        "     * _Available since v5.0._",
                        "        function() internal view customRevert",
                        "        if (address(this).balance < value) {",
                        "            revert AddressInsufficientBalance(address(this));",
                        "        }",
                        "        return verifyCallResultFromTarget(target, success, returndata, customRevert);",
                        "        return functionStaticCall(target, data, defaultRevert);",
                        "        function() internal view customRevert",
                        "        return verifyCallResultFromTarget(target, success, returndata, customRevert);",
                        "        return functionDelegateCall(target, data, defaultRevert);",
                        "        function() internal view customRevert",
                        "        return verifyCallResultFromTarget(target, success, returndata, customRevert);",
                        "     * the revert reason or using the provided `customRevert`) in case of unsuccessful call or if target was not a contract.",
                        "     * _Available since v5.0._",
                        "        function() internal view customRevert",
                        "                if (target.code.length == 0) {",
                        "                    revert AddressEmptyCode(target);",
                        "                }",
                        "            _revert(returndata, customRevert);",
                        "     * revert reason or with a default revert error.",
                        "     *",
                        "     * _Available since v5.0._",
                        "     */",
                        "    function verifyCallResult(bool success, bytes memory returndata) internal view returns (bytes memory) {",
                        "        return verifyCallResult(success, returndata, defaultRevert);",
                        "    }",
                        "    /**",
                        "     * @dev Same as {xref-Address-verifyCallResult-bool-bytes-}[`verifyCallResult`], but with a",
                        "     * `customRevert` function as a fallback when `success` is `false`.",
                        "     * Requirements:",
                        "     *",
                        "     * - `customRevert` must be a reverting function.",
                        "     *",
                        "     * _Available since v5.0._",
                        "        function() internal view customRevert",
                        "    ) internal view returns (bytes memory) {",
                        "            _revert(returndata, customRevert);",
                        "    /**",
                        "     * @dev Default reverting function when no `customRevert` is provided in a function call.",
                        "     */",
                        "    function defaultRevert() internal pure {",
                        "        revert FailedInnerCall();",
                        "    }",
                        "    function _revert(bytes memory returndata, function() internal view customRevert) private view {",
                        "            customRevert();",
                        "            revert FailedInnerCall();",
                        "    /**",
                        "     * @dev Not enough balance for performing a CREATE2 deploy.",
                        "     */",
                        "    error Create2InsufficientBalance(uint256 balance, uint256 needed);",
                        "    /**",
                        "     * @dev There's no code to deploy.",
                        "     */",
                        "    error Create2EmptyBytecode();",
                        "    /**",
                        "     * @dev The deployment failed.",
                        "     */",
                        "    error Create2FailedDeployment();",
                        "        if (address(this).balance < amount) {",
                        "            revert Create2InsufficientBalance(address(this).balance, amount);",
                        "        }",
                        "        if (bytecode.length == 0) {",
                        "            revert Create2EmptyBytecode();",
                        "        }",
                        "        if (addr == address(0)) {",
                        "            revert Create2FailedDeployment();",
                        "        }",
                        "    /**",
                        "     * @dev The nonce used for an `account` is not the expected current nonce.",
                        "     */",
                        "    error InvalidAccountNonce(address account, uint256 currentNonce);",
                        "    /**",
                        "     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.",
                        "     */",
                        "    function _useCheckedNonce(address owner, uint256 nonce) internal virtual returns (uint256) {",
                        "        uint256 current = _useNonce(owner);",
                        "        if (nonce != current) {",
                        "            revert InvalidAccountNonce(owner, current);",
                        "        }",
                        "        return current;",
                        "    }",
                        " *         require(newImplementation.code.length > 0);",
                        "    /**",
                        "     * @dev The `value` string doesn't fit in the specified `length`.",
                        "     */",
                        "    error StringsInsufficientHexLength(uint256 value, uint256 length);",
                        "        uint256 localValue = value;",
                        "            buffer[i] = _SYMBOLS[localValue & 0xf];",
                        "            localValue >>= 4;",
                        "        }",
                        "        if (localValue != 0) {",
                        "            revert StringsInsufficientHexLength(value, length);",
                        "    /**",
                        "     * @dev The signature derives the `address(0)`.",
                        "     */",
                        "    error ECDSAInvalidSignature();",
                        "    /**",
                        "     * @dev The signature has an invalid length.",
                        "     */",
                        "    error ECDSAInvalidSignatureLength(uint256 length);",
                        "    /**",
                        "     * @dev The signature has an S value that is in the upper half order.",
                        "     */",
                        "    error ECDSAInvalidSignatureS(bytes32 s);",
                        "    function _throwError(RecoverError error, bytes32 errorArg) private pure {",
                        "            revert ECDSAInvalidSignature();",
                        "            revert ECDSAInvalidSignatureLength(uint256(errorArg));",
                        "            revert ECDSAInvalidSignatureS(errorArg);",
                        "    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {",
                        "            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));",
                        "        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);",
                        "        _throwError(error, errorArg);",
                        "    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {",
                        "        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);",
                        "        _throwError(error, errorArg);",
                        "    function tryRecover(",
                        "        bytes32 hash,",
                        "        uint8 v,",
                        "        bytes32 r,",
                        "        bytes32 s",
                        "    ) internal pure returns (address, RecoverError, bytes32) {",
                        "            return (address(0), RecoverError.InvalidSignatureS, s);",
                        "            return (address(0), RecoverError.InvalidSignature, bytes32(0));",
                        "        return (signer, RecoverError.NoError, bytes32(0));",
                        "        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);",
                        "        _throwError(error, errorArg);",
                        "    /**",
                        "     *@dev The multiproof provided is not valid.",
                        "     */",
                        "    error MerkleProofInvalidMultiproof();",
                        "        if (leavesLen + proof.length - 1 != totalHashes) {",
                        "            revert MerkleProofInvalidMultiproof();",
                        "        }",
                        "        if (leavesLen + proof.length - 1 != totalHashes) {",
                        "            revert MerkleProofInvalidMultiproof();",
                        "        }",
                        "        (address recovered, ECDSA.RecoverError error, ) = ECDSA.tryRecover(hash, signature);",
                        "    /**",
                        "     * @dev Muldiv operation overflow.",
                        "     */",
                        "    error MathOverflowedMulDiv();",
                        "            if (denominator <= prod1) {",
                        "                revert MathOverflowedMulDiv();",
                        "            }",
                        "    /**",
                        "     * @dev Value doesn't fit in an uint of `bits` size.",
                        "     */",
                        "    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);",
                        "    /**",
                        "     * @dev An int value doesn't fit in an uint of `bits` size.",
                        "     */",
                        "    error SafeCastOverflowedIntToUint(int256 value);",
                        "    /**",
                        "     * @dev Value doesn't fit in an int of `bits` size.",
                        "     */",
                        "    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);",
                        "    /**",
                        "     * @dev An uint value doesn't fit in an int of `bits` size.",
                        "     */",
                        "    error SafeCastOverflowedUintToInt(uint256 value);",
                        "        if (value > type(uint248).max) {",
                        "            revert SafeCastOverflowedUintDowncast(248, value);",
                        "        }",
                        "        if (value > type(uint240).max) {",
                        "            revert SafeCastOverflowedUintDowncast(240, value);",
                        "        }",
                        "        if (value > type(uint232).max) {",
                        "            revert SafeCastOverflowedUintDowncast(232, value);",
                        "        }",
                        "        if (value > type(uint224).max) {",
                        "            revert SafeCastOverflowedUintDowncast(224, value);",
                        "        }",
                        "        if (value > type(uint216).max) {",
                        "            revert SafeCastOverflowedUintDowncast(216, value);",
                        "        }",
                        "        if (value > type(uint208).max) {",
                        "            revert SafeCastOverflowedUintDowncast(208, value);",
                        "        }",
                        "        if (value > type(uint200).max) {",
                        "            revert SafeCastOverflowedUintDowncast(200, value);",
                        "        }",
                        "        if (value > type(uint192).max) {",
                        "            revert SafeCastOverflowedUintDowncast(192, value);",
                        "        }",
                        "        if (value > type(uint184).max) {",
                        "            revert SafeCastOverflowedUintDowncast(184, value);",
                        "        }",
                        "        if (value > type(uint176).max) {",
                        "            revert SafeCastOverflowedUintDowncast(176, value);",
                        "        }",
                        "        if (value > type(uint168).max) {",
                        "            revert SafeCastOverflowedUintDowncast(168, value);",
                        "        }",
                        "        if (value > type(uint160).max) {",
                        "            revert SafeCastOverflowedUintDowncast(160, value);",
                        "        }",
                        "        if (value > type(uint152).max) {",
                        "            revert SafeCastOverflowedUintDowncast(152, value);",
                        "        }",
                        "        if (value > type(uint144).max) {",
                        "            revert SafeCastOverflowedUintDowncast(144, value);",
                        "        }",
                        "        if (value > type(uint136).max) {",
                        "            revert SafeCastOverflowedUintDowncast(136, value);",
                        "        }",
                        "        if (value > type(uint128).max) {",
                        "            revert SafeCastOverflowedUintDowncast(128, value);",
                        "        }",
                        "        if (value > type(uint120).max) {",
                        "            revert SafeCastOverflowedUintDowncast(120, value);",
                        "        }",
                        "        if (value > type(uint112).max) {",
                        "            revert SafeCastOverflowedUintDowncast(112, value);",
                        "        }",
                        "        if (value > type(uint104).max) {",
                        "            revert SafeCastOverflowedUintDowncast(104, value);",
                        "        }",
                        "        if (value > type(uint96).max) {",
                        "            revert SafeCastOverflowedUintDowncast(96, value);",
                        "        }",
                        "        if (value > type(uint88).max) {",
                        "            revert SafeCastOverflowedUintDowncast(88, value);",
                        "        }",
                        "        if (value > type(uint80).max) {",
                        "            revert SafeCastOverflowedUintDowncast(80, value);",
                        "        }",
                        "        if (value > type(uint72).max) {",
                        "            revert SafeCastOverflowedUintDowncast(72, value);",
                        "        }",
                        "        if (value > type(uint64).max) {",
                        "            revert SafeCastOverflowedUintDowncast(64, value);",
                        "        }",
                        "        if (value > type(uint56).max) {",
                        "            revert SafeCastOverflowedUintDowncast(56, value);",
                        "        }",
                        "        if (value > type(uint48).max) {",
                        "            revert SafeCastOverflowedUintDowncast(48, value);",
                        "        }",
                        "        if (value > type(uint40).max) {",
                        "            revert SafeCastOverflowedUintDowncast(40, value);",
                        "        }",
                        "        if (value > type(uint32).max) {",
                        "            revert SafeCastOverflowedUintDowncast(32, value);",
                        "        }",
                        "        if (value > type(uint24).max) {",
                        "            revert SafeCastOverflowedUintDowncast(24, value);",
                        "        }",
                        "        if (value > type(uint16).max) {",
                        "            revert SafeCastOverflowedUintDowncast(16, value);",
                        "        }",
                        "        if (value > type(uint8).max) {",
                        "            revert SafeCastOverflowedUintDowncast(8, value);",
                        "        }",
                        "        if (value < 0) {",
                        "            revert SafeCastOverflowedIntToUint(value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(248, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(240, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(232, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(224, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(216, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(208, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(200, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(192, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(184, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(176, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(168, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(160, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(152, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(144, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(136, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(128, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(120, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(112, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(104, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(96, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(88, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(80, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(72, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(64, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(56, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(48, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(40, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(32, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(24, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(16, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(8, value);",
                        "        }",
                        "        if (value > uint256(type(int256).max)) {",
                        "            revert SafeCastOverflowedUintToInt(value);",
                        "        }",
                        "    /**",
                        "     * @dev A value was attempted to be inserted on a past checkpoint.",
                        "     */",
                        "    error CheckpointUnorderedInsertion();",
                        "            if (last._key > key) {",
                        "                revert CheckpointUnorderedInsertion();",
                        "            }",
                        "            if (last._key > key) {",
                        "                revert CheckpointUnorderedInsertion();",
                        "            }",
                        "    error QueueEmpty();",
                        "    error QueueOutOfBounds();",
                        "     * Reverts with `QueueEmpty` if the queue is empty.",
                        "        if (empty(deque)) revert QueueEmpty();",
                        "     * Reverts with `QueueEmpty` if the queue is empty.",
                        "        if (empty(deque)) revert QueueEmpty();",
                        "     * Reverts with `QueueEmpty` if the queue is empty.",
                        "        if (empty(deque)) revert QueueEmpty();",
                        "     * Reverts with `QueueEmpty` if the queue is empty.",
                        "        if (empty(deque)) revert QueueEmpty();",
                        "     * Reverts with `QueueOutOfBounds` if the index is out of bounds.",
                        "        if (idx >= deque._end) revert QueueOutOfBounds();",
                        "    /**",
                        "     * @dev Query for a nonexistent map key.",
                        "     */",
                        "    error EnumerableMapNonexistentKey(bytes32 key);",
                        "        if (value == 0 && !contains(map, key)) {",
                        "            revert EnumerableMapNonexistentKey(key);",
                        "        }"
                    ],
                    "del": [
                        "            revert(",
                        "                string(",
                        "                    abi.encodePacked(",
                        "                        \"AccessControl: account \",",
                        "                        Strings.toHexString(account),",
                        "                        \" is missing role \",",
                        "                        Strings.toHexString(uint256(role), 32)",
                        "                    )",
                        "                )",
                        "            );",
                        "     * - the caller must be `account`.",
                        "    function renounceRole(bytes32 role, address account) public virtual {",
                        "        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");",
                        "        _revokeRole(role, account);",
                        "        require(initialDefaultAdmin != address(0), \"AccessControl: 0 default admin\");",
                        "        require(role != DEFAULT_ADMIN_ROLE, \"AccessControl: can't directly grant default admin role\");",
                        "        require(role != DEFAULT_ADMIN_ROLE, \"AccessControl: can't directly revoke default admin role\");",
                        "            require(",
                        "                newDefaultAdmin == address(0) && _isScheduleSet(schedule) && _hasSchedulePassed(schedule),",
                        "                \"AccessControl: only can renounce in two delayed steps\"",
                        "            );",
                        "            require(defaultAdmin() == address(0), \"AccessControl: default admin already granted\");",
                        "        require(role != DEFAULT_ADMIN_ROLE, \"AccessControl: can't violate default admin rules\");",
                        "        require(_msgSender() == newDefaultAdmin, \"AccessControl: pending admin must accept\");",
                        "        require(_isScheduleSet(schedule) && _hasSchedulePassed(schedule), \"AccessControl: transfer delay not passed\");",
                        "     * - the caller must be `account`.",
                        "    function renounceRole(bytes32 role, address account) external;",
                        "        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");",
                        "        require(newOwner != address(0), \"Ownable: new owner is the zero address\");",
                        "        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");",
                        "        require(beneficiaryAddress != address(0), \"VestingWallet: beneficiary is zero address\");",
                        "        require(_msgSender() == _executor(), \"Governor: onlyGovernance\");",
                        "        require(_executor() == address(this), \"Governor: must send to executor\");",
                        "            revert(\"Governor: unknown proposal id\");",
                        "        require(",
                        "            getVotes(proposer, currentTimepoint - 1) >= proposalThreshold(),",
                        "            \"Governor: proposer votes below proposal threshold\"",
                        "        );",
                        "        require(targets.length == values.length, \"Governor: invalid proposal length\");",
                        "        require(targets.length == calldatas.length, \"Governor: invalid proposal length\");",
                        "        require(targets.length > 0, \"Governor: empty proposal\");",
                        "        require(_proposals[proposalId].voteStart == 0, \"Governor: proposal already exists\");",
                        "        require(",
                        "            currentState == ProposalState.Succeeded || currentState == ProposalState.Queued,",
                        "            \"Governor: proposal not successful\"",
                        "        );",
                        "        require(state(proposalId) == ProposalState.Pending, \"Governor: too late to cancel\");",
                        "        require(_msgSender() == _proposals[proposalId].proposer, \"Governor: only proposer can cancel\");",
                        "        string memory errorMessage = \"Governor: call reverted without message\";",
                        "            Address.verifyCallResult(success, returndata, errorMessage);",
                        "        require(",
                        "            currentState != ProposalState.Canceled &&",
                        "                currentState != ProposalState.Expired &&",
                        "                currentState != ProposalState.Executed,",
                        "            \"Governor: proposal not active\"",
                        "        );",
                        "        require(state(proposalId) == ProposalState.Active, \"Governor: vote not currently active\");",
                        "        Address.verifyCallResult(success, returndata, \"Governor: relay reverted without message\");",
                        "        require(targets.length == values.length, \"TimelockController: length mismatch\");",
                        "        require(targets.length == payloads.length, \"TimelockController: length mismatch\");",
                        "        require(!isOperation(id), \"TimelockController: operation already scheduled\");",
                        "        require(delay >= getMinDelay(), \"TimelockController: insufficient delay\");",
                        "        require(isOperationPending(id), \"TimelockController: operation cannot be cancelled\");",
                        "        require(targets.length == values.length, \"TimelockController: length mismatch\");",
                        "        require(targets.length == payloads.length, \"TimelockController: length mismatch\");",
                        "        (bool success, ) = target.call{value: value}(data);",
                        "        require(success, \"TimelockController: underlying transaction reverted\");",
                        "        require(isOperationReady(id), \"TimelockController: operation is not ready\");",
                        "        require(predecessor == bytes32(0) || isOperationDone(predecessor), \"TimelockController: missing dependency\");",
                        "        require(isOperationReady(id), \"TimelockController: operation is not ready\");",
                        "        require(msg.sender == address(this), \"TimelockController: caller must be timelock\");",
                        "        require(signatures.length == calldatas.length, \"GovernorBravo: invalid signatures length\");",
                        "        require(",
                        "            _msgSender() == proposer || getVotes(proposer, clock() - 1) < proposalThreshold(),",
                        "            \"GovernorBravo: proposer above threshold\"",
                        "        );",
                        "        require(!receipt.hasVoted, \"GovernorCompatibilityBravo: vote already cast\");",
                        "            revert(\"GovernorCompatibilityBravo: invalid vote type\");",
                        "        require(!proposalVote.hasVoted[account], \"GovernorVotingSimple: vote already cast\");",
                        "            revert(\"GovernorVotingSimple: invalid value for enum VoteType\");",
                        "        require(newVotingPeriod > 0, \"GovernorSettings: voting period too low\");",
                        "        require(state(proposalId) == ProposalState.Succeeded, \"Governor: proposal not successful\");",
                        "            require(",
                        "                !_timelock.queuedTransactions(keccak256(abi.encode(targets[i], values[i], \"\", calldatas[i], eta))),",
                        "                \"GovernorTimelockCompound: identical proposal action already queued\"",
                        "            );",
                        "        require(eta > 0, \"GovernorTimelockCompound: proposal not yet queued\");",
                        "        require(state(proposalId) == ProposalState.Succeeded, \"Governor: proposal not successful\");",
                        "        require(",
                        "            newQuorumNumerator <= quorumDenominator(),",
                        "            \"GovernorVotesQuorumFraction: quorumNumerator over quorumDenominator\"",
                        "        );",
                        "        require(clock() == block.number, \"Votes: broken clock mode\");",
                        "        require(timepoint < clock(), \"Votes: future lookup\");",
                        "        require(timepoint < clock(), \"Votes: future lookup\");",
                        "        require(block.timestamp <= expiry, \"Votes: signature expired\");",
                        "        require(nonce == _useNonce(signer), \"Votes: invalid nonce\");",
                        "        address signer = _hashTypedDataV4(",
                        "            keccak256(abi.encode(_TYPEHASH, req.from, req.to, req.value, req.gas, req.nonce, keccak256(req.data)))",
                        "        ).recover(signature);",
                        "        return _nonces[req.from] == req.nonce && signer == req.from;",
                        "        require(verify(req, signature), \"MinimalForwarder: signature does not match request\");",
                        "        require(instance != address(0), \"ERC1167: create failed\");",
                        "        require(instance != address(0), \"ERC1167: create2 failed\");",
                        "        require(newImplementation.code.length > 0, \"ERC1967: new implementation is not a contract\");",
                        "                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");",
                        "                revert(\"ERC1967Upgrade: new implementation is not UUPS\");",
                        "        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");",
                        "        require(newBeacon.code.length > 0, \"ERC1967: new beacon is not a contract\");",
                        "        require(",
                        "            IBeacon(newBeacon).implementation().code.length > 0,",
                        "            \"ERC1967: beacon implementation is not a contract\"",
                        "        );",
                        "        require(newImplementation.code.length > 0, \"UpgradeableBeacon: implementation is not a contract\");",
                        "                revert(\"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");",
                        "        require(msg.value == 0);",
                        "        require(",
                        "            (isTopLevelCall && _initialized < 1) || (address(this).code.length == 0 && _initialized == 1),",
                        "            \"Initializable: contract is already initialized\"",
                        "        );",
                        "        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");",
                        "        require(_initializing, \"Initializable: contract is not initializing\");",
                        "        require(!_initializing, \"Initializable: contract is initializing\");",
                        "        require(address(this) != __self, \"Function must be called through delegatecall\");",
                        "        require(_getImplementation() == __self, \"Function must be called through active proxy\");",
                        "        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");",
                        "    bool private _paused;",
                        "        require(!paused(), \"Pausable: paused\");",
                        "        require(paused(), \"Pausable: not paused\");",
                        "        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");",
                        "contract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {",
                        "        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");",
                        "        require(",
                        "            from == _msgSender() || isApprovedForAll(from, _msgSender()),",
                        "            \"ERC1155: caller is not token owner or approved\"",
                        "        );",
                        "        require(",
                        "            from == _msgSender() || isApprovedForAll(from, _msgSender()),",
                        "            \"ERC1155: caller is not token owner or approved\"",
                        "        );",
                        "        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");",
                        "                require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");",
                        "        require(to != address(0), \"ERC1155: transfer to the zero address\");",
                        "        require(from != address(0), \"ERC1155: transfer from the zero address\");",
                        "        require(to != address(0), \"ERC1155: transfer to the zero address\");",
                        "        require(from != address(0), \"ERC1155: transfer from the zero address\");",
                        "        require(to != address(0), \"ERC1155: mint to the zero address\");",
                        "        require(to != address(0), \"ERC1155: mint to the zero address\");",
                        "        require(from != address(0), \"ERC1155: burn from the zero address\");",
                        "        require(from != address(0), \"ERC1155: burn from the zero address\");",
                        "        require(owner != operator, \"ERC1155: setting approval status for self\");",
                        "                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");",
                        "                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");",
                        "                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");",
                        "                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");",
                        "        require(",
                        "            account == _msgSender() || isApprovedForAll(account, _msgSender()),",
                        "            \"ERC1155: caller is not token owner or approved\"",
                        "        );",
                        "        require(",
                        "            account == _msgSender() || isApprovedForAll(account, _msgSender()),",
                        "            \"ERC1155: caller is not token owner or approved\"",
                        "        );",
                        "    ) internal virtual override {",
                        "        require(!paused(), \"ERC1155Pausable: token transfer while paused\");",
                        "                uint256 supply = _totalSupply[id];",
                        "                require(supply >= amount, \"ERC1155: burn amount exceeds totalSupply\");",
                        "                    _totalSupply[id] = supply - amount;",
                        "contract ERC20 is Context, IERC20, IERC20Metadata {",
                        "     * `subtractedValue`.",
                        "    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {",
                        "        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");",
                        "            _approve(owner, spender, currentAllowance - subtractedValue);",
                        "        require(from != address(0), \"ERC20: transfer from the zero address\");",
                        "        require(to != address(0), \"ERC20: transfer to the zero address\");",
                        "            require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");",
                        "        require(account != address(0), \"ERC20: mint to the zero address\");",
                        "        require(account != address(0), \"ERC20: burn from the zero address\");",
                        "        require(owner != address(0), \"ERC20: approve from the zero address\");",
                        "        require(spender != address(0), \"ERC20: approve to the zero address\");",
                        "            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");",
                        "        require(cap_ > 0, \"ERC20Capped: cap is 0\");",
                        "            require(totalSupply() + amount <= cap(), \"ERC20Capped: cap exceeded\");",
                        "        super._update(from, to, amount);",
                        "        require(token == address(this), \"ERC20FlashMint: wrong token\");",
                        "        require(amount <= maxFlashLoan(token), \"ERC20FlashMint: amount exceeds maxFlashLoan\");",
                        "        require(",
                        "            receiver.onFlashLoan(msg.sender, token, amount, fee, data) == _RETURN_VALUE,",
                        "            \"ERC20FlashMint: invalid return value\"",
                        "        );",
                        "    function _update(address from, address to, uint256 amount) internal virtual override {",
                        "        require(!paused(), \"ERC20Pausable: token transfer while paused\");",
                        "        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");",
                        "        require(signer == owner, \"ERC20Permit: invalid signature\");",
                        "            require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");",
                        "        require(underlyingToken != this, \"ERC20Wrapper: cannot self wrap\");",
                        "        require(sender != address(this), \"ERC20Wrapper: wrapper can't deposit\");",
                        "        require(assets <= maxDeposit(receiver), \"ERC4626: deposit more than max\");",
                        "        require(shares <= maxMint(receiver), \"ERC4626: mint more than max\");",
                        "        require(assets <= maxWithdraw(owner), \"ERC4626: withdraw more than max\");",
                        "        require(shares <= maxRedeem(owner), \"ERC4626: redeem more than max\");",
                        "     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,",
                        "    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {",
                        "            uint256 oldAllowance = token.allowance(address(this), spender);",
                        "            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");",
                        "            forceApprove(token, spender, oldAllowance - value);",
                        "        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");",
                        "        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");",
                        "        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");",
                        "contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {",
                        "        require(owner != address(0), \"ERC721: address zero is not a valid owner\");",
                        "        require(owner != address(0), \"ERC721: invalid token ID\");",
                        "        require(to != owner, \"ERC721: approval to current owner\");",
                        "        require(",
                        "            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),",
                        "            \"ERC721: approve caller is not token owner or approved for all\"",
                        "        );",
                        "        //solhint-disable-next-line max-line-length",
                        "        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");",
                        "        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");",
                        "        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");",
                        "        require(",
                        "            _checkOnERC721Received(address(0), to, tokenId, data),",
                        "            \"ERC721: transfer to non ERC721Receiver implementer\"",
                        "        );",
                        "        require(to != address(0), \"ERC721: mint to the zero address\");",
                        "        require(!_exists(tokenId), \"ERC721: token already minted\");",
                        "        require(!_exists(tokenId), \"ERC721: token already minted\");",
                        "        require(ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");",
                        "        require(to != address(0), \"ERC721: transfer to the zero address\");",
                        "        require(ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");",
                        "        require(owner != operator, \"ERC721: approve to caller\");",
                        "        require(_exists(tokenId), \"ERC721: invalid token ID\");",
                        "                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");",
                        "        //solhint-disable-next-line max-line-length",
                        "        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");",
                        "            require(address(this).code.length == 0, \"ERC721Consecutive: batch minting restricted to constructor\");",
                        "            require(to != address(0), \"ERC721Consecutive: mint to the zero address\");",
                        "            require(batchSize <= _maxBatchSize(), \"ERC721Consecutive: batch too large\");",
                        "        require(address(this).code.length > 0, \"ERC721Consecutive: can't mint during construction\");",
                        "            require(batchSize == 1, \"ERC721Consecutive: batch burn not supported\");",
                        "        require(index < balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");",
                        "        require(index < totalSupply(), \"ERC721Enumerable: global index out of bounds\");",
                        "            revert(\"ERC721Enumerable: consecutive transfers not supported\");",
                        "        require(!paused(), \"ERC721Pausable: token transfer while paused\");",
                        "        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");",
                        "            require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721Wrapper: caller is not token owner or approved\");",
                        "        require(address(underlying()) == _msgSender(), \"ERC721Wrapper: caller is not underlying\");",
                        "        require(underlying().ownerOf(tokenId) == address(this), \"ERC721Wrapper: wrapper is not token owner\");",
                        "        require(feeNumerator <= _feeDenominator(), \"ERC2981: royalty fee will exceed salePrice\");",
                        "        require(receiver != address(0), \"ERC2981: invalid receiver\");",
                        "        require(feeNumerator <= _feeDenominator(), \"ERC2981: royalty fee will exceed salePrice\");",
                        "        require(receiver != address(0), \"ERC2981: Invalid parameters\");",
                        "        require(address(this).balance >= amount, \"Address: insufficient balance\");",
                        "        require(success, \"Address: unable to send value, recipient may have reverted\");",
                        "        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");",
                        "     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with",
                        "     * `errorMessage` as a fallback revert reason when `target` reverts.",
                        "     * _Available since v3.1._",
                        "        string memory errorMessage",
                        "        return functionCallWithValue(target, data, 0, errorMessage);",
                        "        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");",
                        "     * with `errorMessage` as a fallback revert reason when `target` reverts.",
                        "     * _Available since v3.1._",
                        "        string memory errorMessage",
                        "        require(address(this).balance >= value, \"Address: insufficient balance for call\");",
                        "        return verifyCallResultFromTarget(target, success, returndata, errorMessage);",
                        "        return functionStaticCall(target, data, \"Address: low-level static call failed\");",
                        "        string memory errorMessage",
                        "        return verifyCallResultFromTarget(target, success, returndata, errorMessage);",
                        "        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");",
                        "        string memory errorMessage",
                        "        return verifyCallResultFromTarget(target, success, returndata, errorMessage);",
                        "     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.",
                        "     * _Available since v4.8._",
                        "        string memory errorMessage",
                        "                require(target.code.length > 0, \"Address: call to non-contract\");",
                        "            _revert(returndata, errorMessage);",
                        "     * revert reason or using the provided one.",
                        "     * _Available since v4.3._",
                        "        string memory errorMessage",
                        "    ) internal pure returns (bytes memory) {",
                        "            _revert(returndata, errorMessage);",
                        "    function _revert(bytes memory returndata, string memory errorMessage) private pure {",
                        "            revert(errorMessage);",
                        "        require(address(this).balance >= amount, \"Create2: insufficient balance\");",
                        "        require(bytecode.length != 0, \"Create2: bytecode length is zero\");",
                        "        require(addr != address(0), \"Create2: Failed on deploy\");",
                        " *         require(newImplementation.code.length > 0, \"ERC1967: new implementation is not a contract\");",
                        "            buffer[i] = _SYMBOLS[value & 0xf];",
                        "            value >>= 4;",
                        "        require(value == 0, \"Strings: hex length insufficient\");",
                        "    function _throwError(RecoverError error) private pure {",
                        "            revert(\"ECDSA: invalid signature\");",
                        "            revert(\"ECDSA: invalid signature length\");",
                        "            revert(\"ECDSA: invalid signature 's' value\");",
                        "    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {",
                        "            return (address(0), RecoverError.InvalidSignatureLength);",
                        "        (address recovered, RecoverError error) = tryRecover(hash, signature);",
                        "        _throwError(error);",
                        "    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {",
                        "        (address recovered, RecoverError error) = tryRecover(hash, r, vs);",
                        "        _throwError(error);",
                        "    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {",
                        "            return (address(0), RecoverError.InvalidSignatureS);",
                        "            return (address(0), RecoverError.InvalidSignature);",
                        "        return (signer, RecoverError.NoError);",
                        "        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);",
                        "        _throwError(error);",
                        "        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");",
                        "        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");",
                        "        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);",
                        "            require(denominator > prod1, \"Math: mulDiv overflow\");",
                        "        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");",
                        "        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");",
                        "        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");",
                        "        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");",
                        "        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");",
                        "        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");",
                        "        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");",
                        "        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");",
                        "        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");",
                        "        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");",
                        "        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");",
                        "        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");",
                        "        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");",
                        "        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");",
                        "        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");",
                        "        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");",
                        "        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");",
                        "        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");",
                        "        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");",
                        "        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");",
                        "        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");",
                        "        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");",
                        "        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");",
                        "        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");",
                        "        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");",
                        "        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");",
                        "        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");",
                        "        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");",
                        "        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");",
                        "        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");",
                        "        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");",
                        "        require(value >= 0, \"SafeCast: value must be positive\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");",
                        "        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");",
                        "            require(last._key <= key, \"Checkpoint: decreasing keys\");",
                        "            require(last._key <= key, \"Checkpoint: decreasing keys\");",
                        "    error Empty();",
                        "    error OutOfBounds();",
                        "     * Reverts with `Empty` if the queue is empty.",
                        "        if (empty(deque)) revert Empty();",
                        "     * Reverts with `Empty` if the queue is empty.",
                        "        if (empty(deque)) revert Empty();",
                        "     * Reverts with `Empty` if the queue is empty.",
                        "        if (empty(deque)) revert Empty();",
                        "     * Reverts with `Empty` if the queue is empty.",
                        "        if (empty(deque)) revert Empty();",
                        "     * Reverts with `OutOfBounds` if the index is out of bounds.",
                        "        if (idx >= deque._end) revert OutOfBounds();",
                        "        require(value != 0 || contains(map, key), \"EnumerableMap: nonexistent key\");"
                    ]
                }
            }
        ],
        "- Use of `abi.encodeCall` in place of `abi.encodeWithSelector` and `abi.encodeWithSignature` for improved type-checking of parameters ([#4293](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4293))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4293": {
                    "add": [
                        "            calls[i] = abi.encodeCall(multicallToken.transfer, (recipients[i], amounts[i]));",
                        "            (bool success, ) = address(this).call(abi.encodeCall(this.countThisRecursive, (n - 1)));",
                        "            Address.functionDelegateCall(newImplementation, abi.encodeCall(this.upgradeTo, (oldImplementation)));",
                        "            abi.encodeCall(IERC20Metadata.decimals, ())",
                        "        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));",
                        "        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));",
                        "        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));",
                        "            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));",
                        "            abi.encodeCall(IERC1271.isValidSignature, (hash, signature))",
                        "        bytes memory encodedParams = abi.encodeCall(IERC165.supportsInterface, (interfaceId));"
                    ],
                    "del": [
                        "            calls[i] = abi.encodeWithSignature(\"transfer(address,uint256)\", recipients[i], amounts[i]);",
                        "            (bool success, ) = address(this).call(abi.encodeWithSignature(\"countThisRecursive(uint256)\", n - 1));",
                        "            Address.functionDelegateCall(",
                        "                newImplementation,",
                        "                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)",
                        "            );",
                        "            abi.encodeWithSelector(IERC20Metadata.decimals.selector)",
                        "        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));",
                        "        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));",
                        "        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);",
                        "            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));",
                        "            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)",
                        "        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);"
                    ]
                }
            }
        ],
        "- `Governor`, `Initializable`, and `UUPSUpgradeable`: Use internal functions in modifiers to optimize bytecode size. ([#4472](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4472))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4472": {
                    "add": [
                        "        _checkGovernance();",
                        "    /**",
                        "     * @dev Reverts if the `msg.sender` is not the executor. In case the executor is not this contract",
                        "     * itself, the function reverts if `msg.data` is not whitelisted as a result of an {execute}",
                        "     * operation. See {onlyGovernance}.",
                        "     */",
                        "    function _checkGovernance() internal virtual {",
                        "        if (_executor() != _msgSender()) {",
                        "            revert GovernorOnlyExecutor(_msgSender());",
                        "        }",
                        "        if (_executor() != address(this)) {",
                        "            bytes32 msgDataHash = keccak256(_msgData());",
                        "            while (_governanceCall.popFront() != msgDataHash) {}",
                        "        }",
                        "    }",
                        "        _checkInitializing();",
                        "        _;",
                        "    }",
                        "    /**",
                        "     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.",
                        "     */",
                        "    function _checkInitializing() internal view virtual {",
                        "        _checkProxy();",
                        "        _checkNotDelegated();",
                        "    /**",
                        "     * @dev Reverts if the execution is not performed via delegatecall or the execution",
                        "     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.",
                        "     * See {_onlyProxy}.",
                        "     */",
                        "    function _checkProxy() internal view virtual {",
                        "        if (",
                        "        ) {",
                        "            revert UUPSUnauthorizedCallContext();",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Reverts if the execution is performed via delegatecall.",
                        "     * See {notDelegated}.",
                        "     */",
                        "    function _checkNotDelegated() internal view virtual {",
                        "        if (address(this) != __self) {",
                        "            revert UUPSUnauthorizedCallContext();",
                        "        }",
                        "    }"
                    ],
                    "del": [
                        "        if (_executor() != _msgSender()) {",
                        "            revert GovernorOnlyExecutor(_msgSender());",
                        "        }",
                        "        if (_executor() != address(this)) {",
                        "            bytes32 msgDataHash = keccak256(_msgData());",
                        "            while (_governanceCall.popFront() != msgDataHash) {}",
                        "        }",
                        "        _;",
                        "        if (",
                        "        ) {",
                        "            revert UUPSUnauthorizedCallContext();",
                        "        }",
                        "        if (address(this) != __self) {",
                        "            revert UUPSUnauthorizedCallContext();",
                        "        }"
                    ]
                }
            }
        ],
        "- Upgradeable contracts now use namespaced storage (EIP-7201). ([#4534](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4534))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4534": {
                    "add": [
                        "    ) internal virtual returns (uint256 proposalId) {",
                        "        proposalId = hashProposal(targets, values, calldatas, keccak256(bytes(description)));",
                        "    IERC5805 private immutable _token;",
                        "        _token = IERC5805(address(tokenAddress));",
                        "    }",
                        "    /**",
                        "     * @dev The token that voting power is sourced from.",
                        "     */",
                        "    function token() public view virtual returns (IERC5805) {",
                        "        return _token;",
                        "        try token().clock() returns (uint48 timepoint) {",
                        "        try token().CLOCK_MODE() returns (string memory clockmode) {",
                        "        return token().getPastVotes(account, timepoint);",
                        "        return (token().getPastTotalSupply(timepoint) * quorumNumerator(timepoint)) / quorumDenominator();"
                    ],
                    "del": [
                        "    ) internal virtual returns (uint256) {",
                        "        uint256 proposalId = hashProposal(targets, values, calldatas, keccak256(bytes(description)));",
                        "        return proposalId;",
                        "    IERC5805 public immutable token;",
                        "        token = IERC5805(address(tokenAddress));",
                        "        try token.clock() returns (uint48 timepoint) {",
                        "        try token.CLOCK_MODE() returns (string memory clockmode) {",
                        "        return token.getPastVotes(account, timepoint);",
                        "        return (token.getPastTotalSupply(timepoint) * quorumNumerator(timepoint)) / quorumDenominator();"
                    ]
                }
            }
        ],
        "- Upgradeable contracts no longer transpile interfaces and libraries. ([#4628](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4628))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4628": {
                    "add": [
                        "contract Dummy1234 {}",
                        " *",
                        " * @custom:stateless",
                        " *",
                        " * @custom:stateless",
                        " *",
                        " * @custom:stateless",
                        " *",
                        " * @custom:stateless",
                        " *",
                        " * @custom:stateless",
                        " *",
                        " * @custom:stateless"
                    ],
                    "del": []
                }
            }
        ],
        "- `Ownable`: Prevent using address(0) as the initial owner. ([#4531](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4531))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4531": {
                    "add": [
                        "        if (initialOwner == address(0)) {",
                        "            revert OwnableInvalidOwner(address(0));",
                        "        }"
                    ],
                    "del": [
                        "    /**",
                        "     * @dev The `beneficiary` is not a valid account.",
                        "     */",
                        "    error VestingWalletInvalidBeneficiary(address beneficiary);",
                        "        if (beneficiary == address(0)) {",
                        "            revert VestingWalletInvalidBeneficiary(address(0));",
                        "        }"
                    ]
                }
            }
        ],
        "- `AccessControl`: Added a boolean return value to the internal `_grantRole` and `_revokeRole` functions indicating whether the role was granted or revoked. ([#4241](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4241))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4241": {
                    "add": [
                        "     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.",
                        "    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {",
                        "            return true;",
                        "        } else {",
                        "            return false;",
                        "     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.",
                        "    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {",
                        "            return true;",
                        "        } else {",
                        "            return false;",
                        "    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {",
                        "        return super._grantRole(role, account);",
                        "    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {",
                        "        return super._revokeRole(role, account);",
                        "     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships",
                        "    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {",
                        "        bool granted = super._grantRole(role, account);",
                        "        if (granted) {",
                        "            _roleMembers[role].add(account);",
                        "        }",
                        "        return granted;",
                        "     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships",
                        "    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {",
                        "        bool revoked = super._revokeRole(role, account);",
                        "        if (revoked) {",
                        "            _roleMembers[role].remove(account);",
                        "        }",
                        "        return revoked;"
                    ],
                    "del": [
                        "     * @dev Grants `role` to `account`.",
                        "    function _grantRole(bytes32 role, address account) internal virtual {",
                        "     * @dev Revokes `role` from `account`.",
                        "    function _revokeRole(bytes32 role, address account) internal virtual {",
                        "    function _grantRole(bytes32 role, address account) internal virtual override {",
                        "        super._grantRole(role, account);",
                        "    function _revokeRole(bytes32 role, address account) internal virtual override {",
                        "        super._revokeRole(role, account);",
                        "     * @dev Overload {_grantRole} to track enumerable memberships",
                        "    function _grantRole(bytes32 role, address account) internal virtual override {",
                        "        super._grantRole(role, account);",
                        "        _roleMembers[role].add(account);",
                        "     * @dev Overload {_revokeRole} to track enumerable memberships",
                        "    function _revokeRole(bytes32 role, address account) internal virtual override {",
                        "        super._revokeRole(role, account);",
                        "        _roleMembers[role].remove(account);"
                    ]
                }
            }
        ],
        "- `AccessManager`, `AccessManaged`, `GovernorTimelockAccess`: Ensure that calldata shorter than 4 bytes is not padded to 4 bytes. ([#4624](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4624))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4624": {
                    "add": [
                        "     * [WARNING]",
                        "     * Avoid adding this modifier to the https://docs.soliditylang.org/en/v0.8.20/contracts.html#receive-ether-function[`receive()`]",
                        "     * function or the https://docs.soliditylang.org/en/v0.8.20/contracts.html#fallback-function[`fallback()`]. These",
                        "     * functions are the only execution paths where a function selector cannot be unambiguosly determined from the calldata",
                        "     * since the selector defaults to `0x00000000` in the `receive()` function and similarly in the `fallback()` function",
                        "     * if no calldata is provided. (See {_checkCanCall}).",
                        "     * The `receive()` function will always panic whereas the `fallback()` may panic depending on the calldata length.",
                        "     * @dev Reverts if the caller is not allowed to call the function identified by a selector. Panics if the calldata",
                        "     * is less than 4 bytes long.",
                        "            bytes4(data[0:4])",
                        "    function canCall(",
                        "        address caller,",
                        "        address target,",
                        "        bytes4 selector",
                        "    ) public view virtual returns (bool immediate, uint32 delay) {",
                        "    function getAccess(",
                        "        uint64 roleId,",
                        "        address account",
                        "    ) public view virtual returns (uint48 since, uint32 currentDelay, uint32 pendingDelay, uint48 effect) {",
                        "        since = access.since;",
                        "        (currentDelay, pendingDelay, effect) = access.delay.getFull();",
                        "    function hasRole(",
                        "        uint64 roleId,",
                        "        address account",
                        "    ) public view virtual returns (bool isMember, uint32 executionDelay) {",
                        "            revert AccessManagerUnauthorizedCall(caller, target, _checkSelector(data));",
                        "            revert AccessManagerUnauthorizedCall(caller, target, _checkSelector(data));",
                        "        _executionId = _hashExecutionId(target, _checkSelector(data));",
                        "        bytes4 selector = _checkSelector(data);",
                        "    function _getAdminRestrictions(",
                        "        bytes calldata data",
                        "    ) private view returns (bool restricted, uint64 roleAdminId, uint32 executionDelay) {",
                        "        bytes4 selector = _checkSelector(data);",
                        "            return (true, getRoleAdmin(roleId), 0);",
                        "    function _canCallExtended(",
                        "        address caller,",
                        "        address target,",
                        "        bytes calldata data",
                        "    ) private view returns (bool immediate, uint32 delay) {",
                        "            return data.length < 4 ? (false, 0) : canCall(caller, target, _checkSelector(data));",
                        "        if (data.length < 4) {",
                        "            return (false, 0);",
                        "        }",
                        "            return (_isExecuting(address(this), _checkSelector(data)), 0);",
                        "    /**",
                        "     * @dev Extracts the selector from calldata. Panics if data is not at least 4 bytes",
                        "     */",
                        "    function _checkSelector(bytes calldata data) private pure returns (bytes4) {",
                        "        return bytes4(data[0:4]);",
                        "    }",
                        "            if (calldatas[i].length < 4) {",
                        "                continue;",
                        "            }",
                        "    event CalledFallback(address caller);",
                        "    fallback() external {",
                        "        emit CalledFallback(msg.sender);",
                        "    }"
                    ],
                    "del": [
                        "     * [NOTE]",
                        "     * Selector collisions are mitigated by scoping permissions per contract, but some edge cases must be considered:",
                        "     * * If the https://docs.soliditylang.org/en/v0.8.20/contracts.html#receive-ether-function[`receive()`] function",
                        "     * is restricted, any other function with a `0x00000000` selector will share permissions with `receive()`.",
                        "     * * Similarly, if there's no `receive()` function but a `fallback()` instead, the fallback might be called with",
                        "     * empty `calldata`, sharing the `0x00000000` selector permissions as well.",
                        "     * * For any other selector, if the restricted function is set on an upgradeable contract, an upgrade may remove",
                        "     * the restricted function and replace it with a new method whose selector replaces the last one, keeping the",
                        "     * previous permissions.",
                        "     * @dev Reverts if the caller is not allowed to call the function identified by a selector.",
                        "            bytes4(data)",
                        "    function canCall(address caller, address target, bytes4 selector) public view virtual returns (bool, uint32) {",
                        "    function getAccess(uint64 roleId, address account) public view virtual returns (uint48, uint32, uint32, uint48) {",
                        "        uint48 since = access.since;",
                        "        (uint32 currentDelay, uint32 pendingDelay, uint48 effect) = access.delay.getFull();",
                        "    function hasRole(uint64 roleId, address account) public view virtual returns (bool, uint32) {",
                        "            revert AccessManagerUnauthorizedCall(caller, target, bytes4(data[0:4]));",
                        "            revert AccessManagerUnauthorizedCall(caller, target, bytes4(data));",
                        "        _executionId = _hashExecutionId(target, bytes4(data));",
                        "        bytes4 selector = bytes4(data[0:4]);",
                        "    function _getAdminRestrictions(bytes calldata data) private view returns (bool, uint64, uint32) {",
                        "        bytes4 selector = bytes4(data);",
                        "            uint64 roleAdminId = getRoleAdmin(roleId);",
                        "            return (true, roleAdminId, 0);",
                        "    function _canCallExtended(address caller, address target, bytes calldata data) private view returns (bool, uint32) {",
                        "            bytes4 selector = bytes4(data);",
                        "            return canCall(caller, target, selector);",
                        "            return (_isExecuting(address(this), bytes4(data)), 0);"
                    ]
                }
            }
        ],
        "- `VestingWallet`: Fixed revert during 1 second time window when duration is 0. ([#4502](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4502))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4502": {
                    "add": [
                        " *",
                        " * NOTE: When using this contract with any token whose balance is adjusted automatically (i.e. a rebase token), make sure",
                        " * to account the supply/balance adjustment in the vesting schedule to ensure the vested amount is as intended.",
                        "        } else if (timestamp >= end()) {",
                        "    /**",
                        "     * @dev Initializes the contract with a trusted forwarder, which will be able to",
                        "     * invoke functions on this contract on behalf of other accounts.",
                        "     *",
                        "     * NOTE: The trusted forwarder can be replaced by overriding {trustedForwarder}.",
                        "     */",
                        "    constructor(address trustedForwarder_) {",
                        "        _trustedForwarder = trustedForwarder_;",
                        "    /**",
                        "     * @dev Returns the address of the trusted forwarder.",
                        "     */",
                        "    function trustedForwarder() public view virtual returns (address) {",
                        "        return _trustedForwarder;",
                        "    }",
                        "    /**",
                        "     * @dev Indicates whether any particular address is the trusted forwarder.",
                        "     */",
                        "        return forwarder == trustedForwarder();",
                        "    /**",
                        "     * @dev Override for `msg.sender`. Defaults to the original `msg.sender` whenever",
                        "     * a call is not performed by the trusted forwarder or the calldata length is less than",
                        "     * 20 bytes (an address length).",
                        "     */",
                        "    /**",
                        "     * @dev Override for `msg.data`. Defaults to the original `msg.data` whenever",
                        "     * a call is not performed by the trusted forwarder or the calldata length is less than",
                        "     * 20 bytes (an address length).",
                        "     */",
                        " * WARNING: Do not approve this contract to spend tokens. Anyone can use this forwarder",
                        " * to execute calls with an arbitrary calldata to any address. Any form of approval may",
                        " * result in a loss of funds for the approving party.",
                        " *",
                        " * NOTE: Batching requests includes an optional refund for unused `msg.value` that is achieved by",
                        " * performing a call with empty calldata. While this is within the bounds of ERC-2771 compliance,",
                        " * if the refund receiver happens to consider the forwarder a trusted forwarder, it MUST properly",
                        " * handle `msg.data.length == 0`. `ERC2771Context` in OpenZeppelin Contracts versions prior to 4.9.3",
                        " * do not handle this properly.",
                        " *",
                        "    /**",
                        "     * @dev The request target doesn't trust the `forwarder`.",
                        "     */",
                        "    error ERC2771UntrustfulTarget(address target, address forwarder);",
                        "     * A transaction is considered valid when the target trusts this forwarder, the request hasn't expired",
                        "     * (deadline is not met), and the signer matches the `from` parameter of the signed request.",
                        "        (bool isTrustedForwarder, bool active, bool signerMatch, ) = _validate(request);",
                        "        return isTrustedForwarder && active && signerMatch;",
                        "    ) internal view virtual returns (bool isTrustedForwarder, bool active, bool signerMatch, address signer) {",
                        "        (bool isValid, address recovered) = _recoverForwardRequestSigner(request);",
                        "        return (",
                        "            _isTrustedByTarget(request.to),",
                        "            request.deadline >= block.timestamp,",
                        "            isValid && recovered == request.from,",
                        "            recovered",
                        "        );",
                        "     * @dev Returns a tuple with the recovered the signer of an EIP712 forward request message hash",
                        "     * and a boolean indicating if the signature is valid.",
                        "     *",
                        "     * NOTE: The signature is considered valid if {ECDSA-tryRecover} indicates no recover error for it.",
                        "    function _recoverForwardRequestSigner(",
                        "        ForwardRequestData calldata request",
                        "    ) internal view virtual returns (bool, address) {",
                        "        (address recovered, ECDSA.RecoverError err, ) = _hashTypedDataV4(",
                        "            keccak256(",
                        "                abi.encode(",
                        "                    _FORWARD_REQUEST_TYPEHASH,",
                        "                    request.from,",
                        "                    request.to,",
                        "                    request.value,",
                        "                    request.gas,",
                        "                    nonces(request.from),",
                        "                    request.deadline,",
                        "                    keccak256(request.data)",
                        "            )",
                        "        ).tryRecover(request.signature);",
                        "        return (err == ECDSA.RecoverError.NoError, recovered);",
                        "        (bool isTrustedForwarder, bool active, bool signerMatch, address signer) = _validate(request);",
                        "            if (!isTrustedForwarder) {",
                        "                revert ERC2771UntrustfulTarget(request.to, address(this));",
                        "            }",
                        "            if (!active) {",
                        "        if (isTrustedForwarder && signerMatch && active) {",
                        "    /**",
                        "     * @dev Returns whether the target trusts this forwarder.",
                        "     *",
                        "     * This function performs a static call to the target contract calling the",
                        "     * {ERC2771Context-isTrustedForwarder} function.",
                        "     */",
                        "    function _isTrustedByTarget(address target) private view returns (bool) {",
                        "        bytes memory encodedParams = abi.encodeCall(ERC2771Context.isTrustedForwarder, (address(this)));",
                        "        bool success;",
                        "        uint256 returnSize;",
                        "        uint256 returnValue;",
                        "        assembly {",
                        "            success := staticcall(gas(), target, add(encodedParams, 0x20), mload(encodedParams), 0, 0x20)",
                        "            returnSize := returndatasize()",
                        "            returnValue := mload(0)",
                        "        }",
                        "        return success && returnSize >= 0x20 && returnValue > 0;",
                        "    }",
                        "contract CallReceiverMockTrustingForwarder is CallReceiverMock {",
                        "    address private _trustedForwarder;",
                        "    constructor(address trustedForwarder_) {",
                        "        _trustedForwarder = trustedForwarder_;",
                        "    }",
                        "    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {",
                        "        return forwarder == _trustedForwarder;",
                        "    }",
                        "}",
                        "contract UpgradeableBeaconMock is IBeacon {",
                        "    address public implementation;",
                        "    constructor(address impl) {",
                        "        implementation = impl;",
                        "    }",
                        "}",
                        "interface IProxyExposed {",
                        "    function $getBeacon() external view returns (address);",
                        "}",
                        "contract UpgradeableBeaconReentrantMock is IBeacon {",
                        "    error BeaconProxyBeaconSlotAddress(address beacon);",
                        "    function implementation() external view override returns (address) {",
                        "        revert BeaconProxyBeaconSlotAddress(IProxyExposed(msg.sender).$getBeacon());",
                        "    }",
                        "}",
                        "     * @dev Initializes the upgradeable proxy with an initial implementation specified by `implementation`.",
                        "     * If `_data` is nonempty, it's used as data in a delegate call to `implementation`. This will typically be an encoded",
                        "    constructor(address implementation, bytes memory _data) payable {",
                        "        ERC1967Utils.upgradeToAndCall(implementation, _data);",
                        "    function _implementation() internal view virtual override returns (address) {",
                        "     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1.",
                        "     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.",
                        "     * This is the keccak-256 hash of \"eip1967.proxy.beacon\" subtracted by 1.",
                        "        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;",
                        "     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract",
                        "     * if an upgrade doesn't perform an initialization call.",
                        "     * {UpgradeableBeacon} will check that this address is a contract.",
                        "        emit Upgraded(newImplementation);",
                        "     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function",
                        " * NOTE: This proxy does not inherit from {Context} deliberately. The {ProxyAdmin} of this contract won't send a",
                        " * meta-transaction in any way, and any other meta-transaction setup should be made in the implementation contract.",
                        " *",
                        "        ERC1967Utils.changeAdmin(_proxyAdmin());",
                        "    }",
                        "    /**",
                        "     * @dev Returns the admin of this proxy.",
                        "     */",
                        "    function _proxyAdmin() internal virtual returns (address) {",
                        "        return _admin;",
                        "        if (msg.sender == _proxyAdmin()) {",
                        "            if (msg.sig != ITransparentUpgradeableProxy.upgradeToAndCall.selector) {",
                        "            } else {",
                        "                _dispatchUpgradeToAndCall();",
                        "     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function",
                        "     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.",
                        "     *",
                        "     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value",
                        "     * is expected to be the implementation slot in ERC1967.",
                        "     * If `target` reverts with a revert reason or custom error, it is bubbled",
                        "     * up by this function (like regular Solidity function calls). However, if",
                        "     * the call reverted with no returned reason, this function reverts with a",
                        "     * {FailedInnerCall} error.",
                        "        return functionCallWithValue(target, data, 0);",
                        "        return verifyCallResultFromTarget(target, success, returndata);",
                        "        return verifyCallResultFromTarget(target, success, returndata);",
                        "        return verifyCallResultFromTarget(target, success, returndata);",
                        "     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target",
                        "     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an",
                        "     * unsuccessful call.",
                        "        bytes memory returndata",
                        "        if (!success) {",
                        "            _revert(returndata);",
                        "        } else {",
                        "            if (returndata.length == 0 && target.code.length == 0) {",
                        "                revert AddressEmptyCode(target);",
                        "     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the",
                        "     * revert reason or with a default {FailedInnerCall} error.",
                        "    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {",
                        "        if (!success) {",
                        "            _revert(returndata);",
                        "            return returndata;",
                        "     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.",
                        "    function _revert(bytes memory returndata) private pure {",
                        "    bytes16 private constant _HEX_DIGITS = \"0123456789abcdef\";",
                        "                    mstore8(ptr, byte(mod(value, 10), _HEX_DIGITS))",
                        "            buffer[i] = _HEX_DIGITS[localValue & 0xf];",
                        "    CallReceiverMockTrustingForwarder internal _receiver;",
                        "        _receiver = new CallReceiverMockTrustingForwarder(address(_erc2771Forwarder));"
                    ],
                    "del": [
                        "        } else if (timestamp > end()) {",
                        "    constructor(address trustedForwarder) {",
                        "        _trustedForwarder = trustedForwarder;",
                        "        return forwarder == _trustedForwarder;",
                        "     * A transaction is considered valid when it hasn't expired (deadline is not met), and the signer",
                        "     * matches the `from` parameter of the signed request.",
                        "        (bool alive, bool signerMatch, ) = _validate(request);",
                        "        return alive && signerMatch;",
                        "    ) internal view virtual returns (bool alive, bool signerMatch, address signer) {",
                        "        signer = _recoverForwardRequestSigner(request);",
                        "        return (request.deadline >= block.timestamp, signer == request.from, signer);",
                        "     * @dev Recovers the signer of an EIP712 message hash for a forward `request` and its corresponding `signature`.",
                        "     * See {ECDSA-recover}.",
                        "    function _recoverForwardRequestSigner(ForwardRequestData calldata request) internal view virtual returns (address) {",
                        "        return",
                        "            _hashTypedDataV4(",
                        "                keccak256(",
                        "                    abi.encode(",
                        "                        _FORWARD_REQUEST_TYPEHASH,",
                        "                        request.from,",
                        "                        request.to,",
                        "                        request.value,",
                        "                        request.gas,",
                        "                        nonces(request.from),",
                        "                        request.deadline,",
                        "                        keccak256(request.data)",
                        "                    )",
                        "            ).recover(request.signature);",
                        "        (bool alive, bool signerMatch, address signer) = _validate(request);",
                        "            if (!alive) {",
                        "        if (signerMatch && alive) {",
                        "/**",
                        " * @dev A mock to expose `Address`'s functions with function pointers.",
                        " */",
                        "contract AddressFnPointerMock {",
                        "    error CustomRevert();",
                        "    function functionCall(address target, bytes memory data) external returns (bytes memory) {",
                        "        return Address.functionCall(target, data, _customRevert);",
                        "    }",
                        "    function functionCallWithValue(address target, bytes memory data, uint256 value) external returns (bytes memory) {",
                        "        return Address.functionCallWithValue(target, data, value, _customRevert);",
                        "    }",
                        "    function functionStaticCall(address target, bytes memory data) external view returns (bytes memory) {",
                        "        return Address.functionStaticCall(target, data, _customRevert);",
                        "    }",
                        "    function functionDelegateCall(address target, bytes memory data) external returns (bytes memory) {",
                        "        return Address.functionDelegateCall(target, data, _customRevert);",
                        "    }",
                        "    function verifyCallResultFromTarget(",
                        "        address target,",
                        "        bool success,",
                        "        bytes memory returndata",
                        "    ) external view returns (bytes memory) {",
                        "        return Address.verifyCallResultFromTarget(target, success, returndata, _customRevert);",
                        "    }",
                        "    function verifyCallResult(bool success, bytes memory returndata) external view returns (bytes memory) {",
                        "        return Address.verifyCallResult(success, returndata, _customRevert);",
                        "    }",
                        "    function verifyCallResultVoid(bool success, bytes memory returndata) external view returns (bytes memory) {",
                        "        return Address.verifyCallResult(success, returndata, _customRevertVoid);",
                        "    }",
                        "    function _customRevert() internal pure {",
                        "        revert CustomRevert();",
                        "    }",
                        "    function _customRevertVoid() internal pure {}",
                        "}",
                        "contract UpgradeableBeaconMock is IBeacon {",
                        "    address public implementation;",
                        "    constructor(address impl) {",
                        "        implementation = impl;",
                        "    }",
                        "}",
                        "     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.",
                        "     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded",
                        "    constructor(address _logic, bytes memory _data) payable {",
                        "        ERC1967Utils.upgradeToAndCall(_logic, _data);",
                        "    function _implementation() internal view virtual override returns (address impl) {",
                        "     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is",
                        "     * validated in the constructor.",
                        "     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is",
                        "     * validated in the constructor.",
                        "     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1) and is validated in the constructor.",
                        "        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;",
                        "     * @dev Reverts if `msg.value` is not zero.",
                        "        _beforeFallback();",
                        "    /**",
                        "     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`",
                        "     * call, or as part of the Solidity `fallback` or `receive` functions.",
                        "     *",
                        "     * If overridden should call `super._beforeFallback()`.",
                        "     */",
                        "    function _beforeFallback() internal virtual {}",
                        "     * {BeaconProxy} will check that this address is a contract.",
                        "        emit Upgraded(newImplementation);",
                        "     * be the empty byte string if no function should be called, being impossible to invoke the `receive` function",
                        "        ERC1967Utils.changeAdmin(_admin);",
                        "        if (msg.sender == _admin) {",
                        "            if (msg.sig == ITransparentUpgradeableProxy.upgradeToAndCall.selector) {",
                        "                _dispatchUpgradeToAndCall();",
                        "            } else {",
                        "     * be the empty byte string if no function should be called, being impossible to invoke the `receive` function",
                        "     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.",
                        "     * If `target` reverts with a revert reason, it is bubbled up by this",
                        "     * function (like regular Solidity function calls).",
                        "        return functionCallWithValue(target, data, 0, defaultRevert);",
                        "    }",
                        "    /**",
                        "     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with a",
                        "     * `customRevert` function as a fallback when `target` reverts.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `customRevert` must be a reverting function.",
                        "     */",
                        "    function functionCall(",
                        "        address target,",
                        "        bytes memory data,",
                        "        function() internal view customRevert",
                        "    ) internal returns (bytes memory) {",
                        "        return functionCallWithValue(target, data, 0, customRevert);",
                        "        return functionCallWithValue(target, data, value, defaultRevert);",
                        "    }",
                        "    /**",
                        "     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but",
                        "     * with a `customRevert` function as a fallback revert reason when `target` reverts.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `customRevert` must be a reverting function.",
                        "     */",
                        "    function functionCallWithValue(",
                        "        address target,",
                        "        bytes memory data,",
                        "        uint256 value,",
                        "        function() internal view customRevert",
                        "    ) internal returns (bytes memory) {",
                        "        return verifyCallResultFromTarget(target, success, returndata, customRevert);",
                        "        return functionStaticCall(target, data, defaultRevert);",
                        "    }",
                        "    /**",
                        "     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],",
                        "     * but performing a static call.",
                        "     */",
                        "    function functionStaticCall(",
                        "        address target,",
                        "        bytes memory data,",
                        "        function() internal view customRevert",
                        "    ) internal view returns (bytes memory) {",
                        "        return verifyCallResultFromTarget(target, success, returndata, customRevert);",
                        "        return functionDelegateCall(target, data, defaultRevert);",
                        "    }",
                        "    /**",
                        "     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],",
                        "     * but performing a delegate call.",
                        "     */",
                        "    function functionDelegateCall(",
                        "        address target,",
                        "        bytes memory data,",
                        "        function() internal view customRevert",
                        "    ) internal returns (bytes memory) {",
                        "        return verifyCallResultFromTarget(target, success, returndata, customRevert);",
                        "     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling",
                        "     * the revert reason or using the provided `customRevert`) in case of unsuccessful call or if target was not a contract.",
                        "        bytes memory returndata,",
                        "        function() internal view customRevert",
                        "        if (success) {",
                        "            if (returndata.length == 0) {",
                        "                if (target.code.length == 0) {",
                        "                    revert AddressEmptyCode(target);",
                        "                }",
                        "        } else {",
                        "            _revert(returndata, customRevert);",
                        "     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the",
                        "     * revert reason or with a default revert error.",
                        "    function verifyCallResult(bool success, bytes memory returndata) internal view returns (bytes memory) {",
                        "        return verifyCallResult(success, returndata, defaultRevert);",
                        "    }",
                        "    /**",
                        "     * @dev Same as {xref-Address-verifyCallResult-bool-bytes-}[`verifyCallResult`], but with a",
                        "     * `customRevert` function as a fallback when `success` is `false`.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `customRevert` must be a reverting function.",
                        "     */",
                        "    function verifyCallResult(",
                        "        bool success,",
                        "        bytes memory returndata,",
                        "        function() internal view customRevert",
                        "    ) internal view returns (bytes memory) {",
                        "        if (success) {",
                        "            return returndata;",
                        "            _revert(returndata, customRevert);",
                        "     * @dev Default reverting function when no `customRevert` is provided in a function call.",
                        "    function defaultRevert() internal pure {",
                        "        revert FailedInnerCall();",
                        "    }",
                        "    function _revert(bytes memory returndata, function() internal view customRevert) private view {",
                        "            customRevert();",
                        "    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";",
                        "                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))",
                        "            buffer[i] = _SYMBOLS[localValue & 0xf];",
                        "    CallReceiverMock internal _receiver;",
                        "        _receiver = new CallReceiverMock();"
                    ]
                }
            }
        ],
        "- `VestingWallet`: Use `Ownable` instead of an immutable `beneficiary`. ([#4508](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4508))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4508": {
                    "add": [
                        " * @dev A vesting wallet is an ownable contract that can receive native currency and ERC20 tokens, and release these",
                        " * assets to the wallet owner, also referred to as \"beneficiary\", according to a vesting schedule.",
                        " * Any assets transferred to this contract will follow the vesting schedule as if they were locked from the beginning.",
                        " * NOTE: Since the wallet is {Ownable}, and ownership can be transferred, it is possible to sell unvested tokens.",
                        " * Preventing this in a smart contract is difficult, considering that: 1) a beneficiary address could be a",
                        " * counterfactually deployed contract, 2) there is likely to be a migration path for EOAs to become contracts in the",
                        " * near future.",
                        " *",
                        "contract VestingWallet is Context, Ownable {",
                        "     * @dev Sets the sender as the initial owner, the beneficiary as the pending owner, the start timestamp and the",
                        "     * vesting duration of the vesting wallet.",
                        "    constructor(address beneficiary, uint64 startTimestamp, uint64 durationSeconds) payable Ownable(beneficiary) {",
                        "        if (beneficiary == address(0)) {",
                        "        Address.sendValue(payable(owner()), amount);",
                        "        SafeERC20.safeTransfer(IERC20(token), owner(), amount);"
                    ],
                    "del": [
                        " * @title VestingWallet",
                        " * @dev This contract handles the vesting of Eth and ERC20 tokens for a given beneficiary. Custody of multiple tokens",
                        " * can be given to this contract, which will release the token to the beneficiary following a given vesting schedule.",
                        " * The vesting schedule is customizable through the {vestedAmount} function.",
                        " * Any token transferred to this contract will follow the vesting schedule as if they were locked from the beginning.",
                        "contract VestingWallet is Context {",
                        "    address private immutable _beneficiary;",
                        "     * @dev Set the beneficiary, start timestamp and vesting duration of the vesting wallet.",
                        "    constructor(address beneficiaryAddress, uint64 startTimestamp, uint64 durationSeconds) payable {",
                        "        if (beneficiaryAddress == address(0)) {",
                        "        _beneficiary = beneficiaryAddress;",
                        "    /**",
                        "     * @dev Getter for the beneficiary address.",
                        "     */",
                        "    function beneficiary() public view virtual returns (address) {",
                        "        return _beneficiary;",
                        "    }",
                        "        Address.sendValue(payable(beneficiary()), amount);",
                        "        SafeERC20.safeTransfer(IERC20(token), beneficiary(), amount);"
                    ]
                }
            }
        ],
        "- `Governor`: Optimized use of storage for proposal data ([#4268](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4268))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4268": {
                    "add": [
                        "        uint48 voteStart;",
                        "        uint32 voteDuration;",
                        "        ProposalCore memory proposal = _proposals[proposalId];",
                        "        return _proposals[proposalId].voteStart + _proposals[proposalId].voteDuration;",
                        "        uint256 duration = votingPeriod();",
                        "            voteStart: SafeCast.toUint48(snapshot),",
                        "            voteDuration: SafeCast.toUint32(duration),",
                        "            canceled: false",
                        "            snapshot + duration,",
                        "        uint256 weight = _getVotes(account, proposalSnapshot(proposalId), params);",
                        "     *",
                        "     * NOTE: While this interface returns a uint256, timepoints are stored as uint48 following the ERC-6372 clock type.",
                        "     * Consequently this value must fit in a uint48 (when added to the current clock). See {IERC6372-clock}.",
                        "     *",
                        "     * NOTE: This value is stored when the proposal is submitted so that possible changes to the value do not affect",
                        "     * proposals that have already been submitted. The type used to save it is a uint32. Consequently, while this",
                        "     * interface returns a uint256, the value it returns should fit in a uint32.",
                        "    uint48 private _voteExtension;",
                        "    mapping(uint256 => uint48) private _extendedDeadlines;",
                        "    constructor(uint48 initialVoteExtension) {",
                        "            uint48 extendedDeadline = clock() + lateQuorumVoteExtension();",
                        "    function lateQuorumVoteExtension() public view virtual returns (uint48) {",
                        "    function setLateQuorumVoteExtension(uint48 newVoteExtension) public virtual onlyGovernance {",
                        "    function _setLateQuorumVoteExtension(uint48 newVoteExtension) internal virtual {",
                        "    uint48 private _votingDelay;",
                        "    uint32 private _votingPeriod;",
                        "    constructor(uint48 initialVotingDelay, uint32 initialVotingPeriod, uint256 initialProposalThreshold) {",
                        "    function setVotingDelay(uint48 newVotingDelay) public virtual onlyGovernance {",
                        "    function setVotingPeriod(uint32 newVotingPeriod) public virtual onlyGovernance {",
                        "    function _setVotingDelay(uint48 newVotingDelay) internal virtual {",
                        "    function _setVotingPeriod(uint32 newVotingPeriod) internal virtual {",
                        "    mapping(uint256 => uint256) private _proposalTimelocks;",
                        "        _proposalTimelocks[proposalId] = eta;"
                    ],
                    "del": [
                        "        uint64 voteStart;",
                        "        bytes4 __gap_unused0;",
                        "        uint64 voteEnd;",
                        "        bytes24 __gap_unused1;",
                        "        ProposalCore storage proposal = _proposals[proposalId];",
                        "        return _proposals[proposalId].voteEnd;",
                        "        uint256 deadline = snapshot + votingPeriod();",
                        "            voteStart: SafeCast.toUint64(snapshot),",
                        "            voteEnd: SafeCast.toUint64(deadline),",
                        "            canceled: false,",
                        "            __gap_unused0: 0,",
                        "            __gap_unused1: 0",
                        "            deadline,",
                        "        ProposalCore storage proposal = _proposals[proposalId];",
                        "        uint256 weight = _getVotes(account, proposal.voteStart, params);",
                        "    uint64 private _voteExtension;",
                        "    mapping(uint256 => uint64) private _extendedDeadlines;",
                        "    constructor(uint64 initialVoteExtension) {",
                        "            uint64 extendedDeadline = clock() + lateQuorumVoteExtension();",
                        "    function lateQuorumVoteExtension() public view virtual returns (uint64) {",
                        "    function setLateQuorumVoteExtension(uint64 newVoteExtension) public virtual onlyGovernance {",
                        "    function _setLateQuorumVoteExtension(uint64 newVoteExtension) internal virtual {",
                        "    uint256 private _votingDelay;",
                        "    uint256 private _votingPeriod;",
                        "    constructor(uint256 initialVotingDelay, uint256 initialVotingPeriod, uint256 initialProposalThreshold) {",
                        "    function setVotingDelay(uint256 newVotingDelay) public virtual onlyGovernance {",
                        "    function setVotingPeriod(uint256 newVotingPeriod) public virtual onlyGovernance {",
                        "    function _setVotingDelay(uint256 newVotingDelay) internal virtual {",
                        "    function _setVotingPeriod(uint256 newVotingPeriod) internal virtual {",
                        "    mapping(uint256 => uint64) private _proposalTimelocks;",
                        "        _proposalTimelocks[proposalId] = SafeCast.toUint64(eta);"
                    ]
                }
            }
        ],
        "- `Governor`: Added validation in ERC1155 and ERC721 receiver hooks to ensure Governor is the executor. ([#4314](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4314))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4314": {
                    "add": [
                        "        if (_executor() != _msgSender()) {",
                        "     * Receiving tokens is disabled if the governance executor is other than the governor itself (eg. when using with a timelock).",
                        "        if (_executor() != address(this)) {",
                        "            revert GovernorDisabledDeposit();",
                        "        }",
                        "     * Receiving tokens is disabled if the governance executor is other than the governor itself (eg. when using with a timelock).",
                        "        if (_executor() != address(this)) {",
                        "            revert GovernorDisabledDeposit();",
                        "        }",
                        "     * Receiving tokens is disabled if the governance executor is other than the governor itself (eg. when using with a timelock).",
                        "        if (_executor() != address(this)) {",
                        "            revert GovernorDisabledDeposit();",
                        "        }",
                        "    enum RevertType {",
                        "        None,",
                        "        Empty,",
                        "        String,",
                        "        Custom",
                        "    }",
                        "    RevertType private _recReverts;",
                        "    RevertType private _batReverts;",
                        "    error ERC1155ReceiverMockError();",
                        "    constructor(bytes4 recRetval, RevertType recReverts, bytes4 batRetval, RevertType batReverts) {",
                        "        if (_recReverts == RevertType.Empty) {",
                        "            revert();",
                        "        } else if (_recReverts == RevertType.String) {",
                        "            revert(\"ERC1155ReceiverMock: reverting on receive\");",
                        "        } else if (_recReverts == RevertType.Custom) {",
                        "            revert ERC1155ReceiverMockError();",
                        "        }",
                        "        if (_batReverts == RevertType.Empty) {",
                        "            revert();",
                        "        } else if (_batReverts == RevertType.String) {",
                        "            revert(\"ERC1155ReceiverMock: reverting on batch receive\");",
                        "        } else if (_batReverts == RevertType.Custom) {",
                        "            revert ERC1155ReceiverMockError();",
                        "        }",
                        "            } catch (bytes memory reason) {",
                        "                if (reason.length == 0) {",
                        "                    revert ERC1155InvalidReceiver(to);",
                        "                } else {",
                        "                    assembly {",
                        "                        revert(add(32, reason), mload(reason))",
                        "                    }",
                        "                }",
                        "            } catch (bytes memory reason) {",
                        "                if (reason.length == 0) {",
                        "                    revert ERC1155InvalidReceiver(to);",
                        "                } else {",
                        "                    assembly {",
                        "                        revert(add(32, reason), mload(reason))",
                        "                    }",
                        "                }"
                    ],
                    "del": [
                        "        if (_msgSender() != _executor()) {",
                        "    bool private _recReverts;",
                        "    bool private _batReverts;",
                        "    constructor(bytes4 recRetval, bool recReverts, bytes4 batRetval, bool batReverts) {",
                        "        require(!_recReverts, \"ERC1155ReceiverMock: reverting on receive\");",
                        "        require(!_batReverts, \"ERC1155ReceiverMock: reverting on batch receive\");",
                        "            } catch Error(string memory reason) {",
                        "                revert(reason);",
                        "            } catch {",
                        "                revert ERC1155InvalidReceiver(to);",
                        "            } catch Error(string memory reason) {",
                        "                revert(reason);",
                        "            } catch {",
                        "                revert ERC1155InvalidReceiver(to);"
                    ]
                }
            }
        ],
        "- `Governor`: Added `voter` and `nonce` parameters in signed ballots, to avoid forging signatures for random addresses, prevent signature replay, and allow invalidating signatures. Add `voter` as a new parameter in the `castVoteBySig` and `castVoteWithReasonAndParamsBySig` functions. ([#4378](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4378))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4378": {
                    "add": [
                        "abstract contract Governor is Context, ERC165, EIP712, Nonces, IGovernor, IERC721Receiver, IERC1155Receiver {",
                        "    bytes32 public constant BALLOT_TYPEHASH =",
                        "        keccak256(\"Ballot(uint256 proposalId,uint8 support,address voter,uint256 nonce)\");",
                        "        keccak256(",
                        "            \"ExtendedBallot(uint256 proposalId,uint8 support,address voter,uint256 nonce,string reason,bytes params)\"",
                        "        );",
                        "        address voter,",
                        "        address signer = ECDSA.recover(",
                        "            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support, voter, _useNonce(voter)))),",
                        "        if (voter != signer) {",
                        "            revert GovernorInvalidSigner(signer, voter);",
                        "        }",
                        "        return _castVote(proposalId, signer, support, \"\");",
                        "        address voter,",
                        "        address signer = ECDSA.recover(",
                        "                        voter,",
                        "                        _useNonce(voter),",
                        "        if (voter != signer) {",
                        "            revert GovernorInvalidSigner(signer, voter);",
                        "        }",
                        "        return _castVote(proposalId, signer, support, reason, params);",
                        "    /**",
                        "     * @dev The `voter` doesn't match with the recovered `signer`.",
                        "     */",
                        "    error GovernorInvalidSigner(address signer, address voter);",
                        "        address voter,",
                        "        address voter,"
                    ],
                    "del": [
                        "abstract contract Governor is Context, ERC165, EIP712, IGovernor, IERC721Receiver, IERC1155Receiver {",
                        "    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,uint8 support)\");",
                        "        keccak256(\"ExtendedBallot(uint256 proposalId,uint8 support,string reason,bytes params)\");",
                        "        address voter = ECDSA.recover(",
                        "            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),",
                        "        return _castVote(proposalId, voter, support, \"\");",
                        "        address voter = ECDSA.recover(",
                        "        return _castVote(proposalId, voter, support, reason, params);"
                    ]
                }
            }
        ],
        "- `Governor`: Added support for casting votes with ERC-1271 signatures by using a `bytes memory signature` instead of `r`, `s` and `v` arguments in the `castVoteBySig` and `castVoteWithReasonAndParamsBySig` functions. ([#4418](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4418))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4418": {
                    "add": [
                        "        bytes memory signature",
                        "        bool valid = SignatureChecker.isValidSignatureNow(",
                        "            voter,",
                        "            signature",
                        "        if (!valid) {",
                        "            revert GovernorInvalidSignature(voter);",
                        "        return _castVote(proposalId, voter, support, \"\");",
                        "        bytes memory signature",
                        "        bool valid = SignatureChecker.isValidSignatureNow(",
                        "            voter,",
                        "            signature",
                        "        if (!valid) {",
                        "            revert GovernorInvalidSignature(voter);",
                        "        return _castVote(proposalId, voter, support, reason, params);",
                        "     * @dev The provided signature is not valid for the expected `voter`.",
                        "     * If the `voter` is a contract, the signature is not valid using {IERC1271-isValidSignature}.",
                        "    error GovernorInvalidSignature(address voter);",
                        "     * @dev Cast a vote using the voter's signature, including ERC-1271 signature support.",
                        "        bytes memory signature",
                        "     * @dev Cast a vote with a reason and additional encoded parameters using the voter's signature,",
                        "     * including ERC-1271 signature support.",
                        "        bytes memory signature",
                        " * Argent and Safe Wallet (previously Gnosis Safe)."
                    ],
                    "del": [
                        "        uint8 v,",
                        "        bytes32 r,",
                        "        bytes32 s",
                        "        address signer = ECDSA.recover(",
                        "            v,",
                        "            r,",
                        "            s",
                        "        if (voter != signer) {",
                        "            revert GovernorInvalidSigner(signer, voter);",
                        "        return _castVote(proposalId, signer, support, \"\");",
                        "        uint8 v,",
                        "        bytes32 r,",
                        "        bytes32 s",
                        "        address signer = ECDSA.recover(",
                        "            v,",
                        "            r,",
                        "            s",
                        "        if (voter != signer) {",
                        "            revert GovernorInvalidSigner(signer, voter);",
                        "        return _castVote(proposalId, signer, support, reason, params);",
                        "     * @dev The `voter` doesn't match with the recovered `signer`.",
                        "    error GovernorInvalidSigner(address signer, address voter);",
                        "     * @dev Cast a vote using the user's cryptographic signature.",
                        "        uint8 v,",
                        "        bytes32 r,",
                        "        bytes32 s",
                        "     * @dev Cast a vote with a reason and additional encoded parameters using the user's cryptographic signature.",
                        "        uint8 v,",
                        "        bytes32 r,",
                        "        bytes32 s",
                        " * Argent and Gnosis Safe."
                    ]
                }
            }
        ],
        "- `GovernorTimelockAccess`: Added a module to connect a governor with an instance of `AccessManager`, allowing the governor to make calls that are delay-restricted by the manager using the normal `queue` workflow. ([#4523](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4523))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4523": {
                    "add": [
                        "    struct Schedule {",
                        "        uint48 timepoint;",
                        "        uint32 nonce;",
                        "    }",
                        "    mapping(bytes32 operationId => Schedule) private _schedules;",
                        "        uint48 timepoint = _schedules[id].timepoint;",
                        "    /**",
                        "     * @dev Return the nonce for the latest scheduled operation with a given id. Returns 0 if the operation has never",
                        "     * been scheduled.",
                        "     */",
                        "    function getNonce(bytes32 id) public view virtual returns (uint32) {",
                        "        return _schedules[id].nonce;",
                        "    }",
                        "     * Returns the `operationId` that was scheduled. Since this value is a hash of the parameters, it can reoccur when",
                        "     * the same parameters are used; if this is relevant, the returned `nonce` can be used to uniquely identify this",
                        "     * scheduled operation from other occurrences of the same `operationId` in invocations of {relay} and {cancel}.",
                        "     *",
                        "    function schedule(",
                        "        address target,",
                        "        bytes calldata data,",
                        "        uint48 when",
                        "    ) public virtual returns (bytes32 operationId, uint32 nonce) {",
                        "        if (when == 0) {",
                        "            when = minWhen;",
                        "        }",
                        "        if (!allowed && (setback == 0 || when < minWhen)) {",
                        "        operationId = _hashOperation(caller, target, data);",
                        "        uint48 prevTimepoint = _schedules[operationId].timepoint;",
                        "        unchecked {",
                        "            nonce = _schedules[operationId].nonce + 1;",
                        "        }",
                        "        _schedules[operationId].timepoint = when;",
                        "        _schedules[operationId].nonce = nonce;",
                        "        emit OperationScheduled(operationId, nonce, when, caller, target, data);",
                        "     * Returns the nonce that identifies the previously scheduled operation that is relayed, or 0 if the",
                        "     * operation wasn't previously scheduled (if the caller doesn't have an execution delay).",
                        "     *",
                        "    function relay(address target, bytes calldata data) public payable virtual returns (uint32) {",
                        "        uint32 nonce;",
                        "            nonce = _consumeScheduledOp(operationId);",
                        "        return nonce;",
                        "     *",
                        "     * Returns the nonce of the scheduled operation that is consumed.",
                        "    function _consumeScheduledOp(bytes32 operationId) internal virtual returns (uint32) {",
                        "        uint48 timepoint = _schedules[operationId].timepoint;",
                        "        uint32 nonce = _schedules[operationId].nonce;",
                        "        emit OperationExecuted(operationId, nonce);",
                        "        return nonce;",
                        "     * @dev Cancel a scheduled (delayed) operation. Returns the nonce that identifies the previously scheduled",
                        "     * operation that is cancelled.",
                        "    function cancel(address caller, address target, bytes calldata data) public virtual returns (uint32) {",
                        "        if (_schedules[operationId].timepoint == 0) {",
                        "        delete _schedules[operationId].timepoint;",
                        "        uint32 nonce = _schedules[operationId].nonce;",
                        "        emit OperationCanceled(operationId, nonce);",
                        "        return nonce;",
                        "    event OperationScheduled(",
                        "        bytes32 indexed operationId,",
                        "        uint32 indexed nonce,",
                        "        uint48 schedule,",
                        "        address caller,",
                        "        address target,",
                        "        bytes data",
                        "    );",
                        "    event OperationExecuted(bytes32 indexed operationId, uint32 indexed nonce);",
                        "    event OperationCanceled(bytes32 indexed operationId, uint32 indexed nonce);",
                        "    function getNonce(bytes32 id) external returns (uint32);",
                        "    function schedule(address target, bytes calldata data, uint48 when) external returns (bytes32, uint32);",
                        "    function relay(address target, bytes calldata data) external payable returns (uint32);",
                        "    function cancel(address caller, address target, bytes calldata data) external returns (uint32);",
                        "    function name() public view virtual returns (string memory) {",
                        "    function version() public view virtual returns (string memory) {",
                        "    ) public pure virtual returns (uint256) {",
                        "    function state(uint256 proposalId) public view virtual returns (ProposalState) {",
                        "    function proposalThreshold() public view virtual returns (uint256) {",
                        "    function proposalSnapshot(uint256 proposalId) public view virtual returns (uint256) {",
                        "    function proposalDeadline(uint256 proposalId) public view virtual returns (uint256) {",
                        "    function proposalProposer(uint256 proposalId) public view virtual returns (address) {",
                        "    function proposalEta(uint256 proposalId) public view virtual returns (uint256) {",
                        "    /**",
                        "     * @dev See {IGovernor-proposalNeedsQueuing}.",
                        "     */",
                        "    function proposalNeedsQueuing(uint256) public view virtual returns (bool) {",
                        "        return false;",
                        "    }",
                        "    ) public virtual returns (uint256) {",
                        "    ) public virtual returns (uint256) {",
                        "    ) public payable virtual returns (uint256) {",
                        "    ) public virtual returns (uint256) {",
                        "    function getVotes(address account, uint256 timepoint) public view virtual returns (uint256) {",
                        "    ) public view virtual returns (uint256) {",
                        "    function castVote(uint256 proposalId, uint8 support) public virtual returns (uint256) {",
                        "    ) public virtual returns (uint256) {",
                        "    ) public virtual returns (uint256) {",
                        "    ) public virtual returns (uint256) {",
                        "    ) public virtual returns (uint256) {",
                        "    /**",
                        "     * @notice module:core",
                        "     * @dev Whether a proposal needs to be queued before execution.",
                        "     */",
                        "    function proposalNeedsQueuing(uint256 proposalId) external view returns (bool);",
                        "/**",
                        " * @dev This module connects a {Governor} instance to an {AccessManager} instance, allowing the governor to make calls",
                        " * that are delay-restricted by the manager using the normal {queue} workflow. An optional base delay is applied to",
                        " * operations that are not delayed externally by the manager. Execution of a proposal will be delayed as much as",
                        " * necessary to meet the required delays of all of its operations.",
                        " *",
                        " * This extension allows the governor to hold and use its own assets and permissions, unlike {GovernorTimelockControl}",
                        " * and {GovernorTimelockCompound}, where the timelock is a separate contract that must be the one to hold assets and",
                        " * permissions. Operations that are delay-restricted by the manager, however, will be executed through the",
                        " * {AccessManager-relay} function.",
                        " *",
                        " * Note that some operations may be cancelable in the {AccessManager} by the admin or a set of guardians, depending on",
                        " * the restricted operation being invoked. Since proposals are atomic, the cancellation by a guardian of a single",
                        " * operation in a proposal will cause all of it to become unable to execute.",
                        " */",
                        "abstract contract GovernorTimelockAccess is Governor {",
                        "    struct ExecutionPlan {",
                        "        uint16 length;",
                        "        uint32 delay;",
                        "        mapping(uint256 operationBucket => uint32[8]) managerData;",
                        "    }",
                        "    mapping(uint256 proposalId => ExecutionPlan) private _executionPlan;",
                        "    uint32 private _baseDelay;",
                        "    IAccessManager private immutable _manager;",
                        "    error GovernorUnmetDelay(uint256 proposalId, uint256 neededTimestamp);",
                        "    error GovernorMismatchedNonce(uint256 proposalId, uint256 expectedNonce, uint256 actualNonce);",
                        "    event BaseDelaySet(uint32 oldBaseDelaySeconds, uint32 newBaseDelaySeconds);",
                        "    /**",
                        "     * @dev Initialize the governor with an {AccessManager} and initial base delay.",
                        "     */",
                        "    constructor(address manager, uint32 initialBaseDelay) {",
                        "        _manager = IAccessManager(manager);",
                        "        _setBaseDelaySeconds(initialBaseDelay);",
                        "    }",
                        "    /**",
                        "     * @dev Returns the {AccessManager} instance associated to this governor.",
                        "     */",
                        "    function accessManager() public view virtual returns (IAccessManager) {",
                        "        return _manager;",
                        "    }",
                        "    /**",
                        "     * @dev Base delay that will be applied to all function calls. Some may be further delayed by their associated",
                        "     * `AccessManager` authority; in this case the final delay will be the maximum of the base delay and the one",
                        "     * demanded by the authority.",
                        "     *",
                        "     * NOTE: Execution delays are processed by the `AccessManager` contracts, and according to that contract are",
                        "     * expressed in seconds. Therefore, the base delay is also in seconds, regardless of the governor's clock mode.",
                        "     */",
                        "    function baseDelaySeconds() public view virtual returns (uint32) {",
                        "        return _baseDelay;",
                        "    }",
                        "    /**",
                        "     * @dev Change the value of {baseDelaySeconds}. This operation can only be invoked through a governance proposal.",
                        "     */",
                        "    function setBaseDelaySeconds(uint32 newBaseDelay) public virtual onlyGovernance {",
                        "        _setBaseDelaySeconds(newBaseDelay);",
                        "    }",
                        "    /**",
                        "     * @dev Change the value of {baseDelaySeconds}. Internal function without access control.",
                        "     */",
                        "    function _setBaseDelaySeconds(uint32 newBaseDelay) internal virtual {",
                        "        emit BaseDelaySet(_baseDelay, newBaseDelay);",
                        "        _baseDelay = newBaseDelay;",
                        "    }",
                        "    /**",
                        "     * @dev Public accessor to check the execution plan, including the number of seconds that the proposal will be",
                        "     * delayed since queuing, and an array indicating which of the proposal actions will be executed indirectly through",
                        "     * the associated {AccessManager}.",
                        "     */",
                        "    function proposalExecutionPlan(uint256 proposalId) public view returns (uint32, bool[] memory) {",
                        "        ExecutionPlan storage plan = _executionPlan[proposalId];",
                        "        uint32 delay = plan.delay;",
                        "        uint32 length = plan.length;",
                        "        bool[] memory indirect = new bool[](length);",
                        "        for (uint256 i = 0; i < length; ++i) {",
                        "            (indirect[i], ) = _getManagerData(plan, i);",
                        "        }",
                        "        return (delay, indirect);",
                        "    }",
                        "    /**",
                        "     * @dev See {IGovernor-proposalNeedsQueuing}.",
                        "     */",
                        "    function proposalNeedsQueuing(uint256 proposalId) public view virtual override returns (bool) {",
                        "        return _executionPlan[proposalId].delay > 0;",
                        "    }",
                        "    /**",
                        "     * @dev See {IGovernor-propose}",
                        "     */",
                        "    function propose(",
                        "        address[] memory targets,",
                        "        uint256[] memory values,",
                        "        bytes[] memory calldatas,",
                        "        string memory description",
                        "    ) public virtual override returns (uint256) {",
                        "        uint256 proposalId = super.propose(targets, values, calldatas, description);",
                        "        uint32 neededDelay = baseDelaySeconds();",
                        "        ExecutionPlan storage plan = _executionPlan[proposalId];",
                        "        plan.length = SafeCast.toUint16(targets.length);",
                        "        for (uint256 i = 0; i < targets.length; ++i) {",
                        "            uint32 delay = _detectExecutionRequirements(targets[i], bytes4(calldatas[i]));",
                        "            if (delay > 0) {",
                        "                _setManagerData(plan, i, 0);",
                        "            }",
                        "            neededDelay = uint32(Math.max(delay, neededDelay));",
                        "        }",
                        "        plan.delay = neededDelay;",
                        "        return proposalId;",
                        "    }",
                        "    /**",
                        "     * @dev Mechanism to queue a proposal, potentially scheduling some of its operations in the AccessManager.",
                        "     *",
                        "     * NOTE: The execution delay is chosen based on the delay information retrieved in {propose}. This value may be",
                        "     * off if the delay was updated since proposal creation. In this case, the proposal needs to be recreated.",
                        "     */",
                        "    function _queueOperations(",
                        "        uint256 proposalId,",
                        "        address[] memory targets,",
                        "        uint256[] memory /* values */,",
                        "        bytes[] memory calldatas,",
                        "        bytes32 /* descriptionHash */",
                        "    ) internal virtual override returns (uint48) {",
                        "        ExecutionPlan storage plan = _executionPlan[proposalId];",
                        "        uint48 eta = Time.timestamp() + plan.delay;",
                        "        for (uint256 i = 0; i < targets.length; ++i) {",
                        "            (bool delayed, ) = _getManagerData(plan, i);",
                        "            if (delayed) {",
                        "                (, uint32 nonce) = _manager.schedule(targets[i], calldatas[i], eta);",
                        "                _setManagerData(plan, i, nonce);",
                        "            }",
                        "        }",
                        "        return eta;",
                        "    }",
                        "    /**",
                        "     * @dev Mechanism to execute a proposal, potentially going through {AccessManager-relay} for delayed operations.",
                        "     */",
                        "    function _executeOperations(",
                        "        uint256 proposalId,",
                        "        address[] memory targets,",
                        "        uint256[] memory values,",
                        "        bytes[] memory calldatas,",
                        "        bytes32 /* descriptionHash */",
                        "    ) internal virtual override {",
                        "        uint48 eta = SafeCast.toUint48(proposalEta(proposalId));",
                        "        if (block.timestamp < eta) {",
                        "            revert GovernorUnmetDelay(proposalId, eta);",
                        "        }",
                        "        ExecutionPlan storage plan = _executionPlan[proposalId];",
                        "        for (uint256 i = 0; i < targets.length; ++i) {",
                        "            (bool delayed, uint32 nonce) = _getManagerData(plan, i);",
                        "            if (delayed) {",
                        "                uint32 relayedNonce = _manager.relay{value: values[i]}(targets[i], calldatas[i]);",
                        "                if (relayedNonce != nonce) {",
                        "                    revert GovernorMismatchedNonce(proposalId, nonce, relayedNonce);",
                        "                }",
                        "            } else {",
                        "                (bool success, bytes memory returndata) = targets[i].call{value: values[i]}(calldatas[i]);",
                        "                Address.verifyCallResult(success, returndata);",
                        "            }",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev See {IGovernor-_cancel}",
                        "     */",
                        "    function _cancel(",
                        "        address[] memory targets,",
                        "        uint256[] memory values,",
                        "        bytes[] memory calldatas,",
                        "        bytes32 descriptionHash",
                        "    ) internal virtual override returns (uint256) {",
                        "        uint256 proposalId = super._cancel(targets, values, calldatas, descriptionHash);",
                        "        uint48 eta = SafeCast.toUint48(proposalEta(proposalId));",
                        "        ExecutionPlan storage plan = _executionPlan[proposalId];",
                        "        if (eta != 0) {",
                        "            for (uint256 i = 0; i < targets.length; ++i) {",
                        "                (bool delayed, uint32 nonce) = _getManagerData(plan, i);",
                        "                if (delayed) {",
                        "                    uint32 canceledNonce = _manager.cancel(address(this), targets[i], calldatas[i]);",
                        "                    if (canceledNonce != nonce) {",
                        "                        revert GovernorMismatchedNonce(proposalId, nonce, canceledNonce);",
                        "                    }",
                        "                }",
                        "            }",
                        "        }",
                        "        return proposalId;",
                        "    }",
                        "    /**",
                        "     * @dev Check if the execution of a call needs to be performed through an AccessManager and what delay should be",
                        "     * applied to this call.",
                        "     *",
                        "     * Returns { manager: address(0), delay: 0 } if:",
                        "     * - target does not have code",
                        "     * - target does not implement IAccessManaged",
                        "     * - calling canCall on the target's manager returns a 0 delay",
                        "     * - calling canCall on the target's manager reverts",
                        "     * Otherwise (calling canCall on the target's manager returns a non 0 delay), return the address of the",
                        "     * AccessManager to use, and the delay for this call.",
                        "     */",
                        "    function _detectExecutionRequirements(address target, bytes4 selector) private view returns (uint32 delay) {",
                        "        (, delay) = AuthorityUtils.canCallWithDelay(address(_manager), address(this), target, selector);",
                        "    }",
                        "    /**",
                        "     * @dev Returns whether the operation at an index is delayed by the manager, and its scheduling nonce once queued.",
                        "     */",
                        "    function _getManagerData(ExecutionPlan storage plan, uint256 index) private view returns (bool, uint32) {",
                        "        (uint256 bucket, uint256 subindex) = _getManagerDataIndices(index);",
                        "        uint32 nonce = plan.managerData[bucket][subindex];",
                        "        unchecked {",
                        "            return nonce > 0 ? (true, nonce - 1) : (false, 0);",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Marks an operation at an index as delayed by the manager, and sets its scheduling nonce.",
                        "     */",
                        "    function _setManagerData(ExecutionPlan storage plan, uint256 index, uint32 nonce) private {",
                        "        (uint256 bucket, uint256 subindex) = _getManagerDataIndices(index);",
                        "        plan.managerData[bucket][subindex] = nonce + 1;",
                        "    }",
                        "    /**",
                        "     * @dev Returns bucket and subindex for reading manager data from the packed array mapping.",
                        "     */",
                        "    function _getManagerDataIndices(uint256 index) private pure returns (uint256 bucket, uint256 subindex) {",
                        "    }",
                        "}",
                        "    /**",
                        "     * @dev See {IGovernor-proposalNeedsQueuing}.",
                        "     */",
                        "    function proposalNeedsQueuing(uint256) public view virtual override returns (bool) {",
                        "        return true;",
                        "    }",
                        "    /**",
                        "     * @dev See {IGovernor-proposalNeedsQueuing}.",
                        "     */",
                        "    function proposalNeedsQueuing(uint256) public view virtual override returns (bool) {",
                        "        return true;",
                        "    }",
                        "    function proposalNeedsQueuing(",
                        "        uint256 proposalId",
                        "    ) public view virtual override(Governor, GovernorTimelockControl) returns (bool) {",
                        "        return super.proposalNeedsQueuing(proposalId);",
                        "    }",
                        "    function proposalNeedsQueuing(",
                        "        uint256 proposalId",
                        "    ) public view virtual override(Governor, GovernorTimelockControl) returns (bool) {",
                        "        return super.proposalNeedsQueuing(proposalId);",
                        "    }",
                        "abstract contract GovernorTimelockAccessMock is",
                        "    GovernorSettings,",
                        "    GovernorTimelockAccess,",
                        "    GovernorVotesQuorumFraction,",
                        "    GovernorCountingSimple",
                        "{",
                        "    function nonGovernanceFunction() external {}",
                        "    function quorum(uint256 blockNumber) public view override(Governor, GovernorVotesQuorumFraction) returns (uint256) {",
                        "        return super.quorum(blockNumber);",
                        "    }",
                        "    function proposalThreshold() public view override(Governor, GovernorSettings) returns (uint256) {",
                        "        return super.proposalThreshold();",
                        "    }",
                        "    function proposalNeedsQueuing(",
                        "        uint256 proposalId",
                        "    ) public view virtual override(Governor, GovernorTimelockAccess) returns (bool) {",
                        "        return super.proposalNeedsQueuing(proposalId);",
                        "    }",
                        "    function propose(",
                        "        address[] memory targets,",
                        "        uint256[] memory values,",
                        "        bytes[] memory calldatas,",
                        "        string memory description",
                        "    ) public override(Governor, GovernorTimelockAccess) returns (uint256) {",
                        "        return super.propose(targets, values, calldatas, description);",
                        "    }",
                        "    function _queueOperations(",
                        "        uint256 proposalId,",
                        "        address[] memory targets,",
                        "        uint256[] memory values,",
                        "        bytes[] memory calldatas,",
                        "        bytes32 descriptionHash",
                        "    ) internal override(Governor, GovernorTimelockAccess) returns (uint48) {",
                        "        return super._queueOperations(proposalId, targets, values, calldatas, descriptionHash);",
                        "    }",
                        "    function _executeOperations(",
                        "        uint256 proposalId,",
                        "        address[] memory targets,",
                        "        uint256[] memory values,",
                        "        bytes[] memory calldatas,",
                        "        bytes32 descriptionHash",
                        "    ) internal override(Governor, GovernorTimelockAccess) {",
                        "        super._executeOperations(proposalId, targets, values, calldatas, descriptionHash);",
                        "    }",
                        "    function _cancel(",
                        "        address[] memory targets,",
                        "        uint256[] memory values,",
                        "        bytes[] memory calldatas,",
                        "        bytes32 descriptionHash",
                        "    ) internal override(Governor, GovernorTimelockAccess) returns (uint256) {",
                        "        return super._cancel(targets, values, calldatas, descriptionHash);",
                        "    }",
                        "}",
                        "    function proposalNeedsQueuing(",
                        "        uint256 proposalId",
                        "    ) public view virtual override(Governor, GovernorTimelockCompound) returns (bool) {",
                        "        return super.proposalNeedsQueuing(proposalId);",
                        "    }",
                        "    function proposalNeedsQueuing(",
                        "        uint256 proposalId",
                        "    ) public view virtual override(Governor, GovernorTimelockControl) returns (bool) {",
                        "        return super.proposalNeedsQueuing(proposalId);",
                        "    }"
                    ],
                    "del": [
                        "    mapping(bytes32 operationId => uint48 schedule) private _schedules;",
                        "        uint48 timepoint = _schedules[id];",
                        "    function schedule(address target, bytes calldata data, uint48 when) public virtual returns (bytes32) {",
                        "        if (!allowed && (setback == 0 || when.isSetAndPast(minWhen - 1))) {",
                        "        bytes32 operationId = _hashOperation(caller, target, data);",
                        "        uint48 prevTimepoint = _schedules[operationId];",
                        "        uint48 timepoint = when == 0 ? minWhen : when;",
                        "        _schedules[operationId] = timepoint;",
                        "        emit OperationScheduled(operationId, timepoint, caller, target, data);",
                        "        return operationId;",
                        "    function relay(address target, bytes calldata data) public payable virtual {",
                        "            _consumeScheduledOp(operationId);",
                        "    function _consumeScheduledOp(bytes32 operationId) internal virtual {",
                        "        uint48 timepoint = _schedules[operationId];",
                        "        emit OperationExecuted(operationId, timepoint);",
                        "     * @dev Cancel a scheduled (delayed) operation.",
                        "    function cancel(address caller, address target, bytes calldata data) public virtual {",
                        "        if (_schedules[operationId] == 0) {",
                        "        uint48 timepoint = _schedules[operationId];",
                        "        delete _schedules[operationId];",
                        "        emit OperationCanceled(operationId, timepoint);",
                        "    event OperationScheduled(bytes32 indexed operationId, uint48 schedule, address caller, address target, bytes data);",
                        "    event OperationExecuted(bytes32 indexed operationId, uint48 schedule);",
                        "    event OperationCanceled(bytes32 indexed operationId, uint48 schedule);",
                        "    function schedule(address target, bytes calldata data, uint48 when) external returns (bytes32);",
                        "    function relay(address target, bytes calldata data) external payable;",
                        "    function cancel(address caller, address target, bytes calldata data) external;",
                        "    function name() public view virtual override returns (string memory) {",
                        "    function version() public view virtual override returns (string memory) {",
                        "    ) public pure virtual override returns (uint256) {",
                        "    function state(uint256 proposalId) public view virtual override returns (ProposalState) {",
                        "    function proposalThreshold() public view virtual override returns (uint256) {",
                        "    function proposalSnapshot(uint256 proposalId) public view virtual override returns (uint256) {",
                        "    function proposalDeadline(uint256 proposalId) public view virtual override returns (uint256) {",
                        "    function proposalProposer(uint256 proposalId) public view virtual override returns (address) {",
                        "    function proposalEta(uint256 proposalId) public view virtual override returns (uint256) {",
                        "    ) public virtual override returns (uint256) {",
                        "    ) public virtual override returns (uint256) {",
                        "    ) public payable virtual override returns (uint256) {",
                        "    ) public virtual override returns (uint256) {",
                        "    function getVotes(address account, uint256 timepoint) public view virtual override returns (uint256) {",
                        "    ) public view virtual override returns (uint256) {",
                        "    function castVote(uint256 proposalId, uint8 support) public virtual override returns (uint256) {",
                        "    ) public virtual override returns (uint256) {",
                        "    ) public virtual override returns (uint256) {",
                        "    ) public virtual override returns (uint256) {",
                        "    ) public virtual override returns (uint256) {"
                    ]
                }
            }
        ],
        "- `GovernorTimelockControl`: Added the Governor instance address as part of the TimelockController operation `salt` to avoid operation id collisions between governors using the same TimelockController. ([#4432](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4432))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4432": {
                    "add": [
                        "        bytes32 salt = _timelockSalt(descriptionHash);",
                        "        _timelockIds[proposalId] = _timelock.hashOperationBatch(targets, values, calldatas, 0, salt);",
                        "        _timelock.scheduleBatch(targets, values, calldatas, 0, salt, delay);",
                        "        _timelock.executeBatch{value: msg.value}(targets, values, calldatas, 0, _timelockSalt(descriptionHash));",
                        "    /**",
                        "     * @dev Computes the {TimelockController} operation salt.",
                        "     *",
                        "     * It is computed with the governor address itself to avoid collisions across governor instances using the",
                        "     * same timelock.",
                        "     */",
                        "    function _timelockSalt(bytes32 descriptionHash) private view returns (bytes32) {",
                        "        return bytes20(address(this)) ^ descriptionHash;",
                        "    }"
                    ],
                    "del": [
                        "        _timelockIds[proposalId] = _timelock.hashOperationBatch(targets, values, calldatas, 0, descriptionHash);",
                        "        _timelock.scheduleBatch(targets, values, calldatas, 0, descriptionHash, delay);",
                        "        _timelock.executeBatch{value: msg.value}(targets, values, calldatas, 0, descriptionHash);"
                    ]
                }
            }
        ],
        "- `TimelockController`: Changed the role architecture to use `DEFAULT_ADMIN_ROLE` as the admin for all roles, instead of the bespoke `TIMELOCK_ADMIN_ROLE` that was used previously. This aligns with the general recommendation for `AccessControl` and makes the addition of new roles easier. Accordingly, the `admin` parameter and timelock will now be granted `DEFAULT_ADMIN_ROLE` instead of `TIMELOCK_ADMIN_ROLE`. ([#3799](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3799))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3799": {
                    "add": [
                        "        _grantRole(DEFAULT_ADMIN_ROLE, address(this));",
                        "            _grantRole(DEFAULT_ADMIN_ROLE, admin);"
                    ],
                    "del": [
                        "    bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(\"TIMELOCK_ADMIN_ROLE\");",
                        "        _setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);",
                        "        _setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);",
                        "        _setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);",
                        "        _setRoleAdmin(CANCELLER_ROLE, TIMELOCK_ADMIN_ROLE);",
                        "        _setupRole(TIMELOCK_ADMIN_ROLE, address(this));",
                        "            _setupRole(TIMELOCK_ADMIN_ROLE, admin);"
                    ]
                }
            }
        ],
        "- `Votes`: Use Trace208 for checkpoints. This enables EIP-6372 clock support for keys but reduces the max supported voting power to uint208. ([#4539](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4539))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4539": {
                    "add": [
                        "    using Checkpoints for Checkpoints.Trace208;",
                        "    Checkpoints.Trace208 private _quorumNumeratorHistory;",
                        "        Checkpoints.Checkpoint208 memory latest = _quorumNumeratorHistory._checkpoints[length - 1];",
                        "        uint48 latestKey = latest._key;",
                        "        uint208 latestValue = latest._value;",
                        "        return _quorumNumeratorHistory.upperLookupRecent(SafeCast.toUint48(timepoint));",
                        "        _quorumNumeratorHistory.push(clock(), SafeCast.toUint208(newQuorumNumerator));",
                        "    using Checkpoints for Checkpoints.Trace208;",
                        "    mapping(address delegatee => Checkpoints.Trace208) private _delegateCheckpoints;",
                        "    Checkpoints.Trace208 private _totalCheckpoints;",
                        "        return _delegateCheckpoints[account].upperLookupRecent(SafeCast.toUint48(timepoint));",
                        "        return _totalCheckpoints.upperLookupRecent(SafeCast.toUint48(timepoint));",
                        "            _push(_totalCheckpoints, _add, SafeCast.toUint208(amount));",
                        "            _push(_totalCheckpoints, _subtract, SafeCast.toUint208(amount));",
                        "                    SafeCast.toUint208(amount)",
                        "                    SafeCast.toUint208(amount)",
                        "    ) internal view virtual returns (Checkpoints.Checkpoint208 memory) {",
                        "        Checkpoints.Trace208 storage store,",
                        "        function(uint208, uint208) view returns (uint208) op,",
                        "        uint208 delta",
                        "    ) private returns (uint208, uint208) {",
                        "        return store.push(clock(), op(store.latest(), delta));",
                        "    function _add(uint208 a, uint208 b) private pure returns (uint208) {",
                        "    function _subtract(uint208 a, uint208 b) private pure returns (uint208) {",
                        " * and supports token supply up to 2^208^ - 1, while COMP is limited to 2^96^ - 1.",
                        "     * @dev Maximum token supply. Defaults to `type(uint208).max` (2^208^ - 1).",
                        "     *",
                        "     * This maximum is enforced in {_update}. It limits the total supply of the token, which is otherwise a uint256,",
                        "     * so that checkpoints can be stored in the Trace208 structure used by {{Votes}}. Increasing this value will not",
                        "     * remove the underlying limitation, and will cause {_update} to fail because of a math overflow in",
                        "     * {_transferVotingUnits}. An override could be used to further restrict the total supply (to a lower value) if",
                        "     * additional logic requires it. When resolving override conflicts on this function, the minimum should be",
                        "     * returned.",
                        "    function _maxSupply() internal view virtual returns (uint256) {",
                        "        return type(uint208).max;",
                        "    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoints.Checkpoint208 memory) {",
                        "    struct Trace208 {",
                        "        Checkpoint208[] _checkpoints;",
                        "    }",
                        "    struct Checkpoint208 {",
                        "        uint48 _key;",
                        "        uint208 _value;",
                        "    }",
                        "    /**",
                        "     * @dev Pushes a (`key`, `value`) pair into a Trace208 so that it is stored as the checkpoint.",
                        "     *",
                        "     * Returns previous value and new value.",
                        "     *",
                        "     * IMPORTANT: Never accept `key` as a user input, since an arbitrary `type(uint48).max` key set will disable the library.",
                        "     */",
                        "    function push(Trace208 storage self, uint48 key, uint208 value) internal returns (uint208, uint208) {",
                        "        return _insert(self._checkpoints, key, value);",
                        "    }",
                        "    /**",
                        "     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if there is none.",
                        "     */",
                        "    function lowerLookup(Trace208 storage self, uint48 key) internal view returns (uint208) {",
                        "        uint256 len = self._checkpoints.length;",
                        "        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);",
                        "        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;",
                        "    }",
                        "    /**",
                        "     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.",
                        "     */",
                        "    function upperLookup(Trace208 storage self, uint48 key) internal view returns (uint208) {",
                        "        uint256 len = self._checkpoints.length;",
                        "        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);",
                        "        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
                        "    }",
                        "    /**",
                        "     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.",
                        "     *",
                        "     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high keys).",
                        "     */",
                        "    function upperLookupRecent(Trace208 storage self, uint48 key) internal view returns (uint208) {",
                        "        uint256 len = self._checkpoints.length;",
                        "        uint256 low = 0;",
                        "        uint256 high = len;",
                        "        if (len > 5) {",
                        "            uint256 mid = len - Math.sqrt(len);",
                        "            if (key < _unsafeAccess(self._checkpoints, mid)._key) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }",
                        "        }",
                        "        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);",
                        "        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
                        "    }",
                        "    /**",
                        "     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.",
                        "     */",
                        "    function latest(Trace208 storage self) internal view returns (uint208) {",
                        "        uint256 pos = self._checkpoints.length;",
                        "        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
                        "    }",
                        "    /**",
                        "     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value",
                        "     * in the most recent checkpoint.",
                        "     */",
                        "    function latestCheckpoint(Trace208 storage self) internal view returns (bool exists, uint48 _key, uint208 _value) {",
                        "        uint256 pos = self._checkpoints.length;",
                        "        if (pos == 0) {",
                        "            return (false, 0, 0);",
                        "        } else {",
                        "            Checkpoint208 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);",
                        "            return (true, ckpt._key, ckpt._value);",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Returns the number of checkpoint.",
                        "     */",
                        "    function length(Trace208 storage self) internal view returns (uint256) {",
                        "        return self._checkpoints.length;",
                        "    }",
                        "    /**",
                        "     * @dev Returns checkpoint at given position.",
                        "     */",
                        "    function at(Trace208 storage self, uint32 pos) internal view returns (Checkpoint208 memory) {",
                        "        return self._checkpoints[pos];",
                        "    }",
                        "    /**",
                        "     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,",
                        "     * or by updating the last one.",
                        "     */",
                        "    function _insert(Checkpoint208[] storage self, uint48 key, uint208 value) private returns (uint208, uint208) {",
                        "        uint256 pos = self.length;",
                        "        if (pos > 0) {",
                        "            Checkpoint208 memory last = _unsafeAccess(self, pos - 1);",
                        "            if (last._key > key) {",
                        "                revert CheckpointUnorderedInsertion();",
                        "            }",
                        "            if (last._key == key) {",
                        "                _unsafeAccess(self, pos - 1)._value = value;",
                        "            } else {",
                        "                self.push(Checkpoint208({_key: key, _value: value}));",
                        "            }",
                        "            return (last._value, value);",
                        "        } else {",
                        "            self.push(Checkpoint208({_key: key, _value: value}));",
                        "            return (0, value);",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high` if there is none.",
                        "     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.",
                        "     *",
                        "     * WARNING: `high` should not be greater than the array's length.",
                        "     */",
                        "    function _upperBinaryLookup(",
                        "        Checkpoint208[] storage self,",
                        "        uint48 key,",
                        "        uint256 low,",
                        "        uint256 high",
                        "    ) private view returns (uint256) {",
                        "        while (low < high) {",
                        "            uint256 mid = Math.average(low, high);",
                        "            if (_unsafeAccess(self, mid)._key > key) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }",
                        "        }",
                        "        return high;",
                        "    }",
                        "    /**",
                        "     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or `high` if there is none.",
                        "     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.",
                        "     *",
                        "     * WARNING: `high` should not be greater than the array's length.",
                        "     */",
                        "    function _lowerBinaryLookup(",
                        "        Checkpoint208[] storage self,",
                        "        uint48 key,",
                        "        uint256 low,",
                        "        uint256 high",
                        "    ) private view returns (uint256) {",
                        "        while (low < high) {",
                        "            uint256 mid = Math.average(low, high);",
                        "            if (_unsafeAccess(self, mid)._key < key) {",
                        "                low = mid + 1;",
                        "            } else {",
                        "                high = mid;",
                        "            }",
                        "        }",
                        "        return high;",
                        "    }",
                        "    /**",
                        "     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.",
                        "     */",
                        "    function _unsafeAccess(",
                        "        Checkpoint208[] storage self,",
                        "        uint256 pos",
                        "    ) private pure returns (Checkpoint208 storage result) {",
                        "        assembly {",
                        "            mstore(0, self.slot)",
                        "            result.slot := add(keccak256(0, 0x20), pos)",
                        "        }",
                        "    }",
                        "contract CheckpointsTrace208Test is Test {",
                        "    using Checkpoints for Checkpoints.Trace208;",
                        "    uint8 internal constant _KEY_MAX_GAP = 64;",
                        "    Checkpoints.Trace208 internal _ckpts;",
                        "    function _boundUint48(uint48 x, uint48 min, uint48 max) internal view returns (uint48) {",
                        "        return SafeCast.toUint48(bound(uint256(x), uint256(min), uint256(max)));",
                        "    }",
                        "    function _prepareKeys(uint48[] memory keys, uint48 maxSpread) internal view {",
                        "        uint48 lastKey = 0;",
                        "        for (uint256 i = 0; i < keys.length; ++i) {",
                        "            uint48 key = _boundUint48(keys[i], lastKey, lastKey + maxSpread);",
                        "            keys[i] = key;",
                        "            lastKey = key;",
                        "        }",
                        "    }",
                        "    function _assertLatestCheckpoint(bool exist, uint48 key, uint208 value) internal {",
                        "        (bool _exist, uint48 _key, uint208 _value) = _ckpts.latestCheckpoint();",
                        "        assertEq(_exist, exist);",
                        "        assertEq(_key, key);",
                        "        assertEq(_value, value);",
                        "    }",
                        "    function testPush(uint48[] memory keys, uint208[] memory values, uint48 pastKey) public {",
                        "        vm.assume(values.length > 0 && values.length <= keys.length);",
                        "        _prepareKeys(keys, _KEY_MAX_GAP);",
                        "        assertEq(_ckpts.length(), 0);",
                        "        assertEq(_ckpts.latest(), 0);",
                        "        _assertLatestCheckpoint(false, 0, 0);",
                        "        uint256 duplicates = 0;",
                        "        for (uint256 i = 0; i < keys.length; ++i) {",
                        "            uint48 key = keys[i];",
                        "            uint208 value = values[i % values.length];",
                        "            if (i > 0 && key == keys[i - 1]) ++duplicates;",
                        "            _ckpts.push(key, value);",
                        "            assertEq(_ckpts.length(), i + 1 - duplicates);",
                        "            assertEq(_ckpts.latest(), value);",
                        "            _assertLatestCheckpoint(true, key, value);",
                        "        }",
                        "        if (keys.length > 0) {",
                        "            uint48 lastKey = keys[keys.length - 1];",
                        "            if (lastKey > 0) {",
                        "                pastKey = _boundUint48(pastKey, 0, lastKey - 1);",
                        "                vm.expectRevert();",
                        "                this.push(pastKey, values[keys.length % values.length]);",
                        "            }",
                        "        }",
                        "    }",
                        "    function push(uint48 key, uint208 value) external {",
                        "        _ckpts.push(key, value);",
                        "    }",
                        "    function testLookup(uint48[] memory keys, uint208[] memory values, uint48 lookup) public {",
                        "        vm.assume(values.length > 0 && values.length <= keys.length);",
                        "        _prepareKeys(keys, _KEY_MAX_GAP);",
                        "        uint48 lastKey = keys.length == 0 ? 0 : keys[keys.length - 1];",
                        "        lookup = _boundUint48(lookup, 0, lastKey + _KEY_MAX_GAP);",
                        "        uint208 upper = 0;",
                        "        uint208 lower = 0;",
                        "        uint48 lowerKey = type(uint48).max;",
                        "        for (uint256 i = 0; i < keys.length; ++i) {",
                        "            uint48 key = keys[i];",
                        "            uint208 value = values[i % values.length];",
                        "            _ckpts.push(key, value);",
                        "            if (key <= lookup) {",
                        "                upper = value;",
                        "            }",
                        "            if (key >= lookup && (i == 0 || keys[i - 1] < lookup)) {",
                        "                lowerKey = key;",
                        "            }",
                        "            if (key == lowerKey) {",
                        "                lower = value;",
                        "            }",
                        "        }",
                        "        assertEq(_ckpts.lowerLookup(lookup), lower);",
                        "        assertEq(_ckpts.upperLookup(lookup), upper);",
                        "        assertEq(_ckpts.upperLookupRecent(lookup), upper);",
                        "    }",
                        "}"
                    ],
                    "del": [
                        "    using Checkpoints for Checkpoints.Trace224;",
                        "    Checkpoints.Trace224 private _quorumNumeratorHistory;",
                        "        Checkpoints.Checkpoint224 storage latest = _quorumNumeratorHistory._checkpoints[length - 1];",
                        "        uint32 latestKey = latest._key;",
                        "        uint224 latestValue = latest._value;",
                        "        return _quorumNumeratorHistory.upperLookupRecent(SafeCast.toUint32(timepoint));",
                        "        _quorumNumeratorHistory.push(SafeCast.toUint32(clock()), SafeCast.toUint224(newQuorumNumerator));",
                        "    using Checkpoints for Checkpoints.Trace224;",
                        "    mapping(address delegatee => Checkpoints.Trace224) private _delegateCheckpoints;",
                        "    Checkpoints.Trace224 private _totalCheckpoints;",
                        "        return _delegateCheckpoints[account].upperLookupRecent(SafeCast.toUint32(timepoint));",
                        "        return _totalCheckpoints.upperLookupRecent(SafeCast.toUint32(timepoint));",
                        "            _push(_totalCheckpoints, _add, SafeCast.toUint224(amount));",
                        "            _push(_totalCheckpoints, _subtract, SafeCast.toUint224(amount));",
                        "                    SafeCast.toUint224(amount)",
                        "                    SafeCast.toUint224(amount)",
                        "    ) internal view virtual returns (Checkpoints.Checkpoint224 memory) {",
                        "        Checkpoints.Trace224 storage store,",
                        "        function(uint224, uint224) view returns (uint224) op,",
                        "        uint224 delta",
                        "    ) private returns (uint224, uint224) {",
                        "        return store.push(SafeCast.toUint32(clock()), op(store.latest(), delta));",
                        "    function _add(uint224 a, uint224 b) private pure returns (uint224) {",
                        "    function _subtract(uint224 a, uint224 b) private pure returns (uint224) {",
                        " * and supports token supply up to 2^224^ - 1, while COMP is limited to 2^96^ - 1.",
                        "     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).",
                        "    function _maxSupply() internal view virtual returns (uint224) {",
                        "        return type(uint224).max;",
                        "    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoints.Checkpoint224 memory) {"
                    ]
                }
            }
        ],
        "- `ERC2771Forwarder`: Added `deadline` for expiring transactions, batching, and more secure handling of `msg.value`. ([#4346](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4346))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4346": {
                    "add": [
                        "/**",
                        " * @dev A forwarder compatible with ERC2771 contracts. See {ERC2771Context}.",
                        " *",
                        " * This forwarder operates on forward requests that include:",
                        " *",
                        " * * `from`: An address to operate on behalf of. It is required to be equal to the request signer.",
                        " * * `to`: The address that should be called.",
                        " * * `value`: The amount of native token to attach with the requested call.",
                        " * * `gas`: The amount of gas limit that will be forwarded with the requested call.",
                        " * * `nonce`: A unique transaction ordering identifier to avoid replayability and request invalidation.",
                        " * * `deadline`: A timestamp after which the request is not executable anymore.",
                        " * * `data`: Encoded `msg.data` to send with the requested call.",
                        " */",
                        "contract ERC2771Forwarder is EIP712, Nonces {",
                        "    using ECDSA for bytes32;",
                        "    struct ForwardRequestData {",
                        "        address from;",
                        "        address to;",
                        "        uint256 value;",
                        "        uint256 gas;",
                        "        uint48 deadline;",
                        "        bytes data;",
                        "        bytes signature;",
                        "    }",
                        "    bytes32 private constant _FORWARD_REQUEST_TYPEHASH =",
                        "        keccak256(",
                        "            \"ForwardRequest(address from,address to,uint256 value,uint256 gas,uint256 nonce,uint48 deadline,bytes data)\"",
                        "        );",
                        "    /**",
                        "     * @dev Emitted when a `ForwardRequest` is executed.",
                        "     *",
                        "     * NOTE: An unsuccessful forward request could be due to an invalid signature, an expired deadline,",
                        "     * or simply a revert in the requested call. The contract guarantees that the relayer is not able to force",
                        "     * the requested call to run out of gas.",
                        "     */",
                        "    event ExecutedForwardRequest(address indexed signer, uint256 nonce, bool success);",
                        "    /**",
                        "     * @dev The request `from` doesn't match with the recovered `signer`.",
                        "     */",
                        "    error ERC2771ForwarderInvalidSigner(address signer, address from);",
                        "    /**",
                        "     * @dev The `requestedValue` doesn't match with the available `msgValue`.",
                        "     */",
                        "    error ERC2771ForwarderMismatchedValue(uint256 requestedValue, uint256 msgValue);",
                        "    /**",
                        "     * @dev The request `deadline` has expired.",
                        "     */",
                        "    error ERC2771ForwarderExpiredRequest(uint48 deadline);",
                        "    /**",
                        "     * @dev See {EIP712-constructor}.",
                        "     */",
                        "    constructor(string memory name) EIP712(name, \"1\") {}",
                        "    /**",
                        "     * @dev Returns `true` if a request is valid for a provided `signature` at the current block timestamp.",
                        "     *",
                        "     * A transaction is considered valid when it hasn't expired (deadline is not met), and the signer",
                        "     * matches the `from` parameter of the signed request.",
                        "     *",
                        "     * NOTE: A request may return false here but it won't cause {executeBatch} to revert if a refund",
                        "     * receiver is provided.",
                        "     */",
                        "    function verify(ForwardRequestData calldata request) public view virtual returns (bool) {",
                        "        (bool alive, bool signerMatch, ) = _validate(request);",
                        "        return alive && signerMatch;",
                        "    }",
                        "    /**",
                        "     * @dev Executes a `request` on behalf of `signature`'s signer using the ERC-2771 protocol. The gas",
                        "     * provided to the requested call may not be exactly the amount requested, but the call will not run",
                        "     * out of gas. Will revert if the request is invalid or the call reverts, in this case the nonce is not consumed.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - The request value should be equal to the provided `msg.value`.",
                        "     * - The request should be valid according to {verify}.",
                        "     */",
                        "    function execute(ForwardRequestData calldata request) public payable virtual {",
                        "        if (msg.value != request.value) {",
                        "            revert ERC2771ForwarderMismatchedValue(request.value, msg.value);",
                        "        }",
                        "        if (!_execute(request, true)) {",
                        "            revert Address.FailedInnerCall();",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Batch version of {execute} with optional refunding and atomic execution.",
                        "     *",
                        "     * In case a batch contains at least one invalid request (see {verify}), the",
                        "     * request will be skipped and the `refundReceiver` parameter will receive back the",
                        "     * unused requested value at the end of the execution. This is done to prevent reverting",
                        "     * the entire batch when a request is invalid or has already been submitted.",
                        "     *",
                        "     * If the `refundReceiver` is the `address(0)`, this function will revert when at least",
                        "     * one of the requests was not valid instead of skipping it. This could be useful if",
                        "     * a batch is required to get executed atomically (at least at the top-level). For example,",
                        "     * refunding (and thus atomicity) can be opt-out if the relayer is using a service that avoids",
                        "     * including reverted transactions.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - The sum of the requests' values should be equal to the provided `msg.value`.",
                        "     * - All of the requests should be valid (see {verify}) when `refundReceiver` is the zero address.",
                        "     *",
                        "     * NOTE: Setting a zero `refundReceiver` guarantees an all-or-nothing requests execution only for",
                        "     * the first-level forwarded calls. In case a forwarded request calls to a contract with another",
                        "     * subcall, the second-level call may revert without the top-level call reverting.",
                        "     */",
                        "    function executeBatch(",
                        "        ForwardRequestData[] calldata requests,",
                        "        address payable refundReceiver",
                        "    ) public payable virtual {",
                        "        bool atomic = refundReceiver == address(0);",
                        "        uint256 requestsValue;",
                        "        uint256 refundValue;",
                        "        for (uint256 i; i < requests.length; ++i) {",
                        "            requestsValue += requests[i].value;",
                        "            bool success = _execute(requests[i], atomic);",
                        "            if (!success) {",
                        "                refundValue += requests[i].value;",
                        "            }",
                        "        }",
                        "        if (requestsValue != msg.value) {",
                        "            revert ERC2771ForwarderMismatchedValue(requestsValue, msg.value);",
                        "        }",
                        "        if (refundValue != 0) {",
                        "            Address.sendValue(refundReceiver, refundValue);",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Validates if the provided request can be executed at current block timestamp with",
                        "     * the given `request.signature` on behalf of `request.signer`.",
                        "     */",
                        "    function _validate(",
                        "        ForwardRequestData calldata request",
                        "    ) internal view virtual returns (bool alive, bool signerMatch, address signer) {",
                        "        signer = _recoverForwardRequestSigner(request);",
                        "        return (request.deadline >= block.timestamp, signer == request.from, signer);",
                        "    }",
                        "    /**",
                        "     * @dev Recovers the signer of an EIP712 message hash for a forward `request` and its corresponding `signature`.",
                        "     * See {ECDSA-recover}.",
                        "     */",
                        "    function _recoverForwardRequestSigner(ForwardRequestData calldata request) internal view virtual returns (address) {",
                        "        return",
                        "            _hashTypedDataV4(",
                        "                keccak256(",
                        "                    abi.encode(",
                        "                        _FORWARD_REQUEST_TYPEHASH,",
                        "                        request.from,",
                        "                        request.to,",
                        "                        request.value,",
                        "                        request.gas,",
                        "                        nonces(request.from),",
                        "                        request.deadline,",
                        "                        keccak256(request.data)",
                        "                    )",
                        "                )",
                        "            ).recover(request.signature);",
                        "    }",
                        "    /**",
                        "     * @dev Validates and executes a signed request returning the request call `success` value.",
                        "     *",
                        "     * Internal function without msg.value validation.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - The caller must have provided enough gas to forward with the call.",
                        "     * - The request must be valid (see {verify}) if the `requireValidRequest` is true.",
                        "     *",
                        "     * Emits an {ExecutedForwardRequest} event.",
                        "     *",
                        "     * IMPORTANT: Using this function doesn't check that all the `msg.value` was sent, potentially",
                        "     * leaving value stuck in the contract.",
                        "     */",
                        "    function _execute(",
                        "        ForwardRequestData calldata request,",
                        "        bool requireValidRequest",
                        "    ) internal virtual returns (bool success) {",
                        "        (bool alive, bool signerMatch, address signer) = _validate(request);",
                        "        if (requireValidRequest) {",
                        "            if (!alive) {",
                        "                revert ERC2771ForwarderExpiredRequest(request.deadline);",
                        "            }",
                        "            if (!signerMatch) {",
                        "                revert ERC2771ForwarderInvalidSigner(signer, request.from);",
                        "            }",
                        "        }",
                        "        if (signerMatch && alive) {",
                        "            uint256 currentNonce = _useNonce(signer);",
                        "            (success, ) = request.to.call{gas: request.gas, value: request.value}(",
                        "                abi.encodePacked(request.data, request.from)",
                        "            );",
                        "            _checkForwardedGas(request);",
                        "            emit ExecutedForwardRequest(signer, currentNonce, success);",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Checks if the requested gas was correctly forwarded to the callee.",
                        "     *",
                        "     * As a consequence of https://eips.ethereum.org/EIPS/eip-150[EIP-150]:",
                        "     * - At most `gasleft() - floor(gasleft() / 64)` is forwarded to the callee.",
                        "     * - At least `floor(gasleft() / 64)` is kept in the caller.",
                        "     *",
                        "     * It reverts consuming all the available gas if the forwarded gas is not the requested gas.",
                        "     *",
                        "     * IMPORTANT: This function should be called exactly the end of the forwarded call. Any gas consumed",
                        "     * in between will make room for bypassing this check.",
                        "     */",
                        "    function _checkForwardedGas(ForwardRequestData calldata request) private view {",
                        "        //",
                        "        //",
                        "        //",
                        "        if (gasleft() < request.gas / 63) {",
                        "            assembly {",
                        "                invalid()",
                        "            }",
                        "        }",
                        "    }",
                        "}",
                        "     * @dev See {IERC-5267}."
                    ],
                    "del": [
                        "/**",
                        " * @dev Simple minimal forwarder to be used together with an ERC2771 compatible contract. See {ERC2771Context}.",
                        " *",
                        " * MinimalForwarder is mainly meant for testing, as it is missing features to be a good production-ready forwarder. This",
                        " * contract does not intend to have all the properties that are needed for a sound forwarding system. A fully",
                        " * functioning forwarding system with good properties requires more complexity. We suggest you look at other projects",
                        " * such as the GSN which do have the goal of building a system like that.",
                        " */",
                        "contract MinimalForwarder is EIP712 {",
                        "    using ECDSA for bytes32;",
                        "    struct ForwardRequest {",
                        "        address from;",
                        "        address to;",
                        "        uint256 value;",
                        "        uint256 gas;",
                        "        uint256 nonce;",
                        "        bytes data;",
                        "    }",
                        "    bytes32 private constant _TYPEHASH =",
                        "        keccak256(\"ForwardRequest(address from,address to,uint256 value,uint256 gas,uint256 nonce,bytes data)\");",
                        "    mapping(address => uint256) private _nonces;",
                        "    /**",
                        "     * @dev The request `from` doesn't match with the recovered `signer`.",
                        "     */",
                        "    error MinimalForwarderInvalidSigner(address signer, address from);",
                        "    /**",
                        "     * @dev The request nonce doesn't match with the `current` nonce for the request signer.",
                        "     */",
                        "    error MinimalForwarderInvalidNonce(address signer, uint256 current);",
                        "    constructor() EIP712(\"MinimalForwarder\", \"0.0.1\") {}",
                        "    function getNonce(address from) public view returns (uint256) {",
                        "        return _nonces[from];",
                        "    }",
                        "    function verify(ForwardRequest calldata req, bytes calldata signature) public view returns (bool) {",
                        "        address signer = _recover(req, signature);",
                        "        (bool correctFrom, bool correctNonce) = _validateReq(req, signer);",
                        "        return correctFrom && correctNonce;",
                        "    }",
                        "    function execute(",
                        "        ForwardRequest calldata req,",
                        "        bytes calldata signature",
                        "    ) public payable returns (bool, bytes memory) {",
                        "        address signer = _recover(req, signature);",
                        "        (bool correctFrom, bool correctNonce) = _validateReq(req, signer);",
                        "        if (!correctFrom) {",
                        "            revert MinimalForwarderInvalidSigner(signer, req.from);",
                        "        }",
                        "        if (!correctNonce) {",
                        "            revert MinimalForwarderInvalidNonce(signer, _nonces[req.from]);",
                        "        }",
                        "        _nonces[req.from] = req.nonce + 1;",
                        "        (bool success, bytes memory returndata) = req.to.call{gas: req.gas, value: req.value}(",
                        "            abi.encodePacked(req.data, req.from)",
                        "        );",
                        "        if (gasleft() <= req.gas / 63) {",
                        "            assembly {",
                        "                invalid()",
                        "            }",
                        "        }",
                        "        return (success, returndata);",
                        "    }",
                        "    function _recover(ForwardRequest calldata req, bytes calldata signature) internal view returns (address) {",
                        "        return",
                        "            _hashTypedDataV4(",
                        "                keccak256(abi.encode(_TYPEHASH, req.from, req.to, req.value, req.gas, req.nonce, keccak256(req.data)))",
                        "            ).recover(signature);",
                        "    }",
                        "    function _validateReq(",
                        "        ForwardRequest calldata req,",
                        "        address signer",
                        "    ) internal view returns (bool correctFrom, bool correctNonce) {",
                        "        return (signer == req.from, _nonces[req.from] == req.nonce);",
                        "    }",
                        "}",
                        "     * @dev See {EIP-5267}."
                    ]
                }
            }
        ],
        "- `ERC2771Context`: Return the forwarder address whenever the `msg.data` of a call originating from a trusted forwarder is not long enough to contain the request signer address (i.e. `msg.data.length` is less than 20 bytes), as specified by ERC-2771. ([#4481](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4481))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4481": {
                    "add": [
                        "        if (isTrustedForwarder(msg.sender) && msg.data.length >= 20) {"
                    ],
                    "del": [
                        "        if (isTrustedForwarder(msg.sender)) {"
                    ]
                }
            }
        ],
        "- `ERC2771Context`: Prevent revert in `_msgData()` when a call originating from a trusted forwarder is not long enough to contain the request signer address (i.e. `msg.data.length` is less than 20 bytes). Return the full calldata in that case. ([#4484](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4484))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4484": {
                    "add": [
                        "        if (isTrustedForwarder(msg.sender) && msg.data.length >= 20) {",
                        "    event DataShort(bytes data);",
                        "    function msgDataShort() public {",
                        "        emit DataShort(_msgData());",
                        "    }"
                    ],
                    "del": [
                        "        if (isTrustedForwarder(msg.sender)) {"
                    ]
                }
            }
        ],
        "- `ProxyAdmin`: Removed `getProxyAdmin` and `getProxyImplementation` getters. ([#3820](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3820))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3820": {
                    "add": [
                        "     *",
                        "     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the",
                        "     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.",
                        "     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`",
                        "     *",
                        "     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the",
                        "     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.",
                        "     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`"
                    ],
                    "del": [
                        "    /**",
                        "     * @dev Returns the current implementation of `proxy`.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - This contract must be the admin of `proxy`.",
                        "     */",
                        "    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {",
                        "        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");",
                        "        require(success);",
                        "        return abi.decode(returndata, (address));",
                        "    }",
                        "    /**",
                        "     * @dev Returns the current admin of `proxy`.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - This contract must be the admin of `proxy`.",
                        "     */",
                        "    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {",
                        "        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");",
                        "        require(success);",
                        "        return abi.decode(returndata, (address));",
                        "    }",
                        "    /**",
                        "     * @dev Returns the current admin.",
                        "     *",
                        "     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.",
                        "     *",
                        "     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the",
                        "     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.",
                        "     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`",
                        "     */",
                        "    function admin() external ifAdmin returns (address admin_) {",
                        "        admin_ = _getAdmin();",
                        "    }",
                        "    /**",
                        "     * @dev Returns the current implementation.",
                        "     *",
                        "     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.",
                        "     *",
                        "     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the",
                        "     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.",
                        "     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`",
                        "     */",
                        "    function implementation() external ifAdmin returns (address implementation_) {",
                        "        implementation_ = _implementation();",
                        "    }"
                    ]
                }
            }
        ],
        "- `TransparentUpgradeableProxy`: Removed `admin` and `implementation` getters, which were only callable by the proxy owner and thus not very useful. ([#3820](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3820))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3820": {
                    "add": [
                        "     *",
                        "     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the",
                        "     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.",
                        "     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`",
                        "     *",
                        "     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the",
                        "     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.",
                        "     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`"
                    ],
                    "del": [
                        "    /**",
                        "     * @dev Returns the current implementation of `proxy`.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - This contract must be the admin of `proxy`.",
                        "     */",
                        "    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {",
                        "        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");",
                        "        require(success);",
                        "        return abi.decode(returndata, (address));",
                        "    }",
                        "    /**",
                        "     * @dev Returns the current admin of `proxy`.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - This contract must be the admin of `proxy`.",
                        "     */",
                        "    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {",
                        "        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");",
                        "        require(success);",
                        "        return abi.decode(returndata, (address));",
                        "    }",
                        "    /**",
                        "     * @dev Returns the current admin.",
                        "     *",
                        "     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.",
                        "     *",
                        "     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the",
                        "     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.",
                        "     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`",
                        "     */",
                        "    function admin() external ifAdmin returns (address admin_) {",
                        "        admin_ = _getAdmin();",
                        "    }",
                        "    /**",
                        "     * @dev Returns the current implementation.",
                        "     *",
                        "     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.",
                        "     *",
                        "     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the",
                        "     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.",
                        "     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`",
                        "     */",
                        "    function implementation() external ifAdmin returns (address implementation_) {",
                        "        implementation_ = _implementation();",
                        "    }"
                    ]
                }
            }
        ],
        "- `TransparentUpgradeableProxy`: Admin is now stored in an immutable variable (set during construction) to avoid unnecessary storage reads on every proxy call. This removed the ability to ever change the admin. Transfer of the upgrade capability is exclusively handled through the ownership of the `ProxyAdmin`. ([#4354](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4354))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4354": {
                    "add": [
                        "    function unsafeOverrideAdmin(address newAdmin) public {",
                        "        StorageSlot.getAddressSlot(ERC1967Utils.ADMIN_SLOT).value = newAdmin;",
                        "    }",
                        "    function upgradeTo(address) external payable {",
                        " * @dev This contract implements a proxy that is upgradeable by an immutable admin.",
                        " * implementation. If the admin tries to call a function on the implementation it will fail with an error indicating the",
                        " * proxy admin cannot fallback to the target implementation.",
                        " * These properties mean that the admin account can only be used for upgrading the proxy, so it's best if it's a dedicated",
                        " * account that is not used for anything else. This will avoid headaches due to sudden errors when trying to call a function",
                        " * from the proxy implementation.",
                        " * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy, which extends from the",
                        " * {Ownable} contract to allow for changing the proxy's admin owner.",
                        " * IMPORTANT: This contract avoids unnecessary storage reads by setting the admin only during construction as an immutable variable,",
                        " * preventing any changes thereafter. However, the admin slot defined in ERC-1967 can still be overwritten by the implementation",
                        " * logic pointed to by this proxy. In such cases, the contract may end up in an undesirable state where the admin slot is different",
                        " * from the actual admin.",
                        " *",
                        "    address private immutable _admin;",
                        "        _admin = admin_;",
                        "        if (msg.sender == _admin) {"
                    ],
                    "del": [
                        "    function changeAdmin(address) external payable {",
                        "    /**",
                        "     * @dev Changes the admin of `proxy` to `newAdmin`.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - This contract must be the current admin of `proxy`.",
                        "     */",
                        "    function changeProxyAdmin(ITransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {",
                        "        proxy.changeAdmin(newAdmin);",
                        "    }",
                        "    function changeAdmin(address) external;",
                        " * @dev This contract implements a proxy that is upgradeable by an admin.",
                        " * implementation. If the admin tries to call a function on the implementation it will fail with an error that says",
                        " * \"admin cannot fallback to proxy target\".",
                        " * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing",
                        " * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due",
                        " * to sudden errors when trying to call a function from the proxy implementation.",
                        " * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.",
                        "        if (msg.sender == ERC1967Utils.getAdmin()) {",
                        "            } else if (selector == ITransparentUpgradeableProxy.changeAdmin.selector) {",
                        "                ret = _dispatchChangeAdmin();",
                        "    /**",
                        "     * @dev Changes the admin of the proxy.",
                        "     *",
                        "     * Emits an {AdminChanged} event.",
                        "     */",
                        "    function _dispatchChangeAdmin() private returns (bytes memory) {",
                        "        _requireZeroValue();",
                        "        address newAdmin = abi.decode(msg.data[4:], (address));",
                        "        ERC1967Utils.changeAdmin(newAdmin);",
                        "        return \"\";",
                        "    }"
                    ]
                }
            }
        ],
        "- Moved the logic to validate ERC-1822 during an upgrade from `ERC1967Utils` to `UUPSUpgradeable`. ([#4356](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4356))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4356": {
                    "add": [
                        "contract UUPSUnsupportedProxiableUUID is UUPSUpgradeableMock {",
                        "    function proxiableUUID() external pure override returns (bytes32) {",
                        "        return keccak256(\"invalid UUID\");",
                        "    }",
                        "}",
                        "    /**",
                        "     * @dev The storage `slot` is unsupported as a UUID.",
                        "     */",
                        "    error UUPSUnsupportedProxiableUUID(bytes32 slot);",
                        "        if (",
                        "        ) {",
                        "        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);",
                        "        _upgradeToAndCallUUPS(newImplementation, data, true);",
                        "    /**",
                        "     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.",
                        "     *",
                        "     * Emits an {IERC1967-Upgraded} event.",
                        "     */",
                        "    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) private {",
                        "        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {",
                        "            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {",
                        "                revert UUPSUnsupportedProxiableUUID(slot);",
                        "            }",
                        "            ERC1967Utils.upgradeToAndCall(newImplementation, data, forceCall);",
                        "        } catch {",
                        "            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);",
                        "        }",
                        "    }"
                    ],
                    "del": [
                        "contract UUPSUpgradeableLegacyMock is UUPSUpgradeableMock {",
                        "    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;",
                        "    function __setImplementation(address newImplementation) private {",
                        "        require(newImplementation.code.length > 0, \"ERC1967: new implementation is not a contract\");",
                        "        StorageSlot.getAddressSlot(ERC1967Utils.IMPLEMENTATION_SLOT).value = newImplementation;",
                        "    }",
                        "    function _upgradeToAndCallSecureLegacyV1(address newImplementation, bytes memory data, bool forceCall) internal {",
                        "        address oldImplementation = ERC1967Utils.getImplementation();",
                        "        __setImplementation(newImplementation);",
                        "        if (data.length > 0 || forceCall) {",
                        "            Address.functionDelegateCall(newImplementation, data);",
                        "        }",
                        "        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);",
                        "        if (!rollbackTesting.value) {",
                        "            rollbackTesting.value = true;",
                        "            Address.functionDelegateCall(newImplementation, abi.encodeCall(this.upgradeTo, (oldImplementation)));",
                        "            rollbackTesting.value = false;",
                        "            require(",
                        "                oldImplementation == ERC1967Utils.getImplementation(),",
                        "                \"ERC1967Utils: upgrade breaks further upgrades\"",
                        "            );",
                        "            ERC1967Utils.upgradeTo(newImplementation);",
                        "        }",
                        "    }",
                        "    function upgradeTo(address newImplementation) public override {",
                        "        _upgradeToAndCallSecureLegacyV1(newImplementation, bytes(\"\"), false);",
                        "    }",
                        "    function upgradeToAndCall(address newImplementation, bytes memory data) public payable override {",
                        "        _upgradeToAndCallSecureLegacyV1(newImplementation, data, false);",
                        "    }",
                        "}",
                        "    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;",
                        "    /**",
                        "     * @dev The storage `slot` is unsupported as a UUID.",
                        "     */",
                        "    error ERC1967UnsupportedProxiableUUID(bytes32 slot);",
                        "    /**",
                        "     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.",
                        "     *",
                        "     * Emits an {IERC1967-Upgraded} event.",
                        "     */",
                        "    function upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {",
                        "        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {",
                        "            _setImplementation(newImplementation);",
                        "        } else {",
                        "            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {",
                        "                if (slot != IMPLEMENTATION_SLOT) {",
                        "                    revert ERC1967UnsupportedProxiableUUID(slot);",
                        "                }",
                        "            } catch {",
                        "                revert ERC1967InvalidImplementation(newImplementation);",
                        "            }",
                        "            upgradeToAndCall(newImplementation, data, forceCall);",
                        "        }",
                        "    }",
                        "        if (address(this) == __self) {",
                        "            revert UUPSUnauthorizedCallContext();",
                        "        }",
                        "        if (ERC1967Utils.getImplementation() != __self) {",
                        "        ERC1967Utils.upgradeToAndCallUUPS(newImplementation, new bytes(0), false);",
                        "        ERC1967Utils.upgradeToAndCallUUPS(newImplementation, data, true);"
                    ]
                }
            }
        ],
        "- `UUPSUpgradeable`, `TransparentUpgradeableProxy` and `ProxyAdmin`: Removed `upgradeTo` and `upgrade` functions, and made `upgradeToAndCall` and `upgradeAndCall` ignore the data argument if it is empty. It is no longer possible to invoke the receive function (or send value with empty data) along with an upgrade. ([#4382](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4382))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4382": {
                    "add": [
                        "contract UpgradeableBeaconMock is IBeacon {",
                        "    address public implementation;",
                        "    constructor(address impl) {",
                        "        implementation = impl;",
                        "    }",
                        "}",
                        "    function upgradeToAndCall(address, bytes calldata) external payable {",
                        "        ERC1967Utils.upgradeToAndCall(newImplementation, data);",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - If `data` is empty, `msg.value` must be zero.",
                        "        ERC1967Utils.upgradeToAndCall(_logic, _data);",
                        "    /**",
                        "     * @dev An upgrade function sees `msg.value > 0` that may be lost.",
                        "     */",
                        "    error ERC1967NonPayable();",
                        "     * @dev Performs implementation upgrade with additional setup call if data is nonempty.",
                        "     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected",
                        "     * to avoid stuck value in the contract.",
                        "    function upgradeToAndCall(address newImplementation, bytes memory data) internal {",
                        "        if (data.length > 0) {",
                        "        } else {",
                        "            _checkNonPayable();",
                        "     * @dev Change the beacon and trigger a setup call if data is nonempty.",
                        "     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected",
                        "     * to avoid stuck value in the contract.",
                        "    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {",
                        "        if (data.length > 0) {",
                        "        } else {",
                        "            _checkNonPayable();",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Reverts if `msg.value` is not zero.",
                        "     */",
                        "    function _checkNonPayable() private {",
                        "        if (msg.value > 0) {",
                        "            revert ERC1967NonPayable();",
                        "     * - If `data` is empty, `msg.value` must be zero.",
                        "        ERC1967Utils.upgradeBeaconToAndCall(beacon, data);",
                        "     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgrade(address)`",
                        "     * and `upgradeAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,",
                        "     * while `upgradeAndCall` will invoke the `receive` function if the second argument is the empty byte string.",
                        "     * If the getter returns `\"5.0.0\"`, only `upgradeAndCall(address,bytes)` is present, and the second argument must",
                        "     * be the empty byte string if no function should be called, being impossible to invoke the `receive` function",
                        "     * during an upgrade.",
                        "    string public constant UPGRADE_INTERFACE_VERSION = \"5.0.0\";",
                        "     * @dev Sets the initial owner who can perform upgrades.",
                        "    constructor(address initialOwner) Ownable(initialOwner) {}",
                        "     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation.",
                        "     * See {TransparentUpgradeableProxy-_dispatchUpgradeToAndCall}.",
                        "     * - If `data` is empty, `msg.value` must be zero.",
                        " * does not implement this interface directly, and its upgradeability mechanism is implemented by an internal dispatch",
                        "    function upgradeToAndCall(address, bytes calldata) external payable;",
                        " * @dev This contract implements a proxy that is upgradeable through an associated {ProxyAdmin} instance.",
                        " * that call matches the {ITransparentUpgradeableProxy-upgradeToAndCall} function exposed by the proxy itself.",
                        " * 2. If the admin calls the proxy, it can call the `upgradeToAndCall` function but any other call won't be forwarded to the",
                        " * from the proxy implementation. For this reason, the proxy deploys an instance of {ProxyAdmin} and allows upgrades",
                        " * only if they come through it.",
                        " * You should think of the `ProxyAdmin` instance as the administrative interface of the proxy, including the ability to",
                        " * change who can trigger upgrades by transferring ownership.",
                        " * inherit from that interface, and instead `upgradeToAndCall` is implicitly implemented using a custom dispatch mechanism",
                        " * in `_fallback`. Consequently, the compiler will not produce an ABI for this contract. This is necessary to fully",
                        " * implement transparency without decoding reverts caused by selector clashes between the proxy and the",
                        " * render the `upgradeToAndCall` function inaccessible, preventing upgradeability and compromising transparency.",
                        "     * @dev Initializes an upgradeable proxy managed by an instance of a {ProxyAdmin} with an `initialOwner`,",
                        "     * backed by the implementation at `_logic`, and optionally initialized with `_data` as explained in",
                        "     * {ERC1967Proxy-constructor}.",
                        "    constructor(address _logic, address initialOwner, bytes memory _data) payable ERC1967Proxy(_logic, _data) {",
                        "        _admin = address(new ProxyAdmin(initialOwner));",
                        "        ERC1967Utils.changeAdmin(_admin);",
                        "     * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior.",
                        "            if (msg.sig == ITransparentUpgradeableProxy.upgradeToAndCall.selector) {",
                        "                _dispatchUpgradeToAndCall();",
                        "     * @dev Upgrade the implementation of the proxy. See {ERC1967Utils-upgradeToAndCall}.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - If `data` is empty, `msg.value` must be zero.",
                        "    function _dispatchUpgradeToAndCall() private {",
                        "        ERC1967Utils.upgradeToAndCall(newImplementation, data);",
                        "    /**",
                        "     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`",
                        "     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,",
                        "     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.",
                        "     * If the getter returns `\"5.0.0\"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must",
                        "     * be the empty byte string if no function should be called, being impossible to invoke the `receive` function",
                        "     * during an upgrade.",
                        "     */",
                        "    string public constant UPGRADE_INTERFACE_VERSION = \"5.0.0\";",
                        "        _upgradeToAndCallUUPS(newImplementation, data);",
                        "     * {upgradeToAndCall}.",
                        "     * function _authorizeUpgrade(address) internal onlyOwner {}",
                        "    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {",
                        "            ERC1967Utils.upgradeToAndCall(newImplementation, data);"
                    ],
                    "del": [
                        "    function upgradeTo(address) external payable {",
                        "    function upgradeTo(address newImplementation) public override {",
                        "        ERC1967Utils.upgradeToAndCall(newImplementation, bytes(\"\"), false);",
                        "    }",
                        "        ERC1967Utils.upgradeToAndCall(newImplementation, data, false);",
                        "        ERC1967Utils.upgradeToAndCall(_logic, _data, false);",
                        "     * @dev Perform implementation upgrade",
                        "    function upgradeTo(address newImplementation) internal {",
                        "    }",
                        "    /**",
                        "     * @dev Perform implementation upgrade with additional setup call.",
                        "     *",
                        "     * Emits an {IERC1967-Upgraded} event.",
                        "     */",
                        "    function upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {",
                        "        upgradeTo(newImplementation);",
                        "        if (data.length > 0 || forceCall) {",
                        "     * @dev Change the beacon and trigger a setup call.",
                        "    function upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {",
                        "        if (data.length > 0 || forceCall) {",
                        "        ERC1967Utils.upgradeBeaconToAndCall(beacon, data, false);",
                        "     * @dev Sets the initial owner who can perform upgrades.",
                        "    constructor(address initialOwner) Ownable(initialOwner) {}",
                        "     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - This contract must be the admin of `proxy`.",
                        "    function upgrade(ITransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {",
                        "        proxy.upgradeTo(implementation);",
                        "    }",
                        "     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See",
                        "     * {TransparentUpgradeableProxy-upgradeToAndCall}.",
                        " * does not implement this interface directly, and some of its functions are implemented by an internal dispatch",
                        "    function upgradeTo(address) external;",
                        "    function upgradeToAndCall(address, bytes memory) external payable;",
                        " * @dev This contract implements a proxy that is upgradeable by an immutable admin.",
                        " * that call matches one of the admin functions exposed by the proxy itself.",
                        " * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the",
                        " * from the proxy implementation.",
                        " *",
                        " * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,",
                        " * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy, which extends from the",
                        " * {Ownable} contract to allow for changing the proxy's admin owner.",
                        " * inherit from that interface, and instead the admin functions are implicitly implemented using a custom dispatch",
                        " * mechanism in `_fallback`. Consequently, the compiler will not produce an ABI for this contract. This is necessary to",
                        " * fully implement transparency without decoding reverts caused by selector clashes between the proxy and the",
                        " * render the admin operations inaccessible, which could prevent upgradeability. Transparency may also be compromised.",
                        "     * @dev msg.value is not 0.",
                        "     */",
                        "    error ProxyNonPayableFunction();",
                        "    /**",
                        "     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and",
                        "     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.",
                        "    constructor(address _logic, address admin_, bytes memory _data) payable ERC1967Proxy(_logic, _data) {",
                        "        _admin = admin_;",
                        "        ERC1967Utils.changeAdmin(admin_);",
                        "     * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior",
                        "            bytes memory ret;",
                        "            bytes4 selector = msg.sig;",
                        "            if (selector == ITransparentUpgradeableProxy.upgradeTo.selector) {",
                        "                ret = _dispatchUpgradeTo();",
                        "            } else if (selector == ITransparentUpgradeableProxy.upgradeToAndCall.selector) {",
                        "                ret = _dispatchUpgradeToAndCall();",
                        "            assembly {",
                        "                return(add(ret, 0x20), mload(ret))",
                        "            }",
                        "     * @dev Upgrade the implementation of the proxy.",
                        "     */",
                        "    function _dispatchUpgradeTo() private returns (bytes memory) {",
                        "        _requireZeroValue();",
                        "        address newImplementation = abi.decode(msg.data[4:], (address));",
                        "        ERC1967Utils.upgradeToAndCall(newImplementation, bytes(\"\"), false);",
                        "        return \"\";",
                        "    }",
                        "    /**",
                        "     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified",
                        "     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the",
                        "     * proxied contract.",
                        "    function _dispatchUpgradeToAndCall() private returns (bytes memory) {",
                        "        ERC1967Utils.upgradeToAndCall(newImplementation, data, true);",
                        "        return \"\";",
                        "    }",
                        "    /**",
                        "     * @dev To keep this contract fully transparent, the fallback is payable. This helper is here to enforce",
                        "     * non-payability of function implemented through dispatchers while still allowing value to pass through.",
                        "     */",
                        "    function _requireZeroValue() private {",
                        "        if (msg.value != 0) {",
                        "            revert ProxyNonPayableFunction();",
                        "        }",
                        "    /**",
                        "     * @dev Upgrade the implementation of the proxy to `newImplementation`.",
                        "     *",
                        "     * Calls {_authorizeUpgrade}.",
                        "     *",
                        "     * Emits an {Upgraded} event.",
                        "     *",
                        "     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall",
                        "     */",
                        "    function upgradeTo(address newImplementation) public virtual onlyProxy {",
                        "        _authorizeUpgrade(newImplementation);",
                        "        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);",
                        "    }",
                        "        _upgradeToAndCallUUPS(newImplementation, data, true);",
                        "     * {upgradeTo} and {upgradeToAndCall}.",
                        "     * function _authorizeUpgrade(address) internal  onlyOwner {}",
                        "    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) private {",
                        "            ERC1967Utils.upgradeToAndCall(newImplementation, data, forceCall);"
                    ]
                }
            }
        ],
        "- `BeaconProxy`: Reject value in initialization unless a payable function is explicitly invoked. ([#4382](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4382))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4382": {
                    "add": [
                        "contract UpgradeableBeaconMock is IBeacon {",
                        "    address public implementation;",
                        "    constructor(address impl) {",
                        "        implementation = impl;",
                        "    }",
                        "}",
                        "    function upgradeToAndCall(address, bytes calldata) external payable {",
                        "        ERC1967Utils.upgradeToAndCall(newImplementation, data);",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - If `data` is empty, `msg.value` must be zero.",
                        "        ERC1967Utils.upgradeToAndCall(_logic, _data);",
                        "    /**",
                        "     * @dev An upgrade function sees `msg.value > 0` that may be lost.",
                        "     */",
                        "    error ERC1967NonPayable();",
                        "     * @dev Performs implementation upgrade with additional setup call if data is nonempty.",
                        "     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected",
                        "     * to avoid stuck value in the contract.",
                        "    function upgradeToAndCall(address newImplementation, bytes memory data) internal {",
                        "        if (data.length > 0) {",
                        "        } else {",
                        "            _checkNonPayable();",
                        "     * @dev Change the beacon and trigger a setup call if data is nonempty.",
                        "     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected",
                        "     * to avoid stuck value in the contract.",
                        "    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {",
                        "        if (data.length > 0) {",
                        "        } else {",
                        "            _checkNonPayable();",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Reverts if `msg.value` is not zero.",
                        "     */",
                        "    function _checkNonPayable() private {",
                        "        if (msg.value > 0) {",
                        "            revert ERC1967NonPayable();",
                        "     * - If `data` is empty, `msg.value` must be zero.",
                        "        ERC1967Utils.upgradeBeaconToAndCall(beacon, data);",
                        "     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgrade(address)`",
                        "     * and `upgradeAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,",
                        "     * while `upgradeAndCall` will invoke the `receive` function if the second argument is the empty byte string.",
                        "     * If the getter returns `\"5.0.0\"`, only `upgradeAndCall(address,bytes)` is present, and the second argument must",
                        "     * be the empty byte string if no function should be called, being impossible to invoke the `receive` function",
                        "     * during an upgrade.",
                        "    string public constant UPGRADE_INTERFACE_VERSION = \"5.0.0\";",
                        "     * @dev Sets the initial owner who can perform upgrades.",
                        "    constructor(address initialOwner) Ownable(initialOwner) {}",
                        "     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation.",
                        "     * See {TransparentUpgradeableProxy-_dispatchUpgradeToAndCall}.",
                        "     * - If `data` is empty, `msg.value` must be zero.",
                        " * does not implement this interface directly, and its upgradeability mechanism is implemented by an internal dispatch",
                        "    function upgradeToAndCall(address, bytes calldata) external payable;",
                        " * @dev This contract implements a proxy that is upgradeable through an associated {ProxyAdmin} instance.",
                        " * that call matches the {ITransparentUpgradeableProxy-upgradeToAndCall} function exposed by the proxy itself.",
                        " * 2. If the admin calls the proxy, it can call the `upgradeToAndCall` function but any other call won't be forwarded to the",
                        " * from the proxy implementation. For this reason, the proxy deploys an instance of {ProxyAdmin} and allows upgrades",
                        " * only if they come through it.",
                        " * You should think of the `ProxyAdmin` instance as the administrative interface of the proxy, including the ability to",
                        " * change who can trigger upgrades by transferring ownership.",
                        " * inherit from that interface, and instead `upgradeToAndCall` is implicitly implemented using a custom dispatch mechanism",
                        " * in `_fallback`. Consequently, the compiler will not produce an ABI for this contract. This is necessary to fully",
                        " * implement transparency without decoding reverts caused by selector clashes between the proxy and the",
                        " * render the `upgradeToAndCall` function inaccessible, preventing upgradeability and compromising transparency.",
                        "     * @dev Initializes an upgradeable proxy managed by an instance of a {ProxyAdmin} with an `initialOwner`,",
                        "     * backed by the implementation at `_logic`, and optionally initialized with `_data` as explained in",
                        "     * {ERC1967Proxy-constructor}.",
                        "    constructor(address _logic, address initialOwner, bytes memory _data) payable ERC1967Proxy(_logic, _data) {",
                        "        _admin = address(new ProxyAdmin(initialOwner));",
                        "        ERC1967Utils.changeAdmin(_admin);",
                        "     * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior.",
                        "            if (msg.sig == ITransparentUpgradeableProxy.upgradeToAndCall.selector) {",
                        "                _dispatchUpgradeToAndCall();",
                        "     * @dev Upgrade the implementation of the proxy. See {ERC1967Utils-upgradeToAndCall}.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - If `data` is empty, `msg.value` must be zero.",
                        "    function _dispatchUpgradeToAndCall() private {",
                        "        ERC1967Utils.upgradeToAndCall(newImplementation, data);",
                        "    /**",
                        "     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`",
                        "     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,",
                        "     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.",
                        "     * If the getter returns `\"5.0.0\"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must",
                        "     * be the empty byte string if no function should be called, being impossible to invoke the `receive` function",
                        "     * during an upgrade.",
                        "     */",
                        "    string public constant UPGRADE_INTERFACE_VERSION = \"5.0.0\";",
                        "        _upgradeToAndCallUUPS(newImplementation, data);",
                        "     * {upgradeToAndCall}.",
                        "     * function _authorizeUpgrade(address) internal onlyOwner {}",
                        "    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {",
                        "            ERC1967Utils.upgradeToAndCall(newImplementation, data);"
                    ],
                    "del": [
                        "    function upgradeTo(address) external payable {",
                        "    function upgradeTo(address newImplementation) public override {",
                        "        ERC1967Utils.upgradeToAndCall(newImplementation, bytes(\"\"), false);",
                        "    }",
                        "        ERC1967Utils.upgradeToAndCall(newImplementation, data, false);",
                        "        ERC1967Utils.upgradeToAndCall(_logic, _data, false);",
                        "     * @dev Perform implementation upgrade",
                        "    function upgradeTo(address newImplementation) internal {",
                        "    }",
                        "    /**",
                        "     * @dev Perform implementation upgrade with additional setup call.",
                        "     *",
                        "     * Emits an {IERC1967-Upgraded} event.",
                        "     */",
                        "    function upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {",
                        "        upgradeTo(newImplementation);",
                        "        if (data.length > 0 || forceCall) {",
                        "     * @dev Change the beacon and trigger a setup call.",
                        "    function upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {",
                        "        if (data.length > 0 || forceCall) {",
                        "        ERC1967Utils.upgradeBeaconToAndCall(beacon, data, false);",
                        "     * @dev Sets the initial owner who can perform upgrades.",
                        "    constructor(address initialOwner) Ownable(initialOwner) {}",
                        "     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - This contract must be the admin of `proxy`.",
                        "    function upgrade(ITransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {",
                        "        proxy.upgradeTo(implementation);",
                        "    }",
                        "     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See",
                        "     * {TransparentUpgradeableProxy-upgradeToAndCall}.",
                        " * does not implement this interface directly, and some of its functions are implemented by an internal dispatch",
                        "    function upgradeTo(address) external;",
                        "    function upgradeToAndCall(address, bytes memory) external payable;",
                        " * @dev This contract implements a proxy that is upgradeable by an immutable admin.",
                        " * that call matches one of the admin functions exposed by the proxy itself.",
                        " * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the",
                        " * from the proxy implementation.",
                        " *",
                        " * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,",
                        " * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy, which extends from the",
                        " * {Ownable} contract to allow for changing the proxy's admin owner.",
                        " * inherit from that interface, and instead the admin functions are implicitly implemented using a custom dispatch",
                        " * mechanism in `_fallback`. Consequently, the compiler will not produce an ABI for this contract. This is necessary to",
                        " * fully implement transparency without decoding reverts caused by selector clashes between the proxy and the",
                        " * render the admin operations inaccessible, which could prevent upgradeability. Transparency may also be compromised.",
                        "     * @dev msg.value is not 0.",
                        "     */",
                        "    error ProxyNonPayableFunction();",
                        "    /**",
                        "     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and",
                        "     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.",
                        "    constructor(address _logic, address admin_, bytes memory _data) payable ERC1967Proxy(_logic, _data) {",
                        "        _admin = admin_;",
                        "        ERC1967Utils.changeAdmin(admin_);",
                        "     * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior",
                        "            bytes memory ret;",
                        "            bytes4 selector = msg.sig;",
                        "            if (selector == ITransparentUpgradeableProxy.upgradeTo.selector) {",
                        "                ret = _dispatchUpgradeTo();",
                        "            } else if (selector == ITransparentUpgradeableProxy.upgradeToAndCall.selector) {",
                        "                ret = _dispatchUpgradeToAndCall();",
                        "            assembly {",
                        "                return(add(ret, 0x20), mload(ret))",
                        "            }",
                        "     * @dev Upgrade the implementation of the proxy.",
                        "     */",
                        "    function _dispatchUpgradeTo() private returns (bytes memory) {",
                        "        _requireZeroValue();",
                        "        address newImplementation = abi.decode(msg.data[4:], (address));",
                        "        ERC1967Utils.upgradeToAndCall(newImplementation, bytes(\"\"), false);",
                        "        return \"\";",
                        "    }",
                        "    /**",
                        "     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified",
                        "     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the",
                        "     * proxied contract.",
                        "    function _dispatchUpgradeToAndCall() private returns (bytes memory) {",
                        "        ERC1967Utils.upgradeToAndCall(newImplementation, data, true);",
                        "        return \"\";",
                        "    }",
                        "    /**",
                        "     * @dev To keep this contract fully transparent, the fallback is payable. This helper is here to enforce",
                        "     * non-payability of function implemented through dispatchers while still allowing value to pass through.",
                        "     */",
                        "    function _requireZeroValue() private {",
                        "        if (msg.value != 0) {",
                        "            revert ProxyNonPayableFunction();",
                        "        }",
                        "    /**",
                        "     * @dev Upgrade the implementation of the proxy to `newImplementation`.",
                        "     *",
                        "     * Calls {_authorizeUpgrade}.",
                        "     *",
                        "     * Emits an {Upgraded} event.",
                        "     *",
                        "     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall",
                        "     */",
                        "    function upgradeTo(address newImplementation) public virtual onlyProxy {",
                        "        _authorizeUpgrade(newImplementation);",
                        "        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);",
                        "    }",
                        "        _upgradeToAndCallUUPS(newImplementation, data, true);",
                        "     * {upgradeTo} and {upgradeToAndCall}.",
                        "     * function _authorizeUpgrade(address) internal  onlyOwner {}",
                        "    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) private {",
                        "            ERC1967Utils.upgradeToAndCall(newImplementation, data, forceCall);"
                    ]
                }
            }
        ],
        "- `Proxy`: Removed redundant `receive` function. ([#4434](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4434))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4434": {
                    "add": [],
                    "del": [
                        "    /**",
                        "     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data",
                        "     * is empty.",
                        "     */",
                        "    receive() external payable virtual {",
                        "        _fallback();",
                        "    }"
                    ]
                }
            }
        ],
        "- `BeaconProxy`: Use an immutable variable to store the address of the beacon. It is no longer possible for a `BeaconProxy` to upgrade by changing to another beacon. ([#4435](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4435))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4435": {
                    "add": [
                        "     * @dev Change the beacon and trigger a setup call.",
                        "     *",
                        "     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since",
                        "     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for",
                        "     * efficiency.",
                        " *",
                        " * CAUTION: The beacon address can only be set once during construction, and cannot be changed afterwards.",
                        " * You must ensure that you either control the beacon, or trust the beacon to not upgrade the implementation maliciously.",
                        "    address private immutable _beacon;",
                        "        _beacon = beacon;",
                        "        return IBeacon(_getBeacon()).implementation();",
                        "    }",
                        "    /**",
                        "     * @dev Returns the beacon.",
                        "     */",
                        "    function _getBeacon() internal view virtual returns (address) {",
                        "        return _beacon;"
                    ],
                    "del": [
                        "     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does",
                        "     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).",
                        "        return IBeacon(ERC1967Utils.getBeacon()).implementation();"
                    ]
                }
            }
        ],
        "- `Initializable`: Use the namespaced storage pattern to avoid putting critical variables in slot 0. Allow reinitializer versions greater than 256. ([#4460](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4460))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4460": {
                    "add": [
                        "    function getInitializedVersion() public view returns (uint64) {",
                        "    function reinitialize(uint64 i) public reinitializer(i) {",
                        "    function nestedReinitialize(uint64 i, uint64 j) public reinitializer(i) {",
                        "    function chainReinitialize(uint64 i, uint64 j) public {",
                        "     * @dev Storage of the initializable contract.",
                        "     *",
                        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions",
                        "     * when using with upgradeable contracts.",
                        "     *",
                        "     * @custom:storage-location erc7201:openzeppelin.storage.Initializable",
                        "    struct InitializableStorage {",
                        "        /**",
                        "         * @dev Indicates that the contract has been initialized.",
                        "         */",
                        "        uint64 _initialized;",
                        "        /**",
                        "         * @dev Indicates that the contract is in the process of being initialized.",
                        "         */",
                        "        bool _initializing;",
                        "    }",
                        "    bytes32 private constant _INITIALIZABLE_STORAGE =",
                        "        0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0e;",
                        "    event Initialized(uint64 version);",
                        "        InitializableStorage storage $ = _getInitializableStorage();",
                        "        bool isTopLevelCall = !$._initializing;",
                        "        if (!(isTopLevelCall && $._initialized < 1) && !(address(this).code.length == 0 && $._initialized == 1)) {",
                        "        $._initialized = 1;",
                        "            $._initializing = true;",
                        "            $._initializing = false;",
                        "    modifier reinitializer(uint64 version) {",
                        "        InitializableStorage storage $ = _getInitializableStorage();",
                        "        if ($._initializing || $._initialized >= version) {",
                        "        $._initialized = version;",
                        "        $._initializing = true;",
                        "        $._initializing = false;",
                        "        if (!_isInitializing()) {",
                        "        InitializableStorage storage $ = _getInitializableStorage();",
                        "        if ($._initializing) {",
                        "        if ($._initialized != type(uint64).max) {",
                        "            $._initialized = type(uint64).max;",
                        "            emit Initialized(type(uint64).max);",
                        "    function _getInitializedVersion() internal view returns (uint64) {",
                        "        return _getInitializableStorage()._initialized;",
                        "        return _getInitializableStorage()._initializing;",
                        "    }",
                        "    /**",
                        "     * @dev Returns a pointer to the storage namespace.",
                        "     */",
                        "    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {",
                        "        assembly {",
                        "            $.slot := _INITIALIZABLE_STORAGE",
                        "        }"
                    ],
                    "del": [
                        "    function getInitializedVersion() public view returns (uint8) {",
                        "    function reinitialize(uint8 i) public reinitializer(i) {",
                        "    function nestedReinitialize(uint8 i, uint8 j) public reinitializer(i) {",
                        "    function chainReinitialize(uint8 i, uint8 j) public {",
                        "     * @dev Indicates that the contract has been initialized.",
                        "    uint8 private _initialized;",
                        "    /**",
                        "     * @dev Indicates that the contract is in the process of being initialized.",
                        "     */",
                        "    bool private _initializing;",
                        "    event Initialized(uint8 version);",
                        "        bool isTopLevelCall = !_initializing;",
                        "        if (!(isTopLevelCall && _initialized < 1) && !(address(this).code.length == 0 && _initialized == 1)) {",
                        "        _initialized = 1;",
                        "            _initializing = true;",
                        "            _initializing = false;",
                        "    modifier reinitializer(uint8 version) {",
                        "        if (_initializing || _initialized >= version) {",
                        "        _initialized = version;",
                        "        _initializing = true;",
                        "        _initializing = false;",
                        "        if (!_initializing) {",
                        "        if (_initializing) {",
                        "        if (_initialized != type(uint8).max) {",
                        "            _initialized = type(uint8).max;",
                        "            emit Initialized(type(uint8).max);",
                        "    function _getInitializedVersion() internal view returns (uint8) {",
                        "        return _initialized;",
                        "        return _initializing;"
                    ]
                }
            }
        ],
        "- `ERC20`: Removed `Approval` event previously emitted in `transferFrom` to indicate that part of the allowance was consumed. With this change, allowances are no longer reconstructible from events. See the code for guidelines on how to re-enable this event if needed. ([#4370](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4370))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4370": {
                    "add": [
                        "abstract contract ERC20ApprovalMock is ERC20 {",
                        "    function _approve(address owner, address spender, uint256 amount, bool) internal virtual override {",
                        "        super._approve(owner, spender, amount, true);",
                        "    }",
                        "}",
                        "        _approve(owner, spender, amount, true);",
                        "    }",
                        "    /**",
                        "     * @dev Alternative version of {_approve} with an optional flag that can enable or disable the Approval event.",
                        "     *",
                        "     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by",
                        "     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any",
                        "     * `Approval` event during `transferFrom` operations.",
                        "     *",
                        "     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to true",
                        "     * using the following override:",
                        "     * ```",
                        "     * function _approve(address owner, address spender, uint256 amount, bool) internal virtual override {",
                        "     *     super._approve(owner, spender, amount, true);",
                        "     * }",
                        "     * ```",
                        "     *",
                        "     * Requirements are the same as {_approve}.",
                        "     */",
                        "    function _approve(address owner, address spender, uint256 amount, bool emitEvent) internal virtual {",
                        "        if (emitEvent) {",
                        "            emit Approval(owner, spender, amount);",
                        "        }",
                        "                _approve(owner, spender, currentAllowance - amount, false);"
                    ],
                    "del": [
                        "        emit Approval(owner, spender, amount);",
                        "                _approve(owner, spender, currentAllowance - amount);"
                    ]
                }
            }
        ],
        "- `ERC20`: Removed the non-standard `increaseAllowance` and `decreaseAllowance` functions. ([#4585](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4585))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4585": {
                    "add": [],
                    "del": [
                        " *",
                        " * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}",
                        " * functions have been added to mitigate the well-known issues around setting",
                        " * allowances. See {IERC20-approve}.",
                        "    /**",
                        "     * @dev Atomically increases the allowance granted to `spender` by the caller.",
                        "     *",
                        "     * This is an alternative to {approve} that can be used as a mitigation for",
                        "     * problems described in {IERC20-approve}.",
                        "     *",
                        "     * Emits an {Approval} event indicating the updated allowance.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `spender` cannot be the zero address.",
                        "     */",
                        "    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {",
                        "        address owner = _msgSender();",
                        "        _approve(owner, spender, allowance(owner, spender) + addedValue);",
                        "        return true;",
                        "    }",
                        "    /**",
                        "     * @dev Atomically decreases the allowance granted to `spender` by the caller.",
                        "     *",
                        "     * This is an alternative to {approve} that can be used as a mitigation for",
                        "     * problems described in {IERC20-approve}.",
                        "     *",
                        "     * Emits an {Approval} event indicating the updated allowance.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `spender` cannot be the zero address.",
                        "     * - `spender` must have allowance for the caller of at least",
                        "     * `requestedDecrease`.",
                        "     *",
                        "     * NOTE: Although this function is designed to avoid double spending with {approval},",
                        "     * it can still be frontrunned, preventing any attempt of allowance reduction.",
                        "     */",
                        "    function decreaseAllowance(address spender, uint256 requestedDecrease) public virtual returns (bool) {",
                        "        address owner = _msgSender();",
                        "        uint256 currentAllowance = allowance(owner, spender);",
                        "        if (currentAllowance < requestedDecrease) {",
                        "            revert ERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);",
                        "        }",
                        "        unchecked {",
                        "            _approve(owner, spender, currentAllowance - requestedDecrease);",
                        "        }",
                        "        return true;",
                        "    }"
                    ]
                }
            }
        ],
        "- `ERC20Votes`: Changed internal vote accounting to reusable `Votes` module previously used by `ERC721Votes`. Removed implicit `ERC20Permit` inheritance. Note that the `DOMAIN_SEPARATOR` getter was previously guaranteed to be available for `ERC20Votes` contracts, but is no longer available unless `ERC20Permit` is explicitly used; ERC-5267 support is included in `ERC20Votes` with `EIP712` and is recommended as an alternative. ([#3816](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3816))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3816": {
                    "add": [
                        "abstract contract Votes is IVotes, Context, EIP712, Nonces {",
                        "     * @dev Get number of checkpoints for `account`.",
                        "    function _numCheckpoints(address account) internal view virtual returns (uint32) {",
                        "        return SafeCast.toUint32(_delegateCheckpoints[account].length());",
                        "     * @dev Get the `pos`-th checkpoint for `account`.",
                        "    function _checkpoints(address account, uint32 pos) internal view virtual returns (Checkpoints.Checkpoint memory) {",
                        "        return _delegateCheckpoints[account].getAtPosition(pos);",
                        "    }",
                        "    function _add(uint256 a, uint256 b) private pure returns (uint256) {",
                        "        return a + b;",
                        "    }",
                        "    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {",
                        "        return a - b;",
                        "    constructor(string memory name, string memory symbol) ERC20(name, symbol) EIP712(name, \"1\") {}",
                        "    constructor(string memory name, string memory symbol) ERC20(name, symbol) EIP712(name, \"1\") {}",
                        "    function burn(address, uint256 tokenId) public {",
                        "contract NoncesImpl is Nonces {",
                        "    function useNonce(address owner) public {",
                        "        super._useNonce(owner);",
                        "    }",
                        "}",
                        "    function burn(address, uint256 voteId) external {",
                        "abstract contract ERC20Permit is ERC20, IERC20Permit, EIP712, Nonces {",
                        "    function nonces(address owner) public view virtual override(IERC20Permit, Nonces) returns (uint256) {",
                        "        return super.nonces(owner);",
                        "abstract contract ERC20Votes is ERC20, Votes {",
                        "        _transferVotingUnits(from, to, amount);",
                        "     * @dev Get number of checkpoints for `account`.",
                        "    function numCheckpoints(address account) public view virtual returns (uint32) {",
                        "        return _numCheckpoints(account);",
                        "    /**",
                        "     * @dev Get the `pos`-th checkpoint for `account`.",
                        "     */",
                        "    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoints.Checkpoint memory) {",
                        "        return _checkpoints(account, pos);",
                        "    /**",
                        "     * @dev Returns the balance of `account`.",
                        "     */",
                        "    function _getVotingUnits(address account) internal view virtual override returns (uint256) {",
                        "        return balanceOf(account);",
                        "    /**",
                        "     * @dev Snapshots the totalSupply after it has been increased.",
                        "     */",
                        "    function _mint(address account, uint256 amount) internal virtual override {",
                        "        super._mint(account, amount);",
                        "        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");",
                        "    /**",
                        "     * @dev Returns checkpoint at given position.",
                        "     */",
                        "    function getAtPosition(History storage self, uint32 pos) internal view returns (Checkpoint memory) {",
                        "        return self._checkpoints[pos];",
                        "    }",
                        "/**",
                        " * @dev Provides tracking nonces for addresses. Nonces will only increment.",
                        " */",
                        "abstract contract Nonces {",
                        "    using Counters for Counters.Counter;",
                        "    mapping(address => Counters.Counter) private _nonces;",
                        "    /**",
                        "     * @dev Returns an address nonce.",
                        "     */",
                        "    function nonces(address owner) public view virtual returns (uint256) {",
                        "        return _nonces[owner].current();",
                        "    }",
                        "    /**",
                        "     * @dev Consumes a nonce.",
                        "     *",
                        "     * Returns the current value and increments nonce.",
                        "     */",
                        "    function _useNonce(address owner) internal virtual returns (uint256 current) {",
                        "        Counters.Counter storage nonce = _nonces[owner];",
                        "        current = nonce.current();",
                        "        nonce.increment();",
                        "    }",
                        "}"
                    ],
                    "del": [
                        "abstract contract Votes is IVotes, Context, EIP712 {",
                        "    using Counters for Counters.Counter;",
                        "    mapping(address => Counters.Counter) private _nonces;",
                        "    function _add(uint256 a, uint256 b) private pure returns (uint256) {",
                        "        return a + b;",
                        "    }",
                        "    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {",
                        "        return a - b;",
                        "    }",
                        "     * @dev Consumes a nonce.",
                        "     *",
                        "     * Returns the current value and increments nonce.",
                        "    function _useNonce(address owner) internal virtual returns (uint256 current) {",
                        "        Counters.Counter storage nonce = _nonces[owner];",
                        "        current = nonce.current();",
                        "        nonce.increment();",
                        "     * @dev Returns an address nonce.",
                        "    function nonces(address owner) public view virtual returns (uint256) {",
                        "        return _nonces[owner].current();",
                        "    constructor(string memory name, string memory symbol) ERC20(name, symbol) ERC20Permit(name) {}",
                        "    constructor(string memory name, string memory symbol) ERC20(name, symbol) ERC20Permit(name) {}",
                        "    function burn(uint256 tokenId) public {",
                        "    function burn(uint256 voteId) external {",
                        "abstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {",
                        "    using Counters for Counters.Counter;",
                        "    mapping(address => Counters.Counter) private _nonces;",
                        "    function nonces(address owner) public view virtual override returns (uint256) {",
                        "        return _nonces[owner].current();",
                        "    /**",
                        "     * @dev \"Consume a nonce\": return the current value and increment.",
                        "     *",
                        "     * _Available since v4.1._",
                        "     */",
                        "    function _useNonce(address owner) internal virtual returns (uint256 current) {",
                        "        Counters.Counter storage nonce = _nonces[owner];",
                        "        current = nonce.current();",
                        "        nonce.increment();",
                        "    }",
                        "abstract contract ERC20Votes is IVotes, ERC20Permit {",
                        "    struct Checkpoint {",
                        "        uint32 fromBlock;",
                        "        uint224 votes;",
                        "    }",
                        "    bytes32 private constant _DELEGATION_TYPEHASH =",
                        "        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");",
                        "    mapping(address => address) private _delegates;",
                        "    mapping(address => Checkpoint[]) private _checkpoints;",
                        "    Checkpoint[] private _totalSupplyCheckpoints;",
                        "    /**",
                        "     * @dev Get the `pos`-th checkpoint for `account`.",
                        "     */",
                        "    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {",
                        "        return _checkpoints[account][pos];",
                        "    }",
                        "    /**",
                        "     * @dev Get number of checkpoints for `account`.",
                        "     */",
                        "    function numCheckpoints(address account) public view virtual returns (uint32) {",
                        "        return SafeCast.toUint32(_checkpoints[account].length);",
                        "    }",
                        "    /**",
                        "     * @dev Get the address `account` is currently delegating to.",
                        "     */",
                        "    function delegates(address account) public view virtual override returns (address) {",
                        "        return _delegates[account];",
                        "    }",
                        "    /**",
                        "     * @dev Gets the current votes balance for `account`",
                        "     */",
                        "    function getVotes(address account) public view virtual override returns (uint256) {",
                        "        uint256 pos = _checkpoints[account].length;",
                        "        unchecked {",
                        "            return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `blockNumber` must have been already mined",
                        "     */",
                        "    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");",
                        "        return _checkpointsLookup(_checkpoints[account], blockNumber);",
                        "    }",
                        "    /**",
                        "     * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.",
                        "     * It is NOT the sum of all the delegated votes!",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `blockNumber` must have been already mined",
                        "     */",
                        "    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");",
                        "        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);",
                        "    }",
                        "    /**",
                        "     * @dev Lookup a value in a list of (sorted) checkpoints.",
                        "     */",
                        "    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {",
                        "        //",
                        "        uint256 length = ckpts.length;",
                        "        uint256 low = 0;",
                        "        uint256 high = length;",
                        "        if (length > 5) {",
                        "            uint256 mid = length - Math.sqrt(length);",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > blockNumber) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }",
                        "        }",
                        "        while (low < high) {",
                        "            uint256 mid = Math.average(low, high);",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > blockNumber) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }",
                        "        }",
                        "        unchecked {",
                        "            return high == 0 ? 0 : _unsafeAccess(ckpts, high - 1).votes;",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Delegate votes from the sender to `delegatee`.",
                        "     */",
                        "    function delegate(address delegatee) public virtual override {",
                        "        _delegate(_msgSender(), delegatee);",
                        "    }",
                        "    /**",
                        "     * @dev Delegates votes from signer to `delegatee`",
                        "     */",
                        "    function delegateBySig(",
                        "        address delegatee,",
                        "        uint256 nonce,",
                        "        uint256 expiry,",
                        "        uint8 v,",
                        "        bytes32 r,",
                        "        bytes32 s",
                        "    ) public virtual override {",
                        "        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");",
                        "        address signer = ECDSA.recover(",
                        "            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),",
                        "            v,",
                        "            r,",
                        "            s",
                        "        );",
                        "        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");",
                        "        _delegate(signer, delegatee);",
                        "    }",
                        "    /**",
                        "     * @dev Snapshots the totalSupply after it has been increased.",
                        "     */",
                        "    function _mint(address account, uint256 amount) internal virtual override {",
                        "        super._mint(account, amount);",
                        "        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");",
                        "        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);",
                        "    }",
                        "    /**",
                        "     * @dev Snapshots the totalSupply after it has been decreased.",
                        "     */",
                        "    function _burn(address account, uint256 amount) internal virtual override {",
                        "        super._burn(account, amount);",
                        "        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);",
                        "    }",
                        "        _moveVotingPower(delegates(from), delegates(to), amount);",
                        "     * @dev Change delegation for `delegator` to `delegatee`.",
                        "     *",
                        "     * Emits events {IVotes-DelegateChanged} and {IVotes-DelegateVotesChanged}.",
                        "    function _delegate(address delegator, address delegatee) internal virtual {",
                        "        address currentDelegate = delegates(delegator);",
                        "        uint256 delegatorBalance = balanceOf(delegator);",
                        "        _delegates[delegator] = delegatee;",
                        "        emit DelegateChanged(delegator, currentDelegate, delegatee);",
                        "        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);",
                        "    }",
                        "    function _moveVotingPower(",
                        "        address src,",
                        "        address dst,",
                        "        uint256 amount",
                        "    ) private {",
                        "        if (src != dst && amount > 0) {",
                        "            if (src != address(0)) {",
                        "                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);",
                        "                emit DelegateVotesChanged(src, oldWeight, newWeight);",
                        "            }",
                        "            if (dst != address(0)) {",
                        "                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);",
                        "                emit DelegateVotesChanged(dst, oldWeight, newWeight);",
                        "            }",
                        "        }",
                        "    }",
                        "    function _writeCheckpoint(",
                        "        Checkpoint[] storage ckpts,",
                        "        function(uint256, uint256) view returns (uint256) op,",
                        "        uint256 delta",
                        "    ) private returns (uint256 oldWeight, uint256 newWeight) {",
                        "        uint256 pos = ckpts.length;",
                        "        unchecked {",
                        "            Checkpoint memory oldCkpt = pos == 0 ? Checkpoint(0, 0) : _unsafeAccess(ckpts, pos - 1);",
                        "            oldWeight = oldCkpt.votes;",
                        "            newWeight = op(oldWeight, delta);",
                        "            if (pos > 0 && oldCkpt.fromBlock == block.number) {",
                        "                _unsafeAccess(ckpts, pos - 1).votes = SafeCast.toUint224(newWeight);",
                        "            } else {",
                        "                ckpts.push(",
                        "                    Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)})",
                        "                );",
                        "            }",
                        "        }",
                        "    function _add(uint256 a, uint256 b) private pure returns (uint256) {",
                        "        return a + b;",
                        "    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {",
                        "        return a - b;",
                        "    function _unsafeAccess(Checkpoint[] storage ckpts, uint256 pos) private pure returns (Checkpoint storage result) {",
                        "        assembly {",
                        "            mstore(0, ckpts.slot)",
                        "            result.slot := add(keccak256(0, 0x20), pos)",
                        "        }"
                    ]
                }
            }
        ],
        "- `SafeERC20`: Refactored `safeDecreaseAllowance` and `safeIncreaseAllowance` to support USDT-like tokens. ([#4260](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4260))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4260": {
                    "add": [
                        "        forceApprove(token, spender, oldAllowance + value);",
                        "            forceApprove(token, spender, oldAllowance - value);"
                    ],
                    "del": [
                        "        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));",
                        "            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));"
                    ]
                }
            }
        ],
        "- `SafeERC20`: Removed `safePermit` in favor of documentation-only `permit` recommendations. Based on recommendations from @trust1995 ([#4582](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4582))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4582": {
                    "add": [
                        "     * @inheritdoc IERC20Permit",
                        "     * @inheritdoc IERC20Permit",
                        "     * @inheritdoc IERC20Permit",
                        " *",
                        " * ==== Security Considerations",
                        " *",
                        " * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature",
                        " * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be",
                        " * considered as an intention to spend the allowance in any specific way. The second is that because permits have",
                        " * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should",
                        " * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be",
                        " * generally recommended is:",
                        " *",
                        " * ```solidity",
                        " * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {",
                        " *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}",
                        " *     doThing(..., value);",
                        " * }",
                        " *",
                        " * function doThing(..., uint256 value) public {",
                        " *     token.safeTransferFrom(msg.sender, address(this), value);",
                        " *     ...",
                        " * }",
                        " * ```",
                        " *",
                        " * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of",
                        " * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also",
                        " * {SafeERC20-safeTransferFrom}).",
                        " *",
                        " * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so",
                        " * contracts should have entry points that don't rely on permit.",
                        "     *",
                        "     * CAUTION: See Security Considerations above."
                    ],
                    "del": [
                        "abstract contract ERC20PermitNoRevertMock is ERC20Permit {",
                        "    function permitThatMayRevert(",
                        "        address owner,",
                        "        address spender,",
                        "        uint256 value,",
                        "        uint256 deadline,",
                        "        uint8 v,",
                        "        bytes32 r,",
                        "        bytes32 s",
                        "    ) public virtual {",
                        "        super.permit(owner, spender, value, deadline, v, r, s);",
                        "    }",
                        "    function permit(",
                        "        address owner,",
                        "        address spender,",
                        "        uint256 value,",
                        "        uint256 deadline,",
                        "        uint8 v,",
                        "        bytes32 r,",
                        "        bytes32 s",
                        "    ) public virtual override {",
                        "        try this.permitThatMayRevert(owner, spender, value, deadline, v, r, s) {",
                        "        } catch {",
                        "        }",
                        "    }",
                        "}",
                        "     * @dev See {IERC20Permit-permit}.",
                        "     * @dev See {IERC20Permit-nonces}.",
                        "     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.",
                        "    /**",
                        "     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.",
                        "     * Revert on invalid signature.",
                        "     */",
                        "    function safePermit(",
                        "        IERC20Permit token,",
                        "        address owner,",
                        "        address spender,",
                        "        uint256 value,",
                        "        uint256 deadline,",
                        "        uint8 v,",
                        "        bytes32 r,",
                        "        bytes32 s",
                        "    ) internal {",
                        "        uint256 nonceBefore = token.nonces(owner);",
                        "        token.permit(owner, spender, value, deadline, v, r, s);",
                        "        uint256 nonceAfter = token.nonces(owner);",
                        "        if (nonceAfter != nonceBefore + 1) {",
                        "            revert SafeERC20FailedOperation(address(token));",
                        "        }",
                        "    }"
                    ]
                }
            }
        ],
        "- `ERC721`: `_approve` no longer allows approving the owner of the tokenId. ([#4377](https://github.com/OpenZeppelin/openzeppelin-contracts/issues/4377)) `_setApprovalForAll` no longer allows setting address(0) as an operator. ([#4377](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4377))\r": [
            "https://github.com/OpenZeppelin/openzeppelin-contracts/issues/4377",
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4377": {
                    "add": [
                        "    function _update(",
                        "        uint256 tokenId,",
                        "        address auth",
                        "    ) internal virtual override(ERC721Consecutive, ERC721Enumerable) returns (address) {",
                        "        return super._update(to, tokenId, auth);",
                        "    function _increaseBalance(address account, uint128 amount) internal virtual override(ERC721, ERC721Enumerable) {",
                        "        super._increaseBalance(account, amount);",
                        "    function _update(",
                        "        uint256 tokenId,",
                        "        address auth",
                        "    ) internal virtual override(ERC721Consecutive, ERC721Pausable, ERC721Votes) returns (address) {",
                        "        return super._update(to, tokenId, auth);",
                        "    function _increaseBalance(address account, uint128 amount) internal virtual override(ERC721, ERC721Votes) {",
                        "        super._increaseBalance(account, amount);",
                        "        _approve(to, tokenId, _msgSender());",
                        "        return _getApproved(tokenId);",
                        "        if (to == address(0)) {",
                        "            revert ERC721InvalidReceiver(address(0));",
                        "        }",
                        "        address previousOwner = _update(to, tokenId, _msgSender());",
                        "        if (previousOwner != from) {",
                        "            revert ERC721IncorrectOwner(from, tokenId, previousOwner);",
                        "    function safeTransferFrom(address from, address to, uint256 tokenId) public {",
                        "        transferFrom(from, to, tokenId);",
                        "        _checkOnERC721Received(from, to, tokenId, data);",
                        "     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist",
                        "     * IMPORTANT: Any overrides to this function that add ownership of tokens not tracked by the",
                        "     * core ERC721 logic MUST be matched with the use of {_increaseBalance} to keep balances",
                        "     * consistent with ownership. The invariant to preserve is that for any address `a` the value returned by",
                        "     * `balanceOf(a)` must be equal to the number of tokens such that `_ownerOf(tokenId)` is `a`.",
                        "    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {",
                        "        return _owners[tokenId];",
                        "     * @dev Returns the approved address for `tokenId`. Returns 0 if `tokenId` is not minted.",
                        "    function _getApproved(uint256 tokenId) internal view virtual returns (address) {",
                        "        return _tokenApprovals[tokenId];",
                        "     * @dev Returns whether `spender` is allowed to manage `owner`'s tokens, or `tokenId` in",
                        "     * particular (ignoring whether it is owned by `owner`).",
                        "     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not",
                        "     * verify this assumption.",
                        "    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {",
                        "        return",
                        "            spender != address(0) &&",
                        "            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);",
                        "     * @dev Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.",
                        "     * Reverts if `spender` has not approval for all assets of the provided `owner` nor the actual owner approved the `spender` for the specific `tokenId`.",
                        "     * WARNING: This function relies on {_isAuthorized}, so it doesn't check whether `owner` is the",
                        "     * actual owner of `tokenId`.",
                        "    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {",
                        "        if (!_isAuthorized(owner, spender, tokenId)) {",
                        "            if (owner == address(0)) {",
                        "                revert ERC721NonexistentToken(tokenId);",
                        "            } else {",
                        "                revert ERC721InsufficientApproval(spender, tokenId);",
                        "            }",
                        "        }",
                        "     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.",
                        "     * NOTE: the value is limited to type(uint128).max. This protect against _balance overflow. It is unrealistic that",
                        "     * a uint256 would ever overflow from increments when these increments are bounded to uint128 values.",
                        "     * WARNING: Increasing an account's balance using this function tends to be paired with an override of the",
                        "     * {_ownerOf} function to resolve the ownership of the corresponding tokens so that balances and ownership",
                        "     * remain consistent with one another.",
                        "    function _increaseBalance(address account, uint128 value) internal virtual {",
                        "        unchecked {",
                        "            _balances[account] += value;",
                        "        }",
                        "     * @dev Transfers `tokenId` from its current owner to `to`, or alternatively mints (or burns) if the current owner",
                        "     * (or `to`) is the zero address. Returns the owner of the `tokenId` before the update.",
                        "     *",
                        "     * The `auth` argument is optional. If the value passed is non 0, then this function will check that",
                        "     * `auth` is either the owner of the token, or approved to operate on the token (by the owner).",
                        "     *",
                        "     * Emits a {Transfer} event.",
                        "     *",
                        "     * NOTE: If overriding this function in a way that tracks balances, see also {_increaseBalance}.",
                        "    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {",
                        "        address from = _ownerOf(tokenId);",
                        "        if (auth != address(0)) {",
                        "            _checkAuthorized(from, auth, tokenId);",
                        "        }",
                        "        if (from != address(0)) {",
                        "            delete _tokenApprovals[tokenId];",
                        "            unchecked {",
                        "                _balances[from] -= 1;",
                        "            }",
                        "        }",
                        "        if (to != address(0)) {",
                        "            unchecked {",
                        "                _balances[to] += 1;",
                        "            }",
                        "        _owners[tokenId] = to;",
                        "        emit Transfer(from, to, tokenId);",
                        "        return from;",
                        "    function _mint(address to, uint256 tokenId) internal {",
                        "        address previousOwner = _update(to, tokenId, address(0));",
                        "        if (previousOwner != address(0)) {",
                        "    }",
                        "    /**",
                        "     * @dev Mints `tokenId`, transfers it to `to` and checks for `to` acceptance.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `tokenId` must not exist.",
                        "     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.",
                        "     *",
                        "     * Emits a {Transfer} event.",
                        "     */",
                        "    function _safeMint(address to, uint256 tokenId) internal {",
                        "        _safeMint(to, tokenId, \"\");",
                        "    }",
                        "    /**",
                        "     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is",
                        "     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.",
                        "     */",
                        "    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {",
                        "        _mint(to, tokenId);",
                        "        _checkOnERC721Received(address(0), to, tokenId, data);",
                        "    function _burn(uint256 tokenId) internal {",
                        "        address previousOwner = _update(address(0), tokenId, address(0));",
                        "        if (previousOwner == address(0)) {",
                        "            revert ERC721NonexistentToken(tokenId);",
                        "        }",
                        "    function _transfer(address from, address to, uint256 tokenId) internal {",
                        "        address previousOwner = _update(to, tokenId, address(0));",
                        "        if (previousOwner == address(0)) {",
                        "            revert ERC721NonexistentToken(tokenId);",
                        "        } else if (previousOwner != from) {",
                        "            revert ERC721IncorrectOwner(from, tokenId, previousOwner);",
                        "    }",
                        "    /**",
                        "     * @dev Safely transfers `tokenId` token from `from` to `to`, checking that contract recipients",
                        "     * are aware of the ERC721 standard to prevent tokens from being forever locked.",
                        "     *",
                        "     * `data` is additional data, it has no specified format and it is sent in call to `to`.",
                        "     *",
                        "     * This internal function is like {safeTransferFrom} in the sense that it invokes",
                        "     * {IERC721Receiver-onERC721Received} on the receiver, and can be used to e.g.",
                        "     * implement alternative mechanisms to perform token transfer, such as signature-based.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `tokenId` token must exist and be owned by `from`.",
                        "     * - `to` cannot be the zero address.",
                        "     * - `from` cannot be the zero address.",
                        "     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.",
                        "     *",
                        "     * Emits a {Transfer} event.",
                        "     */",
                        "    function _safeTransfer(address from, address to, uint256 tokenId) internal {",
                        "        _safeTransfer(from, to, tokenId, \"\");",
                        "    }",
                        "    /**",
                        "     * @dev Same as {xref-ERC721-_safeTransfer-address-address-uint256-}[`_safeTransfer`], with an additional `data` parameter which is",
                        "     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.",
                        "     */",
                        "    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {",
                        "        _transfer(from, to, tokenId);",
                        "        _checkOnERC721Received(from, to, tokenId, data);",
                        "     * The `auth` argument is optional. If the value passed is non 0, then this function will check that `auth` is",
                        "     * either the owner of the token, or approved to operate on all tokens held by this owner.",
                        "     *",
                        "    function _approve(address to, uint256 tokenId, address auth) internal virtual returns (address) {",
                        "        address owner = ownerOf(tokenId);",
                        "        if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {",
                        "            revert ERC721InvalidApprover(auth);",
                        "        }",
                        "        emit Approval(owner, to, tokenId);",
                        "        return owner;",
                        "     * Requirements:",
                        "     * - operator can't be the address zero.",
                        "     *",
                        "        if (operator == address(0)) {",
                        "            revert ERC721InvalidOperator(operator);",
                        "        if (_ownerOf(tokenId) == address(0)) {",
                        "     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target address. This will revert if the",
                        "     * recipient doesn't accept the token transfer. The call is not executed if the target address is not a contract.",
                        "     */",
                        "    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {",
                        "                if (retval != IERC721Receiver.onERC721Received.selector) {",
                        "                    revert ERC721InvalidReceiver(to);",
                        "                }",
                        "     * - The `operator` cannot be the address zero.",
                        "        _update(address(0), tokenId, _msgSender());",
                        "            _increaseBalance(to, batchSize);",
                        "     * @dev See {ERC721-_update}. Override version that restricts normal minting to after construction.",
                        "     * WARNING: Using {ERC721Consecutive} prevents minting during construction in favor of {_mintConsecutive}.",
                        "     * After construction, {_mintConsecutive} is no longer available and minting through {_update} becomes available.",
                        "    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {",
                        "        address previousOwner = super._update(to, tokenId, auth);",
                        "        if (previousOwner == address(0) && address(this).code.length == 0) {",
                        "        ) {",
                        "            _sequentialBurn.set(tokenId);",
                        "        return previousOwner;",
                        "     * @dev See {ERC721-_update}.",
                        "    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {",
                        "        address previousOwner = super._update(to, tokenId, auth);",
                        "        if (previousOwner == address(0)) {",
                        "        } else if (previousOwner != to) {",
                        "            _removeTokenFromOwnerEnumeration(previousOwner, tokenId);",
                        "        } else if (previousOwner != to) {",
                        "        return previousOwner;",
                        "        uint256 length = balanceOf(to) - 1;",
                        "        uint256 lastTokenIndex = balanceOf(from);",
                        "    /**",
                        "     * See {ERC721-_increaseBalance}. We need that to account tokens that were minted in batch",
                        "     */",
                        "    function _increaseBalance(address account, uint128 amount) internal virtual override {",
                        "        if (amount > 0) {",
                        "            revert ERC721EnumerableForbiddenBatchMint();",
                        "        }",
                        "        super._increaseBalance(account, amount);",
                        "    }",
                        "     * @dev See {ERC721-_update}.",
                        "    function _update(",
                        "        uint256 tokenId,",
                        "        address auth",
                        "    ) internal virtual override whenNotPaused returns (address) {",
                        "        return super._update(to, tokenId, auth);",
                        "     * @dev See {ERC721-_update}. When burning, this override will additionally clear the royalty information for the token.",
                        "    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {",
                        "        address previousOwner = super._update(to, tokenId, auth);",
                        "        if (to == address(0)) {",
                        "            _resetTokenRoyalty(tokenId);",
                        "        }",
                        "        return previousOwner;",
                        "        if (_ownerOf(tokenId) == address(0)) {",
                        "     * @dev See {ERC721-_update}. When burning, this override will additionally check if a",
                        "    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {",
                        "        address previousOwner = super._update(to, tokenId, auth);",
                        "        if (to == address(0) && bytes(_tokenURIs[tokenId]).length != 0) {",
                        "        return previousOwner;",
                        "     * @dev See {ERC721-_update}. Adjusts votes when tokens are transferred.",
                        "    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {",
                        "        address previousOwner = super._update(to, tokenId, auth);",
                        "        _transferVotingUnits(previousOwner, to, 1);",
                        "        return previousOwner;",
                        "    /**",
                        "     * @dev See {ERC721-_increaseBalance}. We need that to account tokens that were minted in batch.",
                        "     */",
                        "    function _increaseBalance(address account, uint128 amount) internal virtual override {",
                        "        super._increaseBalance(account, amount);",
                        "        _transferVotingUnits(address(0), account, amount);",
                        "    }",
                        "            _update(address(0), tokenId, _msgSender());"
                    ],
                    "del": [
                        "    function _mint(address to, uint256 tokenId) internal virtual override(ERC721, ERC721Consecutive) {",
                        "        super._mint(to, tokenId);",
                        "    }",
                        "    function _beforeTokenTransfer(",
                        "        address from,",
                        "        uint256 firstTokenId,",
                        "        uint256 batchSize",
                        "    ) internal virtual override(ERC721, ERC721Enumerable) {",
                        "        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);",
                        "    function _afterTokenTransfer(",
                        "        address from,",
                        "        address to,",
                        "        uint256 firstTokenId,",
                        "        uint256 batchSize",
                        "    ) internal virtual override(ERC721, ERC721Consecutive) {",
                        "        super._afterTokenTransfer(from, to, firstTokenId, batchSize);",
                        "    function _mint(address to, uint256 tokenId) internal virtual override(ERC721, ERC721Consecutive) {",
                        "        super._mint(to, tokenId);",
                        "    }",
                        "    function _beforeTokenTransfer(",
                        "        address from,",
                        "        uint256 firstTokenId,",
                        "        uint256 batchSize",
                        "    ) internal virtual override(ERC721, ERC721Pausable) {",
                        "        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);",
                        "    function _afterTokenTransfer(",
                        "        address from,",
                        "        address to,",
                        "        uint256 firstTokenId,",
                        "        uint256 batchSize",
                        "    ) internal virtual override(ERC721, ERC721Votes, ERC721Consecutive) {",
                        "        super._afterTokenTransfer(from, to, firstTokenId, batchSize);",
                        "        address owner = ownerOf(tokenId);",
                        "        if (to == owner) {",
                        "            revert ERC721InvalidOperator(owner);",
                        "        }",
                        "        if (_msgSender() != owner && !isApprovedForAll(owner, _msgSender())) {",
                        "            revert ERC721InvalidApprover(_msgSender());",
                        "        }",
                        "        _approve(to, tokenId);",
                        "        return _tokenApprovals[tokenId];",
                        "        if (!_isApprovedOrOwner(_msgSender(), tokenId)) {",
                        "            revert ERC721InsufficientApproval(_msgSender(), tokenId);",
                        "        _transfer(from, to, tokenId);",
                        "    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual {",
                        "        if (!_isApprovedOrOwner(_msgSender(), tokenId)) {",
                        "            revert ERC721InsufficientApproval(_msgSender(), tokenId);",
                        "        }",
                        "        _safeTransfer(from, to, tokenId, data);",
                        "     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients",
                        "     * are aware of the ERC721 protocol to prevent tokens from being forever locked.",
                        "     *",
                        "     * `data` is additional data, it has no specified format and it is sent in call to `to`.",
                        "     *",
                        "     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.",
                        "     * implement alternative mechanisms to perform token transfer, such as signature-based.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `from` cannot be the zero address.",
                        "     * - `to` cannot be the zero address.",
                        "     * - `tokenId` token must exist and be owned by `from`.",
                        "     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.",
                        "     * Emits a {Transfer} event.",
                        "    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {",
                        "        _transfer(from, to, tokenId);",
                        "        if (!_checkOnERC721Received(from, to, tokenId, data)) {",
                        "            revert ERC721InvalidReceiver(to);",
                        "        }",
                        "     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist",
                        "    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {",
                        "        return _owners[tokenId];",
                        "     * @dev Returns whether `tokenId` exists.",
                        "     *",
                        "     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.",
                        "     * Tokens start existing when they are minted (`_mint`),",
                        "     * and stop existing when they are burned (`_burn`).",
                        "    function _exists(uint256 tokenId) internal view virtual returns (bool) {",
                        "        return _ownerOf(tokenId) != address(0);",
                        "     * @dev Returns whether `spender` is allowed to manage `tokenId`.",
                        "     * Requirements:",
                        "     *",
                        "     * - `tokenId` must exist.",
                        "    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {",
                        "        address owner = ownerOf(tokenId);",
                        "        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);",
                        "     * @dev Safely mints `tokenId` and transfers it to `to`.",
                        "     *",
                        "     * Requirements:",
                        "     * - `tokenId` must not exist.",
                        "     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.",
                        "     * Emits a {Transfer} event.",
                        "    function _safeMint(address to, uint256 tokenId) internal virtual {",
                        "        _safeMint(to, tokenId, \"\");",
                        "     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is",
                        "     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.",
                        "    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {",
                        "        _mint(to, tokenId);",
                        "        if (!_checkOnERC721Received(address(0), to, tokenId, data)) {",
                        "            revert ERC721InvalidReceiver(to);",
                        "    function _mint(address to, uint256 tokenId) internal virtual {",
                        "        if (_exists(tokenId)) {",
                        "        _beforeTokenTransfer(address(0), to, tokenId, 1);",
                        "        if (_exists(tokenId)) {",
                        "            revert ERC721InvalidSender(address(0));",
                        "        }",
                        "        unchecked {",
                        "            _balances[to] += 1;",
                        "        }",
                        "        _owners[tokenId] = to;",
                        "        emit Transfer(address(0), to, tokenId);",
                        "        _afterTokenTransfer(address(0), to, tokenId, 1);",
                        "    function _burn(uint256 tokenId) internal virtual {",
                        "        address owner = ownerOf(tokenId);",
                        "        _beforeTokenTransfer(owner, address(0), tokenId, 1);",
                        "        owner = ownerOf(tokenId);",
                        "        delete _tokenApprovals[tokenId];",
                        "        _balances[owner] -= 1;",
                        "        delete _owners[tokenId];",
                        "        emit Transfer(owner, address(0), tokenId);",
                        "        _afterTokenTransfer(owner, address(0), tokenId, 1);",
                        "    function _transfer(address from, address to, uint256 tokenId) internal virtual {",
                        "        address owner = ownerOf(tokenId);",
                        "        if (owner != from) {",
                        "            revert ERC721IncorrectOwner(from, tokenId, owner);",
                        "        }",
                        "        _beforeTokenTransfer(from, to, tokenId, 1);",
                        "        owner = ownerOf(tokenId);",
                        "        if (owner != from) {",
                        "            revert ERC721IncorrectOwner(from, tokenId, owner);",
                        "        }",
                        "        delete _tokenApprovals[tokenId];",
                        "        _balances[from] -= 1;",
                        "        unchecked {",
                        "            _balances[to] += 1;",
                        "        _owners[tokenId] = to;",
                        "        emit Transfer(from, to, tokenId);",
                        "        _afterTokenTransfer(from, to, tokenId, 1);",
                        "    function _approve(address to, uint256 tokenId) internal virtual {",
                        "        emit Approval(ownerOf(tokenId), to, tokenId);",
                        "        if (owner == operator) {",
                        "            revert ERC721InvalidOperator(owner);",
                        "        if (!_exists(tokenId)) {",
                        "     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target address.",
                        "     * The call is not executed if the target address is not a contract.",
                        "     * @return bool whether the call correctly returned the expected magic value",
                        "     */",
                        "    function _checkOnERC721Received(",
                        "        address from,",
                        "        address to,",
                        "        uint256 tokenId,",
                        "        bytes memory data",
                        "    ) private returns (bool) {",
                        "                return retval == IERC721Receiver.onERC721Received.selector;",
                        "        } else {",
                        "            return true;",
                        "    /**",
                        "     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is",
                        "     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.",
                        "     *",
                        "     * Calling conditions:",
                        "     *",
                        "     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.",
                        "     * - When `from` is zero, the tokens will be minted for `to`.",
                        "     * - When `to` is zero, ``from``'s tokens will be burned.",
                        "     * - `from` and `to` are never both zero.",
                        "     * - `batchSize` is non-zero.",
                        "     *",
                        "     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].",
                        "     */",
                        "    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}",
                        "    /**",
                        "     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is",
                        "     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.",
                        "     *",
                        "     * Calling conditions:",
                        "     *",
                        "     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.",
                        "     * - When `from` is zero, the tokens were minted for `to`.",
                        "     * - When `to` is zero, ``from``'s tokens were burned.",
                        "     * - `from` and `to` are never both zero.",
                        "     * - `batchSize` is non-zero.",
                        "     *",
                        "     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].",
                        "     */",
                        "    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}",
                        "    /**",
                        "     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.",
                        "     *",
                        "     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant",
                        "     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such",
                        "     * that `ownerOf(tokenId)` is `a`.",
                        "     */",
                        "    function __unsafe_increaseBalance(address account, uint256 value) internal {",
                        "        _balances[account] += value;",
                        "    }",
                        "     * - The `operator` cannot be the caller.",
                        "        if (!_isApprovedOrOwner(_msgSender(), tokenId)) {",
                        "            revert ERC721InsufficientApproval(_msgSender(), tokenId);",
                        "        }",
                        "        _burn(tokenId);",
                        "            _beforeTokenTransfer(address(0), to, next, batchSize);",
                        "            __unsafe_increaseBalance(to, batchSize);",
                        "            _afterTokenTransfer(address(0), to, next, batchSize);",
                        "     * @dev See {ERC721-_mint}. Override version that restricts normal minting to after construction.",
                        "     * WARNING: Using {ERC721Consecutive} prevents using {_mint} during construction in favor of {_mintConsecutive}.",
                        "     * After construction, {_mintConsecutive} is no longer available and {_mint} becomes available.",
                        "    function _mint(address to, uint256 tokenId) internal virtual override {",
                        "        if (address(this).code.length == 0) {",
                        "        super._mint(to, tokenId);",
                        "    }",
                        "    /**",
                        "     * @dev See {ERC721-_afterTokenTransfer}. Burning of tokens that have been sequentially minted must be explicit.",
                        "     */",
                        "    function _afterTokenTransfer(",
                        "        address from,",
                        "        address to,",
                        "        uint256 firstTokenId,",
                        "        uint256 batchSize",
                        "    ) internal virtual override {",
                        "            firstTokenId >= _firstConsecutiveId() &&",
                        "            firstTokenId < _nextConsecutiveId() &&",
                        "            !_sequentialBurn.get(firstTokenId)",
                        "        {",
                        "            if (batchSize != 1) {",
                        "                revert ERC721ForbiddenBatchBurn();",
                        "            }",
                        "            _sequentialBurn.set(firstTokenId);",
                        "        super._afterTokenTransfer(from, to, firstTokenId, batchSize);",
                        "     * @dev See {ERC721-_beforeTokenTransfer}.",
                        "    function _beforeTokenTransfer(",
                        "        address from,",
                        "        address to,",
                        "        uint256 firstTokenId,",
                        "        uint256 batchSize",
                        "    ) internal virtual override {",
                        "        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);",
                        "        if (batchSize > 1) {",
                        "            revert ERC721EnumerableForbiddenBatchMint();",
                        "        }",
                        "        uint256 tokenId = firstTokenId;",
                        "        if (from == address(0)) {",
                        "        } else if (from != to) {",
                        "            _removeTokenFromOwnerEnumeration(from, tokenId);",
                        "        } else if (to != from) {",
                        "        uint256 length = balanceOf(to);",
                        "        uint256 lastTokenIndex = balanceOf(from) - 1;",
                        "     * @dev See {ERC721-_beforeTokenTransfer}.",
                        "    function _beforeTokenTransfer(",
                        "        address from,",
                        "        uint256 firstTokenId,",
                        "        uint256 batchSize",
                        "    ) internal virtual override {",
                        "        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);",
                        "        _requireNotPaused();",
                        "     * @dev See {ERC721-_burn}. This override additionally clears the royalty information for the token.",
                        "    function _burn(uint256 tokenId) internal virtual override {",
                        "        super._burn(tokenId);",
                        "        _resetTokenRoyalty(tokenId);",
                        "        if (!_exists(tokenId)) {",
                        "     * @dev See {ERC721-_burn}. This override additionally checks to see if a",
                        "    function _burn(uint256 tokenId) internal virtual override {",
                        "        super._burn(tokenId);",
                        "        if (bytes(_tokenURIs[tokenId]).length != 0) {",
                        "     * @dev See {ERC721-_afterTokenTransfer}. Adjusts votes when tokens are transferred.",
                        "    function _afterTokenTransfer(",
                        "        address from,",
                        "        address to,",
                        "        uint256 firstTokenId,",
                        "        uint256 batchSize",
                        "    ) internal virtual override {",
                        "        _transferVotingUnits(from, to, batchSize);",
                        "        super._afterTokenTransfer(from, to, firstTokenId, batchSize);",
                        "            if (!_isApprovedOrOwner(_msgSender(), tokenId)) {",
                        "                revert ERC721InsufficientApproval(_msgSender(), tokenId);",
                        "            }",
                        "            _burn(tokenId);"
                    ]
                }
            }
        ],
        "- `ERC721URIStorage`: Allow setting the token URI prior to minting. ([#4559](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4559))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4559": {
                    "add": [],
                    "del": [
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `tokenId` must exist.",
                        "        if (_ownerOf(tokenId) == address(0)) {",
                        "            revert ERC721NonexistentToken(tokenId);",
                        "        }"
                    ]
                }
            }
        ],
        "- `ERC721URIStorage`, `ERC721Royalty`: Stop resetting token-specific URI and royalties when burning. ([#4561](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4561))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4561": {
                    "add": [],
                    "del": [
                        "    /**",
                        "     * @dev See {ERC721-_update}. When burning, this override will additionally clear the royalty information for the token.",
                        "     */",
                        "    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {",
                        "        address previousOwner = super._update(to, tokenId, auth);",
                        "        if (to == address(0)) {",
                        "            _resetTokenRoyalty(tokenId);",
                        "        }",
                        "        return previousOwner;",
                        "    }",
                        "    /**",
                        "     * @dev See {ERC721-_update}. When burning, this override will additionally check if a",
                        "     * token-specific URI was set for the token, and if so, it deletes the token URI from",
                        "     * the storage mapping.",
                        "     */",
                        "    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {",
                        "        address previousOwner = super._update(to, tokenId, auth);",
                        "        if (to == address(0) && bytes(_tokenURIs[tokenId]).length != 0) {",
                        "            delete _tokenURIs[tokenId];",
                        "        }",
                        "        return previousOwner;",
                        "    }"
                    ]
                }
            }
        ],
        "- `ERC1155`: Optimized array allocation. ([#4196](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4196))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4196": {
                    "add": [
                        "        (uint256[] memory ids, uint256[] memory amounts) = _asSingletonArrays(id, amount);",
                        "        (uint256[] memory ids, uint256[] memory amounts) = _asSingletonArrays(id, amount);",
                        "        (uint256[] memory ids, uint256[] memory amounts) = _asSingletonArrays(id, amount);",
                        "    function _asSingletonArrays(",
                        "        uint256 element1,",
                        "        uint256 element2",
                        "    ) private pure returns (uint256[] memory array1, uint256[] memory array2) {",
                        "        assembly {",
                        "            array1 := mload(0x40)",
                        "            mstore(array1, 1)",
                        "            mstore(add(array1, 0x20), element1)",
                        "            array2 := add(array1, 0x40)",
                        "            mstore(array2, 1)",
                        "            mstore(add(array2, 0x20), element2)",
                        "            mstore(0x40, add(array2, 0x40))",
                        "        }"
                    ],
                    "del": [
                        "        uint256[] memory ids = _asSingletonArray(id);",
                        "        uint256[] memory amounts = _asSingletonArray(amount);",
                        "        uint256[] memory ids = _asSingletonArray(id);",
                        "        uint256[] memory amounts = _asSingletonArray(amount);",
                        "        uint256[] memory ids = _asSingletonArray(id);",
                        "        uint256[] memory amounts = _asSingletonArray(amount);",
                        "    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {",
                        "        uint256[] memory array = new uint256[](1);",
                        "        array[0] = element;",
                        "        return array;"
                    ]
                }
            }
        ],
        "- `ERC1155`: Removed check for address zero in `balanceOf`. ([#4263](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4263))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4263": {
                    "add": [],
                    "del": [
                        "        require(account != address(0), \"ERC1155: address zero is not a valid owner\");"
                    ]
                }
            }
        ],
        "- `ERC1155`: Optimized array accesses by skipping bounds checking when unnecessary. ([#4300](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4300))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4300": {
                    "add": [
                        "    using Arrays for uint256[];",
                        "    using Arrays for address[];",
                        "            batchBalances[i] = balanceOf(accounts.unsafeMemoryAccess(i), ids.unsafeMemoryAccess(i));",
                        "            uint256 id = ids.unsafeMemoryAccess(i);",
                        "            uint256 amount = amounts.unsafeMemoryAccess(i);",
                        "            uint256 id = ids.unsafeMemoryAccess(0);",
                        "            uint256 amount = amounts.unsafeMemoryAccess(0);",
                        "    /**",
                        "     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.",
                        "     *",
                        "     * WARNING: Only use if you are certain `pos` is lower than the array length.",
                        "     */",
                        "    function unsafeMemoryAccess(uint256[] memory arr, uint256 pos) internal pure returns (uint256 res) {",
                        "        assembly {",
                        "            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.",
                        "     *",
                        "     * WARNING: Only use if you are certain `pos` is lower than the array length.",
                        "     */",
                        "    function unsafeMemoryAccess(address[] memory arr, uint256 pos) internal pure returns (address res) {",
                        "        assembly {",
                        "            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))",
                        "        }",
                        "    }"
                    ],
                    "del": [
                        "            batchBalances[i] = balanceOf(accounts[i], ids[i]);",
                        "            uint256 id = ids[i];",
                        "            uint256 amount = amounts[i];",
                        "            uint256 id = ids[0];",
                        "            uint256 amount = amounts[0];"
                    ]
                }
            }
        ],
        "- `ERC1155`: Bubble errors triggered in the `onERC1155Received` and `onERC1155BatchReceived` hooks. ([#4314](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4314))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4314": {
                    "add": [
                        "        if (_executor() != _msgSender()) {",
                        "     * Receiving tokens is disabled if the governance executor is other than the governor itself (eg. when using with a timelock).",
                        "        if (_executor() != address(this)) {",
                        "            revert GovernorDisabledDeposit();",
                        "        }",
                        "     * Receiving tokens is disabled if the governance executor is other than the governor itself (eg. when using with a timelock).",
                        "        if (_executor() != address(this)) {",
                        "            revert GovernorDisabledDeposit();",
                        "        }",
                        "     * Receiving tokens is disabled if the governance executor is other than the governor itself (eg. when using with a timelock).",
                        "        if (_executor() != address(this)) {",
                        "            revert GovernorDisabledDeposit();",
                        "        }",
                        "    enum RevertType {",
                        "        None,",
                        "        Empty,",
                        "        String,",
                        "        Custom",
                        "    }",
                        "    RevertType private _recReverts;",
                        "    RevertType private _batReverts;",
                        "    error ERC1155ReceiverMockError();",
                        "    constructor(bytes4 recRetval, RevertType recReverts, bytes4 batRetval, RevertType batReverts) {",
                        "        if (_recReverts == RevertType.Empty) {",
                        "            revert();",
                        "        } else if (_recReverts == RevertType.String) {",
                        "            revert(\"ERC1155ReceiverMock: reverting on receive\");",
                        "        } else if (_recReverts == RevertType.Custom) {",
                        "            revert ERC1155ReceiverMockError();",
                        "        }",
                        "        if (_batReverts == RevertType.Empty) {",
                        "            revert();",
                        "        } else if (_batReverts == RevertType.String) {",
                        "            revert(\"ERC1155ReceiverMock: reverting on batch receive\");",
                        "        } else if (_batReverts == RevertType.Custom) {",
                        "            revert ERC1155ReceiverMockError();",
                        "        }",
                        "            } catch (bytes memory reason) {",
                        "                if (reason.length == 0) {",
                        "                    revert ERC1155InvalidReceiver(to);",
                        "                } else {",
                        "                    assembly {",
                        "                        revert(add(32, reason), mload(reason))",
                        "                    }",
                        "                }",
                        "            } catch (bytes memory reason) {",
                        "                if (reason.length == 0) {",
                        "                    revert ERC1155InvalidReceiver(to);",
                        "                } else {",
                        "                    assembly {",
                        "                        revert(add(32, reason), mload(reason))",
                        "                    }",
                        "                }"
                    ],
                    "del": [
                        "        if (_msgSender() != _executor()) {",
                        "    bool private _recReverts;",
                        "    bool private _batReverts;",
                        "    constructor(bytes4 recRetval, bool recReverts, bytes4 batRetval, bool batReverts) {",
                        "        require(!_recReverts, \"ERC1155ReceiverMock: reverting on receive\");",
                        "        require(!_batReverts, \"ERC1155ReceiverMock: reverting on batch receive\");",
                        "            } catch Error(string memory reason) {",
                        "                revert(reason);",
                        "            } catch {",
                        "                revert ERC1155InvalidReceiver(to);",
                        "            } catch Error(string memory reason) {",
                        "                revert(reason);",
                        "            } catch {",
                        "                revert ERC1155InvalidReceiver(to);"
                    ]
                }
            }
        ],
        "- `ERC1155Supply`: Added a `totalSupply()` function that returns the total amount of token circulating, this change will restrict the total tokens minted across all ids to 2**256-1 . ([#3962](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3962))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3962": {
                    "add": [
                        "    uint256 private _totalSupplyAll;",
                        "    /**",
                        "     * @dev Total amount of tokens.",
                        "     */",
                        "    function totalSupply() public view virtual returns (uint256) {",
                        "        return _totalSupplyAll;",
                        "    }",
                        "            uint256 totalMintAmount = 0;",
                        "                uint256 amount = amounts[i];",
                        "                _totalSupply[ids[i]] += amount;",
                        "                totalMintAmount += amount;",
                        "            _totalSupplyAll += totalMintAmount;",
                        "            uint256 totalBurnAmount = 0;",
                        "                    totalBurnAmount += amount;",
                        "            unchecked {",
                        "                _totalSupplyAll -= totalBurnAmount;",
                        "            }"
                    ],
                    "del": [
                        "                _totalSupply[ids[i]] += amounts[i];"
                    ]
                }
            }
        ],
        "- `ERC1155Receiver`: Removed in favor of `ERC1155Holder`. ([#4450](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4450))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4450": {
                    "add": [
                        "    ) public view virtual override(AccessControl, ERC1155Holder) returns (bool) {",
                        " * @dev Simple implementation of `IERC1155Receiver` that will allow a contract to hold ERC1155 tokens.",
                        "abstract contract ERC1155Holder is ERC165, IERC1155Receiver {",
                        "    /**",
                        "     * @dev See {IERC165-supportsInterface}.",
                        "     */",
                        "    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {",
                        "        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);",
                        "    }"
                    ],
                    "del": [
                        "    ) public view virtual override(AccessControl, ERC1155Receiver) returns (bool) {",
                        " * @dev Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.",
                        "abstract contract ERC1155Holder is ERC1155Receiver {",
                        "/**",
                        " * @dev Basic contract implementing the ERC-165 interface for {IERC1155Receiver}.",
                        " *",
                        " * NOTE: This contract does not suffice to receive tokens. See {ERC1155Holder}.",
                        " */",
                        "abstract contract ERC1155Receiver is ERC165, IERC1155Receiver {",
                        "    /**",
                        "     * @dev See {IERC165-supportsInterface}.",
                        "     */",
                        "    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {",
                        "        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);",
                        "    }",
                        "}"
                    ]
                }
            }
        ],
        "- `Address`: Removed the ability to customize error messages. A common custom error is always used if the underlying revert reason cannot be bubbled up. ([#4502](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4502))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4502": {
                    "add": [
                        " *",
                        " * NOTE: When using this contract with any token whose balance is adjusted automatically (i.e. a rebase token), make sure",
                        " * to account the supply/balance adjustment in the vesting schedule to ensure the vested amount is as intended.",
                        "        } else if (timestamp >= end()) {",
                        "    /**",
                        "     * @dev Initializes the contract with a trusted forwarder, which will be able to",
                        "     * invoke functions on this contract on behalf of other accounts.",
                        "     *",
                        "     * NOTE: The trusted forwarder can be replaced by overriding {trustedForwarder}.",
                        "     */",
                        "    constructor(address trustedForwarder_) {",
                        "        _trustedForwarder = trustedForwarder_;",
                        "    /**",
                        "     * @dev Returns the address of the trusted forwarder.",
                        "     */",
                        "    function trustedForwarder() public view virtual returns (address) {",
                        "        return _trustedForwarder;",
                        "    }",
                        "    /**",
                        "     * @dev Indicates whether any particular address is the trusted forwarder.",
                        "     */",
                        "        return forwarder == trustedForwarder();",
                        "    /**",
                        "     * @dev Override for `msg.sender`. Defaults to the original `msg.sender` whenever",
                        "     * a call is not performed by the trusted forwarder or the calldata length is less than",
                        "     * 20 bytes (an address length).",
                        "     */",
                        "    /**",
                        "     * @dev Override for `msg.data`. Defaults to the original `msg.data` whenever",
                        "     * a call is not performed by the trusted forwarder or the calldata length is less than",
                        "     * 20 bytes (an address length).",
                        "     */",
                        " * WARNING: Do not approve this contract to spend tokens. Anyone can use this forwarder",
                        " * to execute calls with an arbitrary calldata to any address. Any form of approval may",
                        " * result in a loss of funds for the approving party.",
                        " *",
                        " * NOTE: Batching requests includes an optional refund for unused `msg.value` that is achieved by",
                        " * performing a call with empty calldata. While this is within the bounds of ERC-2771 compliance,",
                        " * if the refund receiver happens to consider the forwarder a trusted forwarder, it MUST properly",
                        " * handle `msg.data.length == 0`. `ERC2771Context` in OpenZeppelin Contracts versions prior to 4.9.3",
                        " * do not handle this properly.",
                        " *",
                        "    /**",
                        "     * @dev The request target doesn't trust the `forwarder`.",
                        "     */",
                        "    error ERC2771UntrustfulTarget(address target, address forwarder);",
                        "     * A transaction is considered valid when the target trusts this forwarder, the request hasn't expired",
                        "     * (deadline is not met), and the signer matches the `from` parameter of the signed request.",
                        "        (bool isTrustedForwarder, bool active, bool signerMatch, ) = _validate(request);",
                        "        return isTrustedForwarder && active && signerMatch;",
                        "    ) internal view virtual returns (bool isTrustedForwarder, bool active, bool signerMatch, address signer) {",
                        "        (bool isValid, address recovered) = _recoverForwardRequestSigner(request);",
                        "        return (",
                        "            _isTrustedByTarget(request.to),",
                        "            request.deadline >= block.timestamp,",
                        "            isValid && recovered == request.from,",
                        "            recovered",
                        "        );",
                        "     * @dev Returns a tuple with the recovered the signer of an EIP712 forward request message hash",
                        "     * and a boolean indicating if the signature is valid.",
                        "     *",
                        "     * NOTE: The signature is considered valid if {ECDSA-tryRecover} indicates no recover error for it.",
                        "    function _recoverForwardRequestSigner(",
                        "        ForwardRequestData calldata request",
                        "    ) internal view virtual returns (bool, address) {",
                        "        (address recovered, ECDSA.RecoverError err, ) = _hashTypedDataV4(",
                        "            keccak256(",
                        "                abi.encode(",
                        "                    _FORWARD_REQUEST_TYPEHASH,",
                        "                    request.from,",
                        "                    request.to,",
                        "                    request.value,",
                        "                    request.gas,",
                        "                    nonces(request.from),",
                        "                    request.deadline,",
                        "                    keccak256(request.data)",
                        "            )",
                        "        ).tryRecover(request.signature);",
                        "        return (err == ECDSA.RecoverError.NoError, recovered);",
                        "        (bool isTrustedForwarder, bool active, bool signerMatch, address signer) = _validate(request);",
                        "            if (!isTrustedForwarder) {",
                        "                revert ERC2771UntrustfulTarget(request.to, address(this));",
                        "            }",
                        "            if (!active) {",
                        "        if (isTrustedForwarder && signerMatch && active) {",
                        "    /**",
                        "     * @dev Returns whether the target trusts this forwarder.",
                        "     *",
                        "     * This function performs a static call to the target contract calling the",
                        "     * {ERC2771Context-isTrustedForwarder} function.",
                        "     */",
                        "    function _isTrustedByTarget(address target) private view returns (bool) {",
                        "        bytes memory encodedParams = abi.encodeCall(ERC2771Context.isTrustedForwarder, (address(this)));",
                        "        bool success;",
                        "        uint256 returnSize;",
                        "        uint256 returnValue;",
                        "        assembly {",
                        "            success := staticcall(gas(), target, add(encodedParams, 0x20), mload(encodedParams), 0, 0x20)",
                        "            returnSize := returndatasize()",
                        "            returnValue := mload(0)",
                        "        }",
                        "        return success && returnSize >= 0x20 && returnValue > 0;",
                        "    }",
                        "contract CallReceiverMockTrustingForwarder is CallReceiverMock {",
                        "    address private _trustedForwarder;",
                        "    constructor(address trustedForwarder_) {",
                        "        _trustedForwarder = trustedForwarder_;",
                        "    }",
                        "    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {",
                        "        return forwarder == _trustedForwarder;",
                        "    }",
                        "}",
                        "contract UpgradeableBeaconMock is IBeacon {",
                        "    address public implementation;",
                        "    constructor(address impl) {",
                        "        implementation = impl;",
                        "    }",
                        "}",
                        "interface IProxyExposed {",
                        "    function $getBeacon() external view returns (address);",
                        "}",
                        "contract UpgradeableBeaconReentrantMock is IBeacon {",
                        "    error BeaconProxyBeaconSlotAddress(address beacon);",
                        "    function implementation() external view override returns (address) {",
                        "        revert BeaconProxyBeaconSlotAddress(IProxyExposed(msg.sender).$getBeacon());",
                        "    }",
                        "}",
                        "     * @dev Initializes the upgradeable proxy with an initial implementation specified by `implementation`.",
                        "     * If `_data` is nonempty, it's used as data in a delegate call to `implementation`. This will typically be an encoded",
                        "    constructor(address implementation, bytes memory _data) payable {",
                        "        ERC1967Utils.upgradeToAndCall(implementation, _data);",
                        "    function _implementation() internal view virtual override returns (address) {",
                        "     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1.",
                        "     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.",
                        "     * This is the keccak-256 hash of \"eip1967.proxy.beacon\" subtracted by 1.",
                        "        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;",
                        "     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract",
                        "     * if an upgrade doesn't perform an initialization call.",
                        "     * {UpgradeableBeacon} will check that this address is a contract.",
                        "        emit Upgraded(newImplementation);",
                        "     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function",
                        " * NOTE: This proxy does not inherit from {Context} deliberately. The {ProxyAdmin} of this contract won't send a",
                        " * meta-transaction in any way, and any other meta-transaction setup should be made in the implementation contract.",
                        " *",
                        "        ERC1967Utils.changeAdmin(_proxyAdmin());",
                        "    }",
                        "    /**",
                        "     * @dev Returns the admin of this proxy.",
                        "     */",
                        "    function _proxyAdmin() internal virtual returns (address) {",
                        "        return _admin;",
                        "        if (msg.sender == _proxyAdmin()) {",
                        "            if (msg.sig != ITransparentUpgradeableProxy.upgradeToAndCall.selector) {",
                        "            } else {",
                        "                _dispatchUpgradeToAndCall();",
                        "     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function",
                        "     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.",
                        "     *",
                        "     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value",
                        "     * is expected to be the implementation slot in ERC1967.",
                        "     * If `target` reverts with a revert reason or custom error, it is bubbled",
                        "     * up by this function (like regular Solidity function calls). However, if",
                        "     * the call reverted with no returned reason, this function reverts with a",
                        "     * {FailedInnerCall} error.",
                        "        return functionCallWithValue(target, data, 0);",
                        "        return verifyCallResultFromTarget(target, success, returndata);",
                        "        return verifyCallResultFromTarget(target, success, returndata);",
                        "        return verifyCallResultFromTarget(target, success, returndata);",
                        "     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target",
                        "     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an",
                        "     * unsuccessful call.",
                        "        bytes memory returndata",
                        "        if (!success) {",
                        "            _revert(returndata);",
                        "        } else {",
                        "            if (returndata.length == 0 && target.code.length == 0) {",
                        "                revert AddressEmptyCode(target);",
                        "     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the",
                        "     * revert reason or with a default {FailedInnerCall} error.",
                        "    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {",
                        "        if (!success) {",
                        "            _revert(returndata);",
                        "            return returndata;",
                        "     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.",
                        "    function _revert(bytes memory returndata) private pure {",
                        "    bytes16 private constant _HEX_DIGITS = \"0123456789abcdef\";",
                        "                    mstore8(ptr, byte(mod(value, 10), _HEX_DIGITS))",
                        "            buffer[i] = _HEX_DIGITS[localValue & 0xf];",
                        "    CallReceiverMockTrustingForwarder internal _receiver;",
                        "        _receiver = new CallReceiverMockTrustingForwarder(address(_erc2771Forwarder));"
                    ],
                    "del": [
                        "        } else if (timestamp > end()) {",
                        "    constructor(address trustedForwarder) {",
                        "        _trustedForwarder = trustedForwarder;",
                        "        return forwarder == _trustedForwarder;",
                        "     * A transaction is considered valid when it hasn't expired (deadline is not met), and the signer",
                        "     * matches the `from` parameter of the signed request.",
                        "        (bool alive, bool signerMatch, ) = _validate(request);",
                        "        return alive && signerMatch;",
                        "    ) internal view virtual returns (bool alive, bool signerMatch, address signer) {",
                        "        signer = _recoverForwardRequestSigner(request);",
                        "        return (request.deadline >= block.timestamp, signer == request.from, signer);",
                        "     * @dev Recovers the signer of an EIP712 message hash for a forward `request` and its corresponding `signature`.",
                        "     * See {ECDSA-recover}.",
                        "    function _recoverForwardRequestSigner(ForwardRequestData calldata request) internal view virtual returns (address) {",
                        "        return",
                        "            _hashTypedDataV4(",
                        "                keccak256(",
                        "                    abi.encode(",
                        "                        _FORWARD_REQUEST_TYPEHASH,",
                        "                        request.from,",
                        "                        request.to,",
                        "                        request.value,",
                        "                        request.gas,",
                        "                        nonces(request.from),",
                        "                        request.deadline,",
                        "                        keccak256(request.data)",
                        "                    )",
                        "            ).recover(request.signature);",
                        "        (bool alive, bool signerMatch, address signer) = _validate(request);",
                        "            if (!alive) {",
                        "        if (signerMatch && alive) {",
                        "/**",
                        " * @dev A mock to expose `Address`'s functions with function pointers.",
                        " */",
                        "contract AddressFnPointerMock {",
                        "    error CustomRevert();",
                        "    function functionCall(address target, bytes memory data) external returns (bytes memory) {",
                        "        return Address.functionCall(target, data, _customRevert);",
                        "    }",
                        "    function functionCallWithValue(address target, bytes memory data, uint256 value) external returns (bytes memory) {",
                        "        return Address.functionCallWithValue(target, data, value, _customRevert);",
                        "    }",
                        "    function functionStaticCall(address target, bytes memory data) external view returns (bytes memory) {",
                        "        return Address.functionStaticCall(target, data, _customRevert);",
                        "    }",
                        "    function functionDelegateCall(address target, bytes memory data) external returns (bytes memory) {",
                        "        return Address.functionDelegateCall(target, data, _customRevert);",
                        "    }",
                        "    function verifyCallResultFromTarget(",
                        "        address target,",
                        "        bool success,",
                        "        bytes memory returndata",
                        "    ) external view returns (bytes memory) {",
                        "        return Address.verifyCallResultFromTarget(target, success, returndata, _customRevert);",
                        "    }",
                        "    function verifyCallResult(bool success, bytes memory returndata) external view returns (bytes memory) {",
                        "        return Address.verifyCallResult(success, returndata, _customRevert);",
                        "    }",
                        "    function verifyCallResultVoid(bool success, bytes memory returndata) external view returns (bytes memory) {",
                        "        return Address.verifyCallResult(success, returndata, _customRevertVoid);",
                        "    }",
                        "    function _customRevert() internal pure {",
                        "        revert CustomRevert();",
                        "    }",
                        "    function _customRevertVoid() internal pure {}",
                        "}",
                        "contract UpgradeableBeaconMock is IBeacon {",
                        "    address public implementation;",
                        "    constructor(address impl) {",
                        "        implementation = impl;",
                        "    }",
                        "}",
                        "     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.",
                        "     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded",
                        "    constructor(address _logic, bytes memory _data) payable {",
                        "        ERC1967Utils.upgradeToAndCall(_logic, _data);",
                        "    function _implementation() internal view virtual override returns (address impl) {",
                        "     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is",
                        "     * validated in the constructor.",
                        "     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is",
                        "     * validated in the constructor.",
                        "     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1) and is validated in the constructor.",
                        "        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;",
                        "     * @dev Reverts if `msg.value` is not zero.",
                        "        _beforeFallback();",
                        "    /**",
                        "     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`",
                        "     * call, or as part of the Solidity `fallback` or `receive` functions.",
                        "     *",
                        "     * If overridden should call `super._beforeFallback()`.",
                        "     */",
                        "    function _beforeFallback() internal virtual {}",
                        "     * {BeaconProxy} will check that this address is a contract.",
                        "        emit Upgraded(newImplementation);",
                        "     * be the empty byte string if no function should be called, being impossible to invoke the `receive` function",
                        "        ERC1967Utils.changeAdmin(_admin);",
                        "        if (msg.sender == _admin) {",
                        "            if (msg.sig == ITransparentUpgradeableProxy.upgradeToAndCall.selector) {",
                        "                _dispatchUpgradeToAndCall();",
                        "            } else {",
                        "     * be the empty byte string if no function should be called, being impossible to invoke the `receive` function",
                        "     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.",
                        "     * If `target` reverts with a revert reason, it is bubbled up by this",
                        "     * function (like regular Solidity function calls).",
                        "        return functionCallWithValue(target, data, 0, defaultRevert);",
                        "    }",
                        "    /**",
                        "     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with a",
                        "     * `customRevert` function as a fallback when `target` reverts.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `customRevert` must be a reverting function.",
                        "     */",
                        "    function functionCall(",
                        "        address target,",
                        "        bytes memory data,",
                        "        function() internal view customRevert",
                        "    ) internal returns (bytes memory) {",
                        "        return functionCallWithValue(target, data, 0, customRevert);",
                        "        return functionCallWithValue(target, data, value, defaultRevert);",
                        "    }",
                        "    /**",
                        "     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but",
                        "     * with a `customRevert` function as a fallback revert reason when `target` reverts.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `customRevert` must be a reverting function.",
                        "     */",
                        "    function functionCallWithValue(",
                        "        address target,",
                        "        bytes memory data,",
                        "        uint256 value,",
                        "        function() internal view customRevert",
                        "    ) internal returns (bytes memory) {",
                        "        return verifyCallResultFromTarget(target, success, returndata, customRevert);",
                        "        return functionStaticCall(target, data, defaultRevert);",
                        "    }",
                        "    /**",
                        "     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],",
                        "     * but performing a static call.",
                        "     */",
                        "    function functionStaticCall(",
                        "        address target,",
                        "        bytes memory data,",
                        "        function() internal view customRevert",
                        "    ) internal view returns (bytes memory) {",
                        "        return verifyCallResultFromTarget(target, success, returndata, customRevert);",
                        "        return functionDelegateCall(target, data, defaultRevert);",
                        "    }",
                        "    /**",
                        "     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],",
                        "     * but performing a delegate call.",
                        "     */",
                        "    function functionDelegateCall(",
                        "        address target,",
                        "        bytes memory data,",
                        "        function() internal view customRevert",
                        "    ) internal returns (bytes memory) {",
                        "        return verifyCallResultFromTarget(target, success, returndata, customRevert);",
                        "     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling",
                        "     * the revert reason or using the provided `customRevert`) in case of unsuccessful call or if target was not a contract.",
                        "        bytes memory returndata,",
                        "        function() internal view customRevert",
                        "        if (success) {",
                        "            if (returndata.length == 0) {",
                        "                if (target.code.length == 0) {",
                        "                    revert AddressEmptyCode(target);",
                        "                }",
                        "        } else {",
                        "            _revert(returndata, customRevert);",
                        "     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the",
                        "     * revert reason or with a default revert error.",
                        "    function verifyCallResult(bool success, bytes memory returndata) internal view returns (bytes memory) {",
                        "        return verifyCallResult(success, returndata, defaultRevert);",
                        "    }",
                        "    /**",
                        "     * @dev Same as {xref-Address-verifyCallResult-bool-bytes-}[`verifyCallResult`], but with a",
                        "     * `customRevert` function as a fallback when `success` is `false`.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `customRevert` must be a reverting function.",
                        "     */",
                        "    function verifyCallResult(",
                        "        bool success,",
                        "        bytes memory returndata,",
                        "        function() internal view customRevert",
                        "    ) internal view returns (bytes memory) {",
                        "        if (success) {",
                        "            return returndata;",
                        "            _revert(returndata, customRevert);",
                        "     * @dev Default reverting function when no `customRevert` is provided in a function call.",
                        "    function defaultRevert() internal pure {",
                        "        revert FailedInnerCall();",
                        "    }",
                        "    function _revert(bytes memory returndata, function() internal view customRevert) private view {",
                        "            customRevert();",
                        "    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";",
                        "                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))",
                        "            buffer[i] = _SYMBOLS[localValue & 0xf];",
                        "    CallReceiverMock internal _receiver;",
                        "        _receiver = new CallReceiverMock();"
                    ]
                }
            }
        ],
        "- `ECDSA`: Use unchecked arithmetic for the `tryRecover` function that receives the `r` and `vs` short-signature fields separately. ([#4301](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4301))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4301": {
                    "add": [
                        "        unchecked {",
                        "            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);",
                        "            uint8 v = uint8((uint256(vs) >> 255) + 27);",
                        "            return tryRecover(hash, v, r, s);",
                        "        }"
                    ],
                    "del": [
                        "        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);",
                        "        uint8 v = uint8((uint256(vs) >> 255) + 27);",
                        "        return tryRecover(hash, v, r, s);"
                    ]
                }
            }
        ],
        "- `EIP712`: Added internal getters for the name and version strings ([#4303](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4303))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4303": {
                    "add": [
                        "            _EIP712Name(),",
                        "            _EIP712Version(),",
                        "    /**",
                        "     * @dev The name parameter for the EIP712 domain.",
                        "     *",
                        "     * NOTE: By default this function reads _name which is an immutable value.",
                        "     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).",
                        "     *",
                        "     * _Available since v5.0._",
                        "     */",
                        "    function _EIP712Name() internal view returns (string memory) {",
                        "        return _name.toStringWithFallback(_nameFallback);",
                        "    }",
                        "    /**",
                        "     * @dev The version parameter for the EIP712 domain.",
                        "     *",
                        "     * NOTE: By default this function reads _version which is an immutable value.",
                        "     * It only reads from storage if necessary (in case the value is too large to fit in a ShortString).",
                        "     *",
                        "     * _Available since v5.0._",
                        "     */",
                        "    function _EIP712Version() internal view returns (string memory) {",
                        "        return _version.toStringWithFallback(_versionFallback);",
                        "    }"
                    ],
                    "del": [
                        "            _name.toStringWithFallback(_nameFallback),",
                        "            _version.toStringWithFallback(_versionFallback),"
                    ]
                }
            }
        ],
        "- `Math`: Makes `ceilDiv` to revert on 0 division even if the numerator is 0 ([#4348](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4348))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4348": {
                    "add": [
                        "abstract contract ERC4626LimitsMock is ERC4626 {",
                        "    uint256 _maxDeposit;",
                        "    uint256 _maxMint;",
                        "    constructor() {",
                        "        _maxDeposit = 100 ether;",
                        "        _maxMint = 100 ether;",
                        "    }",
                        "    function maxDeposit(address) public view override returns (uint256) {",
                        "        return _maxDeposit;",
                        "    }",
                        "    function maxMint(address) public view override returns (uint256) {",
                        "        return _maxMint;",
                        "    }",
                        "}",
                        "        if (b == 0) {",
                        "            return a / b;",
                        "        }"
                    ],
                    "del": []
                }
            }
        ],
        "- `Math`: Optimized stack operations in `mulDiv`. ([#4494](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4494))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4494": {
                    "add": [
                        "            uint256 twos = denominator & (0 - denominator);"
                    ],
                    "del": [
                        "                prod0 := mul(x, y)",
                        "            uint256 twos = denominator & (~denominator + 1);"
                    ]
                }
            }
        ],
        "- `MerkleProof`: Use custom error to report invalid multiproof instead of reverting with overflow panic. ([#4564](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4564))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4564": {
                    "add": [
                        "        if (leavesLen + proofLen != totalHashes + 1) {",
                        "        if (leavesLen + proofLen != totalHashes + 1) {"
                    ],
                    "del": [
                        "        if (leavesLen + proofLen - 1 != totalHashes) {",
                        "        if (leavesLen + proofLen - 1 != totalHashes) {"
                    ]
                }
            }
        ],
        "- `Nonces`: Added a new contract to keep track of user nonces. Used for signatures in `ERC20Permit`, `ERC20Votes`, and `ERC721Votes`. ([#3816](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3816))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3816": {
                    "add": [
                        "abstract contract Votes is IVotes, Context, EIP712, Nonces {",
                        "     * @dev Get number of checkpoints for `account`.",
                        "    function _numCheckpoints(address account) internal view virtual returns (uint32) {",
                        "        return SafeCast.toUint32(_delegateCheckpoints[account].length());",
                        "     * @dev Get the `pos`-th checkpoint for `account`.",
                        "    function _checkpoints(address account, uint32 pos) internal view virtual returns (Checkpoints.Checkpoint memory) {",
                        "        return _delegateCheckpoints[account].getAtPosition(pos);",
                        "    }",
                        "    function _add(uint256 a, uint256 b) private pure returns (uint256) {",
                        "        return a + b;",
                        "    }",
                        "    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {",
                        "        return a - b;",
                        "    constructor(string memory name, string memory symbol) ERC20(name, symbol) EIP712(name, \"1\") {}",
                        "    constructor(string memory name, string memory symbol) ERC20(name, symbol) EIP712(name, \"1\") {}",
                        "    function burn(address, uint256 tokenId) public {",
                        "contract NoncesImpl is Nonces {",
                        "    function useNonce(address owner) public {",
                        "        super._useNonce(owner);",
                        "    }",
                        "}",
                        "    function burn(address, uint256 voteId) external {",
                        "abstract contract ERC20Permit is ERC20, IERC20Permit, EIP712, Nonces {",
                        "    function nonces(address owner) public view virtual override(IERC20Permit, Nonces) returns (uint256) {",
                        "        return super.nonces(owner);",
                        "abstract contract ERC20Votes is ERC20, Votes {",
                        "        _transferVotingUnits(from, to, amount);",
                        "     * @dev Get number of checkpoints for `account`.",
                        "    function numCheckpoints(address account) public view virtual returns (uint32) {",
                        "        return _numCheckpoints(account);",
                        "    /**",
                        "     * @dev Get the `pos`-th checkpoint for `account`.",
                        "     */",
                        "    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoints.Checkpoint memory) {",
                        "        return _checkpoints(account, pos);",
                        "    /**",
                        "     * @dev Returns the balance of `account`.",
                        "     */",
                        "    function _getVotingUnits(address account) internal view virtual override returns (uint256) {",
                        "        return balanceOf(account);",
                        "    /**",
                        "     * @dev Snapshots the totalSupply after it has been increased.",
                        "     */",
                        "    function _mint(address account, uint256 amount) internal virtual override {",
                        "        super._mint(account, amount);",
                        "        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");",
                        "    /**",
                        "     * @dev Returns checkpoint at given position.",
                        "     */",
                        "    function getAtPosition(History storage self, uint32 pos) internal view returns (Checkpoint memory) {",
                        "        return self._checkpoints[pos];",
                        "    }",
                        "/**",
                        " * @dev Provides tracking nonces for addresses. Nonces will only increment.",
                        " */",
                        "abstract contract Nonces {",
                        "    using Counters for Counters.Counter;",
                        "    mapping(address => Counters.Counter) private _nonces;",
                        "    /**",
                        "     * @dev Returns an address nonce.",
                        "     */",
                        "    function nonces(address owner) public view virtual returns (uint256) {",
                        "        return _nonces[owner].current();",
                        "    }",
                        "    /**",
                        "     * @dev Consumes a nonce.",
                        "     *",
                        "     * Returns the current value and increments nonce.",
                        "     */",
                        "    function _useNonce(address owner) internal virtual returns (uint256 current) {",
                        "        Counters.Counter storage nonce = _nonces[owner];",
                        "        current = nonce.current();",
                        "        nonce.increment();",
                        "    }",
                        "}"
                    ],
                    "del": [
                        "abstract contract Votes is IVotes, Context, EIP712 {",
                        "    using Counters for Counters.Counter;",
                        "    mapping(address => Counters.Counter) private _nonces;",
                        "    function _add(uint256 a, uint256 b) private pure returns (uint256) {",
                        "        return a + b;",
                        "    }",
                        "    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {",
                        "        return a - b;",
                        "    }",
                        "     * @dev Consumes a nonce.",
                        "     *",
                        "     * Returns the current value and increments nonce.",
                        "    function _useNonce(address owner) internal virtual returns (uint256 current) {",
                        "        Counters.Counter storage nonce = _nonces[owner];",
                        "        current = nonce.current();",
                        "        nonce.increment();",
                        "     * @dev Returns an address nonce.",
                        "    function nonces(address owner) public view virtual returns (uint256) {",
                        "        return _nonces[owner].current();",
                        "    constructor(string memory name, string memory symbol) ERC20(name, symbol) ERC20Permit(name) {}",
                        "    constructor(string memory name, string memory symbol) ERC20(name, symbol) ERC20Permit(name) {}",
                        "    function burn(uint256 tokenId) public {",
                        "    function burn(uint256 voteId) external {",
                        "abstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {",
                        "    using Counters for Counters.Counter;",
                        "    mapping(address => Counters.Counter) private _nonces;",
                        "    function nonces(address owner) public view virtual override returns (uint256) {",
                        "        return _nonces[owner].current();",
                        "    /**",
                        "     * @dev \"Consume a nonce\": return the current value and increment.",
                        "     *",
                        "     * _Available since v4.1._",
                        "     */",
                        "    function _useNonce(address owner) internal virtual returns (uint256 current) {",
                        "        Counters.Counter storage nonce = _nonces[owner];",
                        "        current = nonce.current();",
                        "        nonce.increment();",
                        "    }",
                        "abstract contract ERC20Votes is IVotes, ERC20Permit {",
                        "    struct Checkpoint {",
                        "        uint32 fromBlock;",
                        "        uint224 votes;",
                        "    }",
                        "    bytes32 private constant _DELEGATION_TYPEHASH =",
                        "        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");",
                        "    mapping(address => address) private _delegates;",
                        "    mapping(address => Checkpoint[]) private _checkpoints;",
                        "    Checkpoint[] private _totalSupplyCheckpoints;",
                        "    /**",
                        "     * @dev Get the `pos`-th checkpoint for `account`.",
                        "     */",
                        "    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {",
                        "        return _checkpoints[account][pos];",
                        "    }",
                        "    /**",
                        "     * @dev Get number of checkpoints for `account`.",
                        "     */",
                        "    function numCheckpoints(address account) public view virtual returns (uint32) {",
                        "        return SafeCast.toUint32(_checkpoints[account].length);",
                        "    }",
                        "    /**",
                        "     * @dev Get the address `account` is currently delegating to.",
                        "     */",
                        "    function delegates(address account) public view virtual override returns (address) {",
                        "        return _delegates[account];",
                        "    }",
                        "    /**",
                        "     * @dev Gets the current votes balance for `account`",
                        "     */",
                        "    function getVotes(address account) public view virtual override returns (uint256) {",
                        "        uint256 pos = _checkpoints[account].length;",
                        "        unchecked {",
                        "            return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `blockNumber` must have been already mined",
                        "     */",
                        "    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");",
                        "        return _checkpointsLookup(_checkpoints[account], blockNumber);",
                        "    }",
                        "    /**",
                        "     * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.",
                        "     * It is NOT the sum of all the delegated votes!",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `blockNumber` must have been already mined",
                        "     */",
                        "    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");",
                        "        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);",
                        "    }",
                        "    /**",
                        "     * @dev Lookup a value in a list of (sorted) checkpoints.",
                        "     */",
                        "    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {",
                        "        //",
                        "        uint256 length = ckpts.length;",
                        "        uint256 low = 0;",
                        "        uint256 high = length;",
                        "        if (length > 5) {",
                        "            uint256 mid = length - Math.sqrt(length);",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > blockNumber) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }",
                        "        }",
                        "        while (low < high) {",
                        "            uint256 mid = Math.average(low, high);",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > blockNumber) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }",
                        "        }",
                        "        unchecked {",
                        "            return high == 0 ? 0 : _unsafeAccess(ckpts, high - 1).votes;",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Delegate votes from the sender to `delegatee`.",
                        "     */",
                        "    function delegate(address delegatee) public virtual override {",
                        "        _delegate(_msgSender(), delegatee);",
                        "    }",
                        "    /**",
                        "     * @dev Delegates votes from signer to `delegatee`",
                        "     */",
                        "    function delegateBySig(",
                        "        address delegatee,",
                        "        uint256 nonce,",
                        "        uint256 expiry,",
                        "        uint8 v,",
                        "        bytes32 r,",
                        "        bytes32 s",
                        "    ) public virtual override {",
                        "        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");",
                        "        address signer = ECDSA.recover(",
                        "            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),",
                        "            v,",
                        "            r,",
                        "            s",
                        "        );",
                        "        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");",
                        "        _delegate(signer, delegatee);",
                        "    }",
                        "    /**",
                        "     * @dev Snapshots the totalSupply after it has been increased.",
                        "     */",
                        "    function _mint(address account, uint256 amount) internal virtual override {",
                        "        super._mint(account, amount);",
                        "        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");",
                        "        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);",
                        "    }",
                        "    /**",
                        "     * @dev Snapshots the totalSupply after it has been decreased.",
                        "     */",
                        "    function _burn(address account, uint256 amount) internal virtual override {",
                        "        super._burn(account, amount);",
                        "        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);",
                        "    }",
                        "        _moveVotingPower(delegates(from), delegates(to), amount);",
                        "     * @dev Change delegation for `delegator` to `delegatee`.",
                        "     *",
                        "     * Emits events {IVotes-DelegateChanged} and {IVotes-DelegateVotesChanged}.",
                        "    function _delegate(address delegator, address delegatee) internal virtual {",
                        "        address currentDelegate = delegates(delegator);",
                        "        uint256 delegatorBalance = balanceOf(delegator);",
                        "        _delegates[delegator] = delegatee;",
                        "        emit DelegateChanged(delegator, currentDelegate, delegatee);",
                        "        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);",
                        "    }",
                        "    function _moveVotingPower(",
                        "        address src,",
                        "        address dst,",
                        "        uint256 amount",
                        "    ) private {",
                        "        if (src != dst && amount > 0) {",
                        "            if (src != address(0)) {",
                        "                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);",
                        "                emit DelegateVotesChanged(src, oldWeight, newWeight);",
                        "            }",
                        "            if (dst != address(0)) {",
                        "                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);",
                        "                emit DelegateVotesChanged(dst, oldWeight, newWeight);",
                        "            }",
                        "        }",
                        "    }",
                        "    function _writeCheckpoint(",
                        "        Checkpoint[] storage ckpts,",
                        "        function(uint256, uint256) view returns (uint256) op,",
                        "        uint256 delta",
                        "    ) private returns (uint256 oldWeight, uint256 newWeight) {",
                        "        uint256 pos = ckpts.length;",
                        "        unchecked {",
                        "            Checkpoint memory oldCkpt = pos == 0 ? Checkpoint(0, 0) : _unsafeAccess(ckpts, pos - 1);",
                        "            oldWeight = oldCkpt.votes;",
                        "            newWeight = op(oldWeight, delta);",
                        "            if (pos > 0 && oldCkpt.fromBlock == block.number) {",
                        "                _unsafeAccess(ckpts, pos - 1).votes = SafeCast.toUint224(newWeight);",
                        "            } else {",
                        "                ckpts.push(",
                        "                    Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)})",
                        "                );",
                        "            }",
                        "        }",
                        "    function _add(uint256 a, uint256 b) private pure returns (uint256) {",
                        "        return a + b;",
                        "    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {",
                        "        return a - b;",
                        "    function _unsafeAccess(Checkpoint[] storage ckpts, uint256 pos) private pure returns (Checkpoint storage result) {",
                        "        assembly {",
                        "            mstore(0, ckpts.slot)",
                        "            result.slot := add(keccak256(0, 0x20), pos)",
                        "        }"
                    ]
                }
            }
        ],
        "- `ReentrancyGuard`, `Pausable`: Moved to `utils` directory. ([#4551](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4551))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4551": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Optimized `Strings.equal` ([#4262](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4262))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4262": {
                    "add": [
                        "        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));"
                    ],
                    "del": [
                        "        return keccak256(bytes(a)) == keccak256(bytes(b));"
                    ]
                }
            }
        ],
        "These breaking changes will require modifications to ERC20, ERC721, and ERC1155 contracts, since the `_afterTokenTransfer` and `_beforeTokenTransfer` functions were removed. Thus, any customization made through those hooks should now be done overriding the new `_update` function instead.\r": [],
        "Minting and burning are implemented by `_update` and customizations should be done by overriding this function as well. `_transfer`, `_mint` and `_burn` are no longer virtual (meaning they are not overridable) to guard against possible inconsistencies.\r": [],
        "For example, a contract using `ERC20`'s `_beforeTokenTransfer` hook would have to be changed in the following way.\r": [],
        "   require(!condition(), \"ERC20: wrong condition\");\r": [],
        "In the case of `ERC721`, the `_update` function does not include a `from` parameter, as the sender is implicitly the previous owner of the `tokenId`. The address of this previous owner is returned by the `_update` function, so it can be used for a posteriori checks. In addition to `to` and `tokenId`, a third parameter (`auth`) is present in this function. This parameter enabled an optional check that the caller/spender is approved to do the transfer. This check cannot be performed after the transfer (because the transfer resets the approval), and doing it before `_update` would require a duplicate call to `_ownerOf`.\r": [],
        "In this logic of removing hidden SLOADs, the `_isApprovedOrOwner` function was removed in favor of a new `_isAuthorized` function. Overrides that used to target the `_isApprovedOrOwner` should now be performed on the `_isAuthorized` function. Calls to `_isApprovedOrOwner` that preceded a call to `_transfer`, `_burn` or `_approve` should be removed in favor of using the `auth` argument in `_update` and `_approve`. This is showcased in `ERC721Burnable.burn` and in `ERC721Wrapper.withdrawTo`.\r": [],
        "The `_exists` function was removed. Calls to this function can be replaced by `_ownerOf(tokenId) != address(0)`.\r": [],
        "Users that were registering EIP-165 interfaces with `_registerInterface` from `ERC165Storage` should instead do so so by overriding the `supportsInterface` function as seen below:\r": [],
        "  return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\r": [],
        "#### SafeMath\r": [],
        "Methods in SafeMath superseded by native overflow checks in Solidity 0.8.0 were removed along with operations providing an interface for revert strings. The remaining methods were moved to `utils/Math.sol`.\r": [],
        "-  (bool overflowsAdd, uint256 resultAdd) = SafeMath.tryAdd(x, y);\r": [],
        "-  (bool overflowsSub, uint256 resultSub) = SafeMath.trySub(x, y);\r": [],
        "-  (bool overflowsDiv, uint256 resultDiv) = SafeMath.tryDiv(x, y);\r": [],
        "Custom Governor modules that override internal functions may require modifications if migrated to v5. In particular, the new internal functions `_queueOperations` and `_executeOperations` may need to be used. If assistance with this migration is needed reach out via the [OpenZeppelin Support Forum](https://forum.openzeppelin.com/c/support/contracts/18).\r": [],
        "#### Interfaces and libraries in upgradeable contracts\r": [],
        "The upgradeable version of the contracts library used to include a variant suffixed with `Upgradeable` for every contract. These variants, which are produced automatically, mainly include changes for dealing with storage that don't apply to libraries and interfaces.\r": [],
        "The upgradeable library no longer includes upgradeable variants for libraries and interfaces. Projects migrating to 5.0 should replace their library and interface imports with their corresponding non-upgradeable version:\r": [],
        "##### Relying on revert strings for processing errors\r": [],
        "A concrete example is AccessControl, where it was previously advised to catch revert reasons using the following regex:\r": [],
        "/^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\r": [],
        "Instead, contracts now revert with custom errors. Systems that interact with smart contracts outside of the network should consider reliance on revert strings and possibly support the new custom errors.\r": [],
        "##### Relying on storage locations for retrieving data\r": [],
        "After 5.0, the storage location of some variables were changed. This is the case for `Initializable` and all the upgradeable contracts since they now use namespaced storaged locations. Any system relying on storage locations for retrieving data or detecting capabilities should be updated to support these new locations.": []
    },
    "5.0.0-rc.2": {},
    "5.0.0-rc.1": {
        "- Upgradeable Contracts: No longer transpile interfaces, libraries, and stateless contracts. ([#4636](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4636))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4636": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- `AccessManager`, `AccessManaged`, `GovernorTimelockAccess`: Ensure that calldata shorter than 4 bytes is not padded to 4 bytes. ([#4624](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4624))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4624": {
                    "add": [
                        "     * [WARNING]",
                        "     * Avoid adding this modifier to the https://docs.soliditylang.org/en/v0.8.20/contracts.html#receive-ether-function[`receive()`]",
                        "     * function or the https://docs.soliditylang.org/en/v0.8.20/contracts.html#fallback-function[`fallback()`]. These",
                        "     * functions are the only execution paths where a function selector cannot be unambiguosly determined from the calldata",
                        "     * since the selector defaults to `0x00000000` in the `receive()` function and similarly in the `fallback()` function",
                        "     * if no calldata is provided. (See {_checkCanCall}).",
                        "     * The `receive()` function will always panic whereas the `fallback()` may panic depending on the calldata length.",
                        "     * @dev Reverts if the caller is not allowed to call the function identified by a selector. Panics if the calldata",
                        "     * is less than 4 bytes long.",
                        "            bytes4(data[0:4])",
                        "    function canCall(",
                        "        address caller,",
                        "        address target,",
                        "        bytes4 selector",
                        "    ) public view virtual returns (bool immediate, uint32 delay) {",
                        "    function getAccess(",
                        "        uint64 roleId,",
                        "        address account",
                        "    ) public view virtual returns (uint48 since, uint32 currentDelay, uint32 pendingDelay, uint48 effect) {",
                        "        since = access.since;",
                        "        (currentDelay, pendingDelay, effect) = access.delay.getFull();",
                        "    function hasRole(",
                        "        uint64 roleId,",
                        "        address account",
                        "    ) public view virtual returns (bool isMember, uint32 executionDelay) {",
                        "            revert AccessManagerUnauthorizedCall(caller, target, _checkSelector(data));",
                        "            revert AccessManagerUnauthorizedCall(caller, target, _checkSelector(data));",
                        "        _executionId = _hashExecutionId(target, _checkSelector(data));",
                        "        bytes4 selector = _checkSelector(data);",
                        "    function _getAdminRestrictions(",
                        "        bytes calldata data",
                        "    ) private view returns (bool restricted, uint64 roleAdminId, uint32 executionDelay) {",
                        "        bytes4 selector = _checkSelector(data);",
                        "            return (true, getRoleAdmin(roleId), 0);",
                        "    function _canCallExtended(",
                        "        address caller,",
                        "        address target,",
                        "        bytes calldata data",
                        "    ) private view returns (bool immediate, uint32 delay) {",
                        "            return data.length < 4 ? (false, 0) : canCall(caller, target, _checkSelector(data));",
                        "        if (data.length < 4) {",
                        "            return (false, 0);",
                        "        }",
                        "            return (_isExecuting(address(this), _checkSelector(data)), 0);",
                        "    /**",
                        "     * @dev Extracts the selector from calldata. Panics if data is not at least 4 bytes",
                        "     */",
                        "    function _checkSelector(bytes calldata data) private pure returns (bytes4) {",
                        "        return bytes4(data[0:4]);",
                        "    }",
                        "            if (calldatas[i].length < 4) {",
                        "                continue;",
                        "            }",
                        "    event CalledFallback(address caller);",
                        "    fallback() external {",
                        "        emit CalledFallback(msg.sender);",
                        "    }"
                    ],
                    "del": [
                        "     * [NOTE]",
                        "     * Selector collisions are mitigated by scoping permissions per contract, but some edge cases must be considered:",
                        "     * * If the https://docs.soliditylang.org/en/v0.8.20/contracts.html#receive-ether-function[`receive()`] function",
                        "     * is restricted, any other function with a `0x00000000` selector will share permissions with `receive()`.",
                        "     * * Similarly, if there's no `receive()` function but a `fallback()` instead, the fallback might be called with",
                        "     * empty `calldata`, sharing the `0x00000000` selector permissions as well.",
                        "     * * For any other selector, if the restricted function is set on an upgradeable contract, an upgrade may remove",
                        "     * the restricted function and replace it with a new method whose selector replaces the last one, keeping the",
                        "     * previous permissions.",
                        "     * @dev Reverts if the caller is not allowed to call the function identified by a selector.",
                        "            bytes4(data)",
                        "    function canCall(address caller, address target, bytes4 selector) public view virtual returns (bool, uint32) {",
                        "    function getAccess(uint64 roleId, address account) public view virtual returns (uint48, uint32, uint32, uint48) {",
                        "        uint48 since = access.since;",
                        "        (uint32 currentDelay, uint32 pendingDelay, uint48 effect) = access.delay.getFull();",
                        "    function hasRole(uint64 roleId, address account) public view virtual returns (bool, uint32) {",
                        "            revert AccessManagerUnauthorizedCall(caller, target, bytes4(data[0:4]));",
                        "            revert AccessManagerUnauthorizedCall(caller, target, bytes4(data));",
                        "        _executionId = _hashExecutionId(target, bytes4(data));",
                        "        bytes4 selector = bytes4(data[0:4]);",
                        "    function _getAdminRestrictions(bytes calldata data) private view returns (bool, uint64, uint32) {",
                        "        bytes4 selector = bytes4(data);",
                        "            uint64 roleAdminId = getRoleAdmin(roleId);",
                        "            return (true, roleAdminId, 0);",
                        "    function _canCallExtended(address caller, address target, bytes calldata data) private view returns (bool, uint32) {",
                        "            bytes4 selector = bytes4(data);",
                        "            return canCall(caller, target, selector);",
                        "            return (_isExecuting(address(this), bytes4(data)), 0);"
                    ]
                }
            }
        ]
    },
    "5.0.0-rc.0": {
        "- `ERC1155Receiver`: Removed in favor of `ERC1155Holder`. ([#4450](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4450))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4450": {
                    "add": [
                        "    ) public view virtual override(AccessControl, ERC1155Holder) returns (bool) {",
                        " * @dev Simple implementation of `IERC1155Receiver` that will allow a contract to hold ERC1155 tokens.",
                        "abstract contract ERC1155Holder is ERC165, IERC1155Receiver {",
                        "    /**",
                        "     * @dev See {IERC165-supportsInterface}.",
                        "     */",
                        "    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {",
                        "        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);",
                        "    }"
                    ],
                    "del": [
                        "    ) public view virtual override(AccessControl, ERC1155Receiver) returns (bool) {",
                        " * @dev Simple implementation of `ERC1155Receiver` that will allow a contract to hold ERC1155 tokens.",
                        "abstract contract ERC1155Holder is ERC1155Receiver {",
                        "/**",
                        " * @dev Basic contract implementing the ERC-165 interface for {IERC1155Receiver}.",
                        " *",
                        " * NOTE: This contract does not suffice to receive tokens. See {ERC1155Holder}.",
                        " */",
                        "abstract contract ERC1155Receiver is ERC165, IERC1155Receiver {",
                        "    /**",
                        "     * @dev See {IERC165-supportsInterface}.",
                        "     */",
                        "    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {",
                        "        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);",
                        "    }",
                        "}"
                    ]
                }
            }
        ],
        "- `TimelockController`: Changed the role architecture to use `DEFAULT_ADMIN_ROLE` as the admin for all roles, instead of the bespoke `TIMELOCK_ADMIN_ROLE` that was used previously. This aligns with the general recommendation for `AccessControl` and makes the addition of new roles easier. Accordingly, the `admin` parameter and timelock will now be granted `DEFAULT_ADMIN_ROLE` instead of `TIMELOCK_ADMIN_ROLE`. ([#3799](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3799))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3799": {
                    "add": [
                        "        _grantRole(DEFAULT_ADMIN_ROLE, address(this));",
                        "            _grantRole(DEFAULT_ADMIN_ROLE, admin);"
                    ],
                    "del": [
                        "    bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(\"TIMELOCK_ADMIN_ROLE\");",
                        "        _setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);",
                        "        _setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);",
                        "        _setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);",
                        "        _setRoleAdmin(CANCELLER_ROLE, TIMELOCK_ADMIN_ROLE);",
                        "        _setupRole(TIMELOCK_ADMIN_ROLE, address(this));",
                        "            _setupRole(TIMELOCK_ADMIN_ROLE, admin);"
                    ]
                }
            }
        ],
        "- Use `abi.encodeCall` in place of `abi.encodeWithSelector` and `abi.encodeWithSignature` for improved type-checking of parameters ([#4293](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4293))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4293": {
                    "add": [
                        "            calls[i] = abi.encodeCall(multicallToken.transfer, (recipients[i], amounts[i]));",
                        "            (bool success, ) = address(this).call(abi.encodeCall(this.countThisRecursive, (n - 1)));",
                        "            Address.functionDelegateCall(newImplementation, abi.encodeCall(this.upgradeTo, (oldImplementation)));",
                        "            abi.encodeCall(IERC20Metadata.decimals, ())",
                        "        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));",
                        "        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));",
                        "        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));",
                        "            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));",
                        "            abi.encodeCall(IERC1271.isValidSignature, (hash, signature))",
                        "        bytes memory encodedParams = abi.encodeCall(IERC165.supportsInterface, (interfaceId));"
                    ],
                    "del": [
                        "            calls[i] = abi.encodeWithSignature(\"transfer(address,uint256)\", recipients[i], amounts[i]);",
                        "            (bool success, ) = address(this).call(abi.encodeWithSignature(\"countThisRecursive(uint256)\", n - 1));",
                        "            Address.functionDelegateCall(",
                        "                newImplementation,",
                        "                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)",
                        "            );",
                        "            abi.encodeWithSelector(IERC20Metadata.decimals.selector)",
                        "        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));",
                        "        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));",
                        "        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);",
                        "            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));",
                        "            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)",
                        "        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);"
                    ]
                }
            }
        ],
        "- `ERC2771Forwarder`: Added `deadline` for expiring transactions, batching, and more secure handling of `msg.value`. ([#4346](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4346))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4346": {
                    "add": [
                        "/**",
                        " * @dev A forwarder compatible with ERC2771 contracts. See {ERC2771Context}.",
                        " *",
                        " * This forwarder operates on forward requests that include:",
                        " *",
                        " * * `from`: An address to operate on behalf of. It is required to be equal to the request signer.",
                        " * * `to`: The address that should be called.",
                        " * * `value`: The amount of native token to attach with the requested call.",
                        " * * `gas`: The amount of gas limit that will be forwarded with the requested call.",
                        " * * `nonce`: A unique transaction ordering identifier to avoid replayability and request invalidation.",
                        " * * `deadline`: A timestamp after which the request is not executable anymore.",
                        " * * `data`: Encoded `msg.data` to send with the requested call.",
                        " */",
                        "contract ERC2771Forwarder is EIP712, Nonces {",
                        "    using ECDSA for bytes32;",
                        "    struct ForwardRequestData {",
                        "        address from;",
                        "        address to;",
                        "        uint256 value;",
                        "        uint256 gas;",
                        "        uint48 deadline;",
                        "        bytes data;",
                        "        bytes signature;",
                        "    }",
                        "    bytes32 private constant _FORWARD_REQUEST_TYPEHASH =",
                        "        keccak256(",
                        "            \"ForwardRequest(address from,address to,uint256 value,uint256 gas,uint256 nonce,uint48 deadline,bytes data)\"",
                        "        );",
                        "    /**",
                        "     * @dev Emitted when a `ForwardRequest` is executed.",
                        "     *",
                        "     * NOTE: An unsuccessful forward request could be due to an invalid signature, an expired deadline,",
                        "     * or simply a revert in the requested call. The contract guarantees that the relayer is not able to force",
                        "     * the requested call to run out of gas.",
                        "     */",
                        "    event ExecutedForwardRequest(address indexed signer, uint256 nonce, bool success);",
                        "    /**",
                        "     * @dev The request `from` doesn't match with the recovered `signer`.",
                        "     */",
                        "    error ERC2771ForwarderInvalidSigner(address signer, address from);",
                        "    /**",
                        "     * @dev The `requestedValue` doesn't match with the available `msgValue`.",
                        "     */",
                        "    error ERC2771ForwarderMismatchedValue(uint256 requestedValue, uint256 msgValue);",
                        "    /**",
                        "     * @dev The request `deadline` has expired.",
                        "     */",
                        "    error ERC2771ForwarderExpiredRequest(uint48 deadline);",
                        "    /**",
                        "     * @dev See {EIP712-constructor}.",
                        "     */",
                        "    constructor(string memory name) EIP712(name, \"1\") {}",
                        "    /**",
                        "     * @dev Returns `true` if a request is valid for a provided `signature` at the current block timestamp.",
                        "     *",
                        "     * A transaction is considered valid when it hasn't expired (deadline is not met), and the signer",
                        "     * matches the `from` parameter of the signed request.",
                        "     *",
                        "     * NOTE: A request may return false here but it won't cause {executeBatch} to revert if a refund",
                        "     * receiver is provided.",
                        "     */",
                        "    function verify(ForwardRequestData calldata request) public view virtual returns (bool) {",
                        "        (bool alive, bool signerMatch, ) = _validate(request);",
                        "        return alive && signerMatch;",
                        "    }",
                        "    /**",
                        "     * @dev Executes a `request` on behalf of `signature`'s signer using the ERC-2771 protocol. The gas",
                        "     * provided to the requested call may not be exactly the amount requested, but the call will not run",
                        "     * out of gas. Will revert if the request is invalid or the call reverts, in this case the nonce is not consumed.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - The request value should be equal to the provided `msg.value`.",
                        "     * - The request should be valid according to {verify}.",
                        "     */",
                        "    function execute(ForwardRequestData calldata request) public payable virtual {",
                        "        if (msg.value != request.value) {",
                        "            revert ERC2771ForwarderMismatchedValue(request.value, msg.value);",
                        "        }",
                        "        if (!_execute(request, true)) {",
                        "            revert Address.FailedInnerCall();",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Batch version of {execute} with optional refunding and atomic execution.",
                        "     *",
                        "     * In case a batch contains at least one invalid request (see {verify}), the",
                        "     * request will be skipped and the `refundReceiver` parameter will receive back the",
                        "     * unused requested value at the end of the execution. This is done to prevent reverting",
                        "     * the entire batch when a request is invalid or has already been submitted.",
                        "     *",
                        "     * If the `refundReceiver` is the `address(0)`, this function will revert when at least",
                        "     * one of the requests was not valid instead of skipping it. This could be useful if",
                        "     * a batch is required to get executed atomically (at least at the top-level). For example,",
                        "     * refunding (and thus atomicity) can be opt-out if the relayer is using a service that avoids",
                        "     * including reverted transactions.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - The sum of the requests' values should be equal to the provided `msg.value`.",
                        "     * - All of the requests should be valid (see {verify}) when `refundReceiver` is the zero address.",
                        "     *",
                        "     * NOTE: Setting a zero `refundReceiver` guarantees an all-or-nothing requests execution only for",
                        "     * the first-level forwarded calls. In case a forwarded request calls to a contract with another",
                        "     * subcall, the second-level call may revert without the top-level call reverting.",
                        "     */",
                        "    function executeBatch(",
                        "        ForwardRequestData[] calldata requests,",
                        "        address payable refundReceiver",
                        "    ) public payable virtual {",
                        "        bool atomic = refundReceiver == address(0);",
                        "        uint256 requestsValue;",
                        "        uint256 refundValue;",
                        "        for (uint256 i; i < requests.length; ++i) {",
                        "            requestsValue += requests[i].value;",
                        "            bool success = _execute(requests[i], atomic);",
                        "            if (!success) {",
                        "                refundValue += requests[i].value;",
                        "            }",
                        "        }",
                        "        if (requestsValue != msg.value) {",
                        "            revert ERC2771ForwarderMismatchedValue(requestsValue, msg.value);",
                        "        }",
                        "        if (refundValue != 0) {",
                        "            Address.sendValue(refundReceiver, refundValue);",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Validates if the provided request can be executed at current block timestamp with",
                        "     * the given `request.signature` on behalf of `request.signer`.",
                        "     */",
                        "    function _validate(",
                        "        ForwardRequestData calldata request",
                        "    ) internal view virtual returns (bool alive, bool signerMatch, address signer) {",
                        "        signer = _recoverForwardRequestSigner(request);",
                        "        return (request.deadline >= block.timestamp, signer == request.from, signer);",
                        "    }",
                        "    /**",
                        "     * @dev Recovers the signer of an EIP712 message hash for a forward `request` and its corresponding `signature`.",
                        "     * See {ECDSA-recover}.",
                        "     */",
                        "    function _recoverForwardRequestSigner(ForwardRequestData calldata request) internal view virtual returns (address) {",
                        "        return",
                        "            _hashTypedDataV4(",
                        "                keccak256(",
                        "                    abi.encode(",
                        "                        _FORWARD_REQUEST_TYPEHASH,",
                        "                        request.from,",
                        "                        request.to,",
                        "                        request.value,",
                        "                        request.gas,",
                        "                        nonces(request.from),",
                        "                        request.deadline,",
                        "                        keccak256(request.data)",
                        "                    )",
                        "                )",
                        "            ).recover(request.signature);",
                        "    }",
                        "    /**",
                        "     * @dev Validates and executes a signed request returning the request call `success` value.",
                        "     *",
                        "     * Internal function without msg.value validation.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - The caller must have provided enough gas to forward with the call.",
                        "     * - The request must be valid (see {verify}) if the `requireValidRequest` is true.",
                        "     *",
                        "     * Emits an {ExecutedForwardRequest} event.",
                        "     *",
                        "     * IMPORTANT: Using this function doesn't check that all the `msg.value` was sent, potentially",
                        "     * leaving value stuck in the contract.",
                        "     */",
                        "    function _execute(",
                        "        ForwardRequestData calldata request,",
                        "        bool requireValidRequest",
                        "    ) internal virtual returns (bool success) {",
                        "        (bool alive, bool signerMatch, address signer) = _validate(request);",
                        "        if (requireValidRequest) {",
                        "            if (!alive) {",
                        "                revert ERC2771ForwarderExpiredRequest(request.deadline);",
                        "            }",
                        "            if (!signerMatch) {",
                        "                revert ERC2771ForwarderInvalidSigner(signer, request.from);",
                        "            }",
                        "        }",
                        "        if (signerMatch && alive) {",
                        "            uint256 currentNonce = _useNonce(signer);",
                        "            (success, ) = request.to.call{gas: request.gas, value: request.value}(",
                        "                abi.encodePacked(request.data, request.from)",
                        "            );",
                        "            _checkForwardedGas(request);",
                        "            emit ExecutedForwardRequest(signer, currentNonce, success);",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Checks if the requested gas was correctly forwarded to the callee.",
                        "     *",
                        "     * As a consequence of https://eips.ethereum.org/EIPS/eip-150[EIP-150]:",
                        "     * - At most `gasleft() - floor(gasleft() / 64)` is forwarded to the callee.",
                        "     * - At least `floor(gasleft() / 64)` is kept in the caller.",
                        "     *",
                        "     * It reverts consuming all the available gas if the forwarded gas is not the requested gas.",
                        "     *",
                        "     * IMPORTANT: This function should be called exactly the end of the forwarded call. Any gas consumed",
                        "     * in between will make room for bypassing this check.",
                        "     */",
                        "    function _checkForwardedGas(ForwardRequestData calldata request) private view {",
                        "        //",
                        "        //",
                        "        //",
                        "        if (gasleft() < request.gas / 63) {",
                        "            assembly {",
                        "                invalid()",
                        "            }",
                        "        }",
                        "    }",
                        "}",
                        "     * @dev See {IERC-5267}."
                    ],
                    "del": [
                        "/**",
                        " * @dev Simple minimal forwarder to be used together with an ERC2771 compatible contract. See {ERC2771Context}.",
                        " *",
                        " * MinimalForwarder is mainly meant for testing, as it is missing features to be a good production-ready forwarder. This",
                        " * contract does not intend to have all the properties that are needed for a sound forwarding system. A fully",
                        " * functioning forwarding system with good properties requires more complexity. We suggest you look at other projects",
                        " * such as the GSN which do have the goal of building a system like that.",
                        " */",
                        "contract MinimalForwarder is EIP712 {",
                        "    using ECDSA for bytes32;",
                        "    struct ForwardRequest {",
                        "        address from;",
                        "        address to;",
                        "        uint256 value;",
                        "        uint256 gas;",
                        "        uint256 nonce;",
                        "        bytes data;",
                        "    }",
                        "    bytes32 private constant _TYPEHASH =",
                        "        keccak256(\"ForwardRequest(address from,address to,uint256 value,uint256 gas,uint256 nonce,bytes data)\");",
                        "    mapping(address => uint256) private _nonces;",
                        "    /**",
                        "     * @dev The request `from` doesn't match with the recovered `signer`.",
                        "     */",
                        "    error MinimalForwarderInvalidSigner(address signer, address from);",
                        "    /**",
                        "     * @dev The request nonce doesn't match with the `current` nonce for the request signer.",
                        "     */",
                        "    error MinimalForwarderInvalidNonce(address signer, uint256 current);",
                        "    constructor() EIP712(\"MinimalForwarder\", \"0.0.1\") {}",
                        "    function getNonce(address from) public view returns (uint256) {",
                        "        return _nonces[from];",
                        "    }",
                        "    function verify(ForwardRequest calldata req, bytes calldata signature) public view returns (bool) {",
                        "        address signer = _recover(req, signature);",
                        "        (bool correctFrom, bool correctNonce) = _validateReq(req, signer);",
                        "        return correctFrom && correctNonce;",
                        "    }",
                        "    function execute(",
                        "        ForwardRequest calldata req,",
                        "        bytes calldata signature",
                        "    ) public payable returns (bool, bytes memory) {",
                        "        address signer = _recover(req, signature);",
                        "        (bool correctFrom, bool correctNonce) = _validateReq(req, signer);",
                        "        if (!correctFrom) {",
                        "            revert MinimalForwarderInvalidSigner(signer, req.from);",
                        "        }",
                        "        if (!correctNonce) {",
                        "            revert MinimalForwarderInvalidNonce(signer, _nonces[req.from]);",
                        "        }",
                        "        _nonces[req.from] = req.nonce + 1;",
                        "        (bool success, bytes memory returndata) = req.to.call{gas: req.gas, value: req.value}(",
                        "            abi.encodePacked(req.data, req.from)",
                        "        );",
                        "        if (gasleft() <= req.gas / 63) {",
                        "            assembly {",
                        "                invalid()",
                        "            }",
                        "        }",
                        "        return (success, returndata);",
                        "    }",
                        "    function _recover(ForwardRequest calldata req, bytes calldata signature) internal view returns (address) {",
                        "        return",
                        "            _hashTypedDataV4(",
                        "                keccak256(abi.encode(_TYPEHASH, req.from, req.to, req.value, req.gas, req.nonce, keccak256(req.data)))",
                        "            ).recover(signature);",
                        "    }",
                        "    function _validateReq(",
                        "        ForwardRequest calldata req,",
                        "        address signer",
                        "    ) internal view returns (bool correctFrom, bool correctNonce) {",
                        "        return (signer == req.from, _nonces[req.from] == req.nonce);",
                        "    }",
                        "}",
                        "     * @dev See {EIP-5267}."
                    ]
                }
            }
        ],
        "- `ERC1155Supply`: add a `totalSupply()` function that returns the total amount of token circulating, this change will restrict the total tokens minted across all ids to 2\\*\\*256-1 . ([#3962](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3962))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3962": {
                    "add": [
                        "    uint256 private _totalSupplyAll;",
                        "    /**",
                        "     * @dev Total amount of tokens.",
                        "     */",
                        "    function totalSupply() public view virtual returns (uint256) {",
                        "        return _totalSupplyAll;",
                        "    }",
                        "            uint256 totalMintAmount = 0;",
                        "                uint256 amount = amounts[i];",
                        "                _totalSupply[ids[i]] += amount;",
                        "                totalMintAmount += amount;",
                        "            _totalSupplyAll += totalMintAmount;",
                        "            uint256 totalBurnAmount = 0;",
                        "                    totalBurnAmount += amount;",
                        "            unchecked {",
                        "                _totalSupplyAll -= totalBurnAmount;",
                        "            }"
                    ],
                    "del": [
                        "                _totalSupply[ids[i]] += amounts[i];"
                    ]
                }
            }
        ],
        "- `ERC721`: `_approve` no longer allows approving the owner of the tokenId. `_setApprovalForAll` no longer allows setting address(0) as an operator. ([#4377](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4377))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4377": {
                    "add": [
                        "    function _update(",
                        "        uint256 tokenId,",
                        "        address auth",
                        "    ) internal virtual override(ERC721Consecutive, ERC721Enumerable) returns (address) {",
                        "        return super._update(to, tokenId, auth);",
                        "    function _increaseBalance(address account, uint128 amount) internal virtual override(ERC721, ERC721Enumerable) {",
                        "        super._increaseBalance(account, amount);",
                        "    function _update(",
                        "        uint256 tokenId,",
                        "        address auth",
                        "    ) internal virtual override(ERC721Consecutive, ERC721Pausable, ERC721Votes) returns (address) {",
                        "        return super._update(to, tokenId, auth);",
                        "    function _increaseBalance(address account, uint128 amount) internal virtual override(ERC721, ERC721Votes) {",
                        "        super._increaseBalance(account, amount);",
                        "        _approve(to, tokenId, _msgSender());",
                        "        return _getApproved(tokenId);",
                        "        if (to == address(0)) {",
                        "            revert ERC721InvalidReceiver(address(0));",
                        "        }",
                        "        address previousOwner = _update(to, tokenId, _msgSender());",
                        "        if (previousOwner != from) {",
                        "            revert ERC721IncorrectOwner(from, tokenId, previousOwner);",
                        "    function safeTransferFrom(address from, address to, uint256 tokenId) public {",
                        "        transferFrom(from, to, tokenId);",
                        "        _checkOnERC721Received(from, to, tokenId, data);",
                        "     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist",
                        "     * IMPORTANT: Any overrides to this function that add ownership of tokens not tracked by the",
                        "     * core ERC721 logic MUST be matched with the use of {_increaseBalance} to keep balances",
                        "     * consistent with ownership. The invariant to preserve is that for any address `a` the value returned by",
                        "     * `balanceOf(a)` must be equal to the number of tokens such that `_ownerOf(tokenId)` is `a`.",
                        "    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {",
                        "        return _owners[tokenId];",
                        "     * @dev Returns the approved address for `tokenId`. Returns 0 if `tokenId` is not minted.",
                        "    function _getApproved(uint256 tokenId) internal view virtual returns (address) {",
                        "        return _tokenApprovals[tokenId];",
                        "     * @dev Returns whether `spender` is allowed to manage `owner`'s tokens, or `tokenId` in",
                        "     * particular (ignoring whether it is owned by `owner`).",
                        "     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not",
                        "     * verify this assumption.",
                        "    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {",
                        "        return",
                        "            spender != address(0) &&",
                        "            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);",
                        "     * @dev Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.",
                        "     * Reverts if `spender` has not approval for all assets of the provided `owner` nor the actual owner approved the `spender` for the specific `tokenId`.",
                        "     * WARNING: This function relies on {_isAuthorized}, so it doesn't check whether `owner` is the",
                        "     * actual owner of `tokenId`.",
                        "    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {",
                        "        if (!_isAuthorized(owner, spender, tokenId)) {",
                        "            if (owner == address(0)) {",
                        "                revert ERC721NonexistentToken(tokenId);",
                        "            } else {",
                        "                revert ERC721InsufficientApproval(spender, tokenId);",
                        "            }",
                        "        }",
                        "     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.",
                        "     * NOTE: the value is limited to type(uint128).max. This protect against _balance overflow. It is unrealistic that",
                        "     * a uint256 would ever overflow from increments when these increments are bounded to uint128 values.",
                        "     * WARNING: Increasing an account's balance using this function tends to be paired with an override of the",
                        "     * {_ownerOf} function to resolve the ownership of the corresponding tokens so that balances and ownership",
                        "     * remain consistent with one another.",
                        "    function _increaseBalance(address account, uint128 value) internal virtual {",
                        "        unchecked {",
                        "            _balances[account] += value;",
                        "        }",
                        "     * @dev Transfers `tokenId` from its current owner to `to`, or alternatively mints (or burns) if the current owner",
                        "     * (or `to`) is the zero address. Returns the owner of the `tokenId` before the update.",
                        "     *",
                        "     * The `auth` argument is optional. If the value passed is non 0, then this function will check that",
                        "     * `auth` is either the owner of the token, or approved to operate on the token (by the owner).",
                        "     *",
                        "     * Emits a {Transfer} event.",
                        "     *",
                        "     * NOTE: If overriding this function in a way that tracks balances, see also {_increaseBalance}.",
                        "    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {",
                        "        address from = _ownerOf(tokenId);",
                        "        if (auth != address(0)) {",
                        "            _checkAuthorized(from, auth, tokenId);",
                        "        }",
                        "        if (from != address(0)) {",
                        "            delete _tokenApprovals[tokenId];",
                        "            unchecked {",
                        "                _balances[from] -= 1;",
                        "            }",
                        "        }",
                        "        if (to != address(0)) {",
                        "            unchecked {",
                        "                _balances[to] += 1;",
                        "            }",
                        "        _owners[tokenId] = to;",
                        "        emit Transfer(from, to, tokenId);",
                        "        return from;",
                        "    function _mint(address to, uint256 tokenId) internal {",
                        "        address previousOwner = _update(to, tokenId, address(0));",
                        "        if (previousOwner != address(0)) {",
                        "    }",
                        "    /**",
                        "     * @dev Mints `tokenId`, transfers it to `to` and checks for `to` acceptance.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `tokenId` must not exist.",
                        "     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.",
                        "     *",
                        "     * Emits a {Transfer} event.",
                        "     */",
                        "    function _safeMint(address to, uint256 tokenId) internal {",
                        "        _safeMint(to, tokenId, \"\");",
                        "    }",
                        "    /**",
                        "     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is",
                        "     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.",
                        "     */",
                        "    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {",
                        "        _mint(to, tokenId);",
                        "        _checkOnERC721Received(address(0), to, tokenId, data);",
                        "    function _burn(uint256 tokenId) internal {",
                        "        address previousOwner = _update(address(0), tokenId, address(0));",
                        "        if (previousOwner == address(0)) {",
                        "            revert ERC721NonexistentToken(tokenId);",
                        "        }",
                        "    function _transfer(address from, address to, uint256 tokenId) internal {",
                        "        address previousOwner = _update(to, tokenId, address(0));",
                        "        if (previousOwner == address(0)) {",
                        "            revert ERC721NonexistentToken(tokenId);",
                        "        } else if (previousOwner != from) {",
                        "            revert ERC721IncorrectOwner(from, tokenId, previousOwner);",
                        "    }",
                        "    /**",
                        "     * @dev Safely transfers `tokenId` token from `from` to `to`, checking that contract recipients",
                        "     * are aware of the ERC721 standard to prevent tokens from being forever locked.",
                        "     *",
                        "     * `data` is additional data, it has no specified format and it is sent in call to `to`.",
                        "     *",
                        "     * This internal function is like {safeTransferFrom} in the sense that it invokes",
                        "     * {IERC721Receiver-onERC721Received} on the receiver, and can be used to e.g.",
                        "     * implement alternative mechanisms to perform token transfer, such as signature-based.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `tokenId` token must exist and be owned by `from`.",
                        "     * - `to` cannot be the zero address.",
                        "     * - `from` cannot be the zero address.",
                        "     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.",
                        "     *",
                        "     * Emits a {Transfer} event.",
                        "     */",
                        "    function _safeTransfer(address from, address to, uint256 tokenId) internal {",
                        "        _safeTransfer(from, to, tokenId, \"\");",
                        "    }",
                        "    /**",
                        "     * @dev Same as {xref-ERC721-_safeTransfer-address-address-uint256-}[`_safeTransfer`], with an additional `data` parameter which is",
                        "     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.",
                        "     */",
                        "    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {",
                        "        _transfer(from, to, tokenId);",
                        "        _checkOnERC721Received(from, to, tokenId, data);",
                        "     * The `auth` argument is optional. If the value passed is non 0, then this function will check that `auth` is",
                        "     * either the owner of the token, or approved to operate on all tokens held by this owner.",
                        "     *",
                        "    function _approve(address to, uint256 tokenId, address auth) internal virtual returns (address) {",
                        "        address owner = ownerOf(tokenId);",
                        "        if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {",
                        "            revert ERC721InvalidApprover(auth);",
                        "        }",
                        "        emit Approval(owner, to, tokenId);",
                        "        return owner;",
                        "     * Requirements:",
                        "     * - operator can't be the address zero.",
                        "     *",
                        "        if (operator == address(0)) {",
                        "            revert ERC721InvalidOperator(operator);",
                        "        if (_ownerOf(tokenId) == address(0)) {",
                        "     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target address. This will revert if the",
                        "     * recipient doesn't accept the token transfer. The call is not executed if the target address is not a contract.",
                        "     */",
                        "    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {",
                        "                if (retval != IERC721Receiver.onERC721Received.selector) {",
                        "                    revert ERC721InvalidReceiver(to);",
                        "                }",
                        "     * - The `operator` cannot be the address zero.",
                        "        _update(address(0), tokenId, _msgSender());",
                        "            _increaseBalance(to, batchSize);",
                        "     * @dev See {ERC721-_update}. Override version that restricts normal minting to after construction.",
                        "     * WARNING: Using {ERC721Consecutive} prevents minting during construction in favor of {_mintConsecutive}.",
                        "     * After construction, {_mintConsecutive} is no longer available and minting through {_update} becomes available.",
                        "    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {",
                        "        address previousOwner = super._update(to, tokenId, auth);",
                        "        if (previousOwner == address(0) && address(this).code.length == 0) {",
                        "        ) {",
                        "            _sequentialBurn.set(tokenId);",
                        "        return previousOwner;",
                        "     * @dev See {ERC721-_update}.",
                        "    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {",
                        "        address previousOwner = super._update(to, tokenId, auth);",
                        "        if (previousOwner == address(0)) {",
                        "        } else if (previousOwner != to) {",
                        "            _removeTokenFromOwnerEnumeration(previousOwner, tokenId);",
                        "        } else if (previousOwner != to) {",
                        "        return previousOwner;",
                        "        uint256 length = balanceOf(to) - 1;",
                        "        uint256 lastTokenIndex = balanceOf(from);",
                        "    /**",
                        "     * See {ERC721-_increaseBalance}. We need that to account tokens that were minted in batch",
                        "     */",
                        "    function _increaseBalance(address account, uint128 amount) internal virtual override {",
                        "        if (amount > 0) {",
                        "            revert ERC721EnumerableForbiddenBatchMint();",
                        "        }",
                        "        super._increaseBalance(account, amount);",
                        "    }",
                        "     * @dev See {ERC721-_update}.",
                        "    function _update(",
                        "        uint256 tokenId,",
                        "        address auth",
                        "    ) internal virtual override whenNotPaused returns (address) {",
                        "        return super._update(to, tokenId, auth);",
                        "     * @dev See {ERC721-_update}. When burning, this override will additionally clear the royalty information for the token.",
                        "    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {",
                        "        address previousOwner = super._update(to, tokenId, auth);",
                        "        if (to == address(0)) {",
                        "            _resetTokenRoyalty(tokenId);",
                        "        }",
                        "        return previousOwner;",
                        "        if (_ownerOf(tokenId) == address(0)) {",
                        "     * @dev See {ERC721-_update}. When burning, this override will additionally check if a",
                        "    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {",
                        "        address previousOwner = super._update(to, tokenId, auth);",
                        "        if (to == address(0) && bytes(_tokenURIs[tokenId]).length != 0) {",
                        "        return previousOwner;",
                        "     * @dev See {ERC721-_update}. Adjusts votes when tokens are transferred.",
                        "    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {",
                        "        address previousOwner = super._update(to, tokenId, auth);",
                        "        _transferVotingUnits(previousOwner, to, 1);",
                        "        return previousOwner;",
                        "    /**",
                        "     * @dev See {ERC721-_increaseBalance}. We need that to account tokens that were minted in batch.",
                        "     */",
                        "    function _increaseBalance(address account, uint128 amount) internal virtual override {",
                        "        super._increaseBalance(account, amount);",
                        "        _transferVotingUnits(address(0), account, amount);",
                        "    }",
                        "            _update(address(0), tokenId, _msgSender());"
                    ],
                    "del": [
                        "    function _mint(address to, uint256 tokenId) internal virtual override(ERC721, ERC721Consecutive) {",
                        "        super._mint(to, tokenId);",
                        "    }",
                        "    function _beforeTokenTransfer(",
                        "        address from,",
                        "        uint256 firstTokenId,",
                        "        uint256 batchSize",
                        "    ) internal virtual override(ERC721, ERC721Enumerable) {",
                        "        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);",
                        "    function _afterTokenTransfer(",
                        "        address from,",
                        "        address to,",
                        "        uint256 firstTokenId,",
                        "        uint256 batchSize",
                        "    ) internal virtual override(ERC721, ERC721Consecutive) {",
                        "        super._afterTokenTransfer(from, to, firstTokenId, batchSize);",
                        "    function _mint(address to, uint256 tokenId) internal virtual override(ERC721, ERC721Consecutive) {",
                        "        super._mint(to, tokenId);",
                        "    }",
                        "    function _beforeTokenTransfer(",
                        "        address from,",
                        "        uint256 firstTokenId,",
                        "        uint256 batchSize",
                        "    ) internal virtual override(ERC721, ERC721Pausable) {",
                        "        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);",
                        "    function _afterTokenTransfer(",
                        "        address from,",
                        "        address to,",
                        "        uint256 firstTokenId,",
                        "        uint256 batchSize",
                        "    ) internal virtual override(ERC721, ERC721Votes, ERC721Consecutive) {",
                        "        super._afterTokenTransfer(from, to, firstTokenId, batchSize);",
                        "        address owner = ownerOf(tokenId);",
                        "        if (to == owner) {",
                        "            revert ERC721InvalidOperator(owner);",
                        "        }",
                        "        if (_msgSender() != owner && !isApprovedForAll(owner, _msgSender())) {",
                        "            revert ERC721InvalidApprover(_msgSender());",
                        "        }",
                        "        _approve(to, tokenId);",
                        "        return _tokenApprovals[tokenId];",
                        "        if (!_isApprovedOrOwner(_msgSender(), tokenId)) {",
                        "            revert ERC721InsufficientApproval(_msgSender(), tokenId);",
                        "        _transfer(from, to, tokenId);",
                        "    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual {",
                        "        if (!_isApprovedOrOwner(_msgSender(), tokenId)) {",
                        "            revert ERC721InsufficientApproval(_msgSender(), tokenId);",
                        "        }",
                        "        _safeTransfer(from, to, tokenId, data);",
                        "     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients",
                        "     * are aware of the ERC721 protocol to prevent tokens from being forever locked.",
                        "     *",
                        "     * `data` is additional data, it has no specified format and it is sent in call to `to`.",
                        "     *",
                        "     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.",
                        "     * implement alternative mechanisms to perform token transfer, such as signature-based.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `from` cannot be the zero address.",
                        "     * - `to` cannot be the zero address.",
                        "     * - `tokenId` token must exist and be owned by `from`.",
                        "     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.",
                        "     * Emits a {Transfer} event.",
                        "    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {",
                        "        _transfer(from, to, tokenId);",
                        "        if (!_checkOnERC721Received(from, to, tokenId, data)) {",
                        "            revert ERC721InvalidReceiver(to);",
                        "        }",
                        "     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist",
                        "    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {",
                        "        return _owners[tokenId];",
                        "     * @dev Returns whether `tokenId` exists.",
                        "     *",
                        "     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.",
                        "     * Tokens start existing when they are minted (`_mint`),",
                        "     * and stop existing when they are burned (`_burn`).",
                        "    function _exists(uint256 tokenId) internal view virtual returns (bool) {",
                        "        return _ownerOf(tokenId) != address(0);",
                        "     * @dev Returns whether `spender` is allowed to manage `tokenId`.",
                        "     * Requirements:",
                        "     *",
                        "     * - `tokenId` must exist.",
                        "    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {",
                        "        address owner = ownerOf(tokenId);",
                        "        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);",
                        "     * @dev Safely mints `tokenId` and transfers it to `to`.",
                        "     *",
                        "     * Requirements:",
                        "     * - `tokenId` must not exist.",
                        "     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.",
                        "     * Emits a {Transfer} event.",
                        "    function _safeMint(address to, uint256 tokenId) internal virtual {",
                        "        _safeMint(to, tokenId, \"\");",
                        "     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is",
                        "     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.",
                        "    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {",
                        "        _mint(to, tokenId);",
                        "        if (!_checkOnERC721Received(address(0), to, tokenId, data)) {",
                        "            revert ERC721InvalidReceiver(to);",
                        "    function _mint(address to, uint256 tokenId) internal virtual {",
                        "        if (_exists(tokenId)) {",
                        "        _beforeTokenTransfer(address(0), to, tokenId, 1);",
                        "        if (_exists(tokenId)) {",
                        "            revert ERC721InvalidSender(address(0));",
                        "        }",
                        "        unchecked {",
                        "            _balances[to] += 1;",
                        "        }",
                        "        _owners[tokenId] = to;",
                        "        emit Transfer(address(0), to, tokenId);",
                        "        _afterTokenTransfer(address(0), to, tokenId, 1);",
                        "    function _burn(uint256 tokenId) internal virtual {",
                        "        address owner = ownerOf(tokenId);",
                        "        _beforeTokenTransfer(owner, address(0), tokenId, 1);",
                        "        owner = ownerOf(tokenId);",
                        "        delete _tokenApprovals[tokenId];",
                        "        _balances[owner] -= 1;",
                        "        delete _owners[tokenId];",
                        "        emit Transfer(owner, address(0), tokenId);",
                        "        _afterTokenTransfer(owner, address(0), tokenId, 1);",
                        "    function _transfer(address from, address to, uint256 tokenId) internal virtual {",
                        "        address owner = ownerOf(tokenId);",
                        "        if (owner != from) {",
                        "            revert ERC721IncorrectOwner(from, tokenId, owner);",
                        "        }",
                        "        _beforeTokenTransfer(from, to, tokenId, 1);",
                        "        owner = ownerOf(tokenId);",
                        "        if (owner != from) {",
                        "            revert ERC721IncorrectOwner(from, tokenId, owner);",
                        "        }",
                        "        delete _tokenApprovals[tokenId];",
                        "        _balances[from] -= 1;",
                        "        unchecked {",
                        "            _balances[to] += 1;",
                        "        _owners[tokenId] = to;",
                        "        emit Transfer(from, to, tokenId);",
                        "        _afterTokenTransfer(from, to, tokenId, 1);",
                        "    function _approve(address to, uint256 tokenId) internal virtual {",
                        "        emit Approval(ownerOf(tokenId), to, tokenId);",
                        "        if (owner == operator) {",
                        "            revert ERC721InvalidOperator(owner);",
                        "        if (!_exists(tokenId)) {",
                        "     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target address.",
                        "     * The call is not executed if the target address is not a contract.",
                        "     * @return bool whether the call correctly returned the expected magic value",
                        "     */",
                        "    function _checkOnERC721Received(",
                        "        address from,",
                        "        address to,",
                        "        uint256 tokenId,",
                        "        bytes memory data",
                        "    ) private returns (bool) {",
                        "                return retval == IERC721Receiver.onERC721Received.selector;",
                        "        } else {",
                        "            return true;",
                        "    /**",
                        "     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is",
                        "     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.",
                        "     *",
                        "     * Calling conditions:",
                        "     *",
                        "     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.",
                        "     * - When `from` is zero, the tokens will be minted for `to`.",
                        "     * - When `to` is zero, ``from``'s tokens will be burned.",
                        "     * - `from` and `to` are never both zero.",
                        "     * - `batchSize` is non-zero.",
                        "     *",
                        "     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].",
                        "     */",
                        "    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}",
                        "    /**",
                        "     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is",
                        "     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.",
                        "     *",
                        "     * Calling conditions:",
                        "     *",
                        "     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.",
                        "     * - When `from` is zero, the tokens were minted for `to`.",
                        "     * - When `to` is zero, ``from``'s tokens were burned.",
                        "     * - `from` and `to` are never both zero.",
                        "     * - `batchSize` is non-zero.",
                        "     *",
                        "     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].",
                        "     */",
                        "    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}",
                        "    /**",
                        "     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.",
                        "     *",
                        "     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant",
                        "     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such",
                        "     * that `ownerOf(tokenId)` is `a`.",
                        "     */",
                        "    function __unsafe_increaseBalance(address account, uint256 value) internal {",
                        "        _balances[account] += value;",
                        "    }",
                        "     * - The `operator` cannot be the caller.",
                        "        if (!_isApprovedOrOwner(_msgSender(), tokenId)) {",
                        "            revert ERC721InsufficientApproval(_msgSender(), tokenId);",
                        "        }",
                        "        _burn(tokenId);",
                        "            _beforeTokenTransfer(address(0), to, next, batchSize);",
                        "            __unsafe_increaseBalance(to, batchSize);",
                        "            _afterTokenTransfer(address(0), to, next, batchSize);",
                        "     * @dev See {ERC721-_mint}. Override version that restricts normal minting to after construction.",
                        "     * WARNING: Using {ERC721Consecutive} prevents using {_mint} during construction in favor of {_mintConsecutive}.",
                        "     * After construction, {_mintConsecutive} is no longer available and {_mint} becomes available.",
                        "    function _mint(address to, uint256 tokenId) internal virtual override {",
                        "        if (address(this).code.length == 0) {",
                        "        super._mint(to, tokenId);",
                        "    }",
                        "    /**",
                        "     * @dev See {ERC721-_afterTokenTransfer}. Burning of tokens that have been sequentially minted must be explicit.",
                        "     */",
                        "    function _afterTokenTransfer(",
                        "        address from,",
                        "        address to,",
                        "        uint256 firstTokenId,",
                        "        uint256 batchSize",
                        "    ) internal virtual override {",
                        "            firstTokenId >= _firstConsecutiveId() &&",
                        "            firstTokenId < _nextConsecutiveId() &&",
                        "            !_sequentialBurn.get(firstTokenId)",
                        "        {",
                        "            if (batchSize != 1) {",
                        "                revert ERC721ForbiddenBatchBurn();",
                        "            }",
                        "            _sequentialBurn.set(firstTokenId);",
                        "        super._afterTokenTransfer(from, to, firstTokenId, batchSize);",
                        "     * @dev See {ERC721-_beforeTokenTransfer}.",
                        "    function _beforeTokenTransfer(",
                        "        address from,",
                        "        address to,",
                        "        uint256 firstTokenId,",
                        "        uint256 batchSize",
                        "    ) internal virtual override {",
                        "        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);",
                        "        if (batchSize > 1) {",
                        "            revert ERC721EnumerableForbiddenBatchMint();",
                        "        }",
                        "        uint256 tokenId = firstTokenId;",
                        "        if (from == address(0)) {",
                        "        } else if (from != to) {",
                        "            _removeTokenFromOwnerEnumeration(from, tokenId);",
                        "        } else if (to != from) {",
                        "        uint256 length = balanceOf(to);",
                        "        uint256 lastTokenIndex = balanceOf(from) - 1;",
                        "     * @dev See {ERC721-_beforeTokenTransfer}.",
                        "    function _beforeTokenTransfer(",
                        "        address from,",
                        "        uint256 firstTokenId,",
                        "        uint256 batchSize",
                        "    ) internal virtual override {",
                        "        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);",
                        "        _requireNotPaused();",
                        "     * @dev See {ERC721-_burn}. This override additionally clears the royalty information for the token.",
                        "    function _burn(uint256 tokenId) internal virtual override {",
                        "        super._burn(tokenId);",
                        "        _resetTokenRoyalty(tokenId);",
                        "        if (!_exists(tokenId)) {",
                        "     * @dev See {ERC721-_burn}. This override additionally checks to see if a",
                        "    function _burn(uint256 tokenId) internal virtual override {",
                        "        super._burn(tokenId);",
                        "        if (bytes(_tokenURIs[tokenId]).length != 0) {",
                        "     * @dev See {ERC721-_afterTokenTransfer}. Adjusts votes when tokens are transferred.",
                        "    function _afterTokenTransfer(",
                        "        address from,",
                        "        address to,",
                        "        uint256 firstTokenId,",
                        "        uint256 batchSize",
                        "    ) internal virtual override {",
                        "        _transferVotingUnits(from, to, batchSize);",
                        "        super._afterTokenTransfer(from, to, firstTokenId, batchSize);",
                        "            if (!_isApprovedOrOwner(_msgSender(), tokenId)) {",
                        "                revert ERC721InsufficientApproval(_msgSender(), tokenId);",
                        "            }",
                        "            _burn(tokenId);"
                    ]
                }
            }
        ],
        "- `ERC721URIStorage`: Allow setting the token URI prior to minting. ([#4559](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4559))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4559": {
                    "add": [],
                    "del": [
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `tokenId` must exist.",
                        "        if (_ownerOf(tokenId) == address(0)) {",
                        "            revert ERC721NonexistentToken(tokenId);",
                        "        }"
                    ]
                }
            }
        ],
        "- `UUPSUpgradeable`, `TransparentUpgradeableProxy` and `ProxyAdmin`: Removed `upgradeTo` and `upgrade` functions, and made `upgradeToAndCall` and `upgradeAndCall` ignore the data argument if it is empty. It is no longer possible to invoke the receive function (or send value with empty data) along with an upgrade. ([#4382](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4382))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4382": {
                    "add": [
                        "contract UpgradeableBeaconMock is IBeacon {",
                        "    address public implementation;",
                        "    constructor(address impl) {",
                        "        implementation = impl;",
                        "    }",
                        "}",
                        "    function upgradeToAndCall(address, bytes calldata) external payable {",
                        "        ERC1967Utils.upgradeToAndCall(newImplementation, data);",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - If `data` is empty, `msg.value` must be zero.",
                        "        ERC1967Utils.upgradeToAndCall(_logic, _data);",
                        "    /**",
                        "     * @dev An upgrade function sees `msg.value > 0` that may be lost.",
                        "     */",
                        "    error ERC1967NonPayable();",
                        "     * @dev Performs implementation upgrade with additional setup call if data is nonempty.",
                        "     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected",
                        "     * to avoid stuck value in the contract.",
                        "    function upgradeToAndCall(address newImplementation, bytes memory data) internal {",
                        "        if (data.length > 0) {",
                        "        } else {",
                        "            _checkNonPayable();",
                        "     * @dev Change the beacon and trigger a setup call if data is nonempty.",
                        "     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected",
                        "     * to avoid stuck value in the contract.",
                        "    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {",
                        "        if (data.length > 0) {",
                        "        } else {",
                        "            _checkNonPayable();",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Reverts if `msg.value` is not zero.",
                        "     */",
                        "    function _checkNonPayable() private {",
                        "        if (msg.value > 0) {",
                        "            revert ERC1967NonPayable();",
                        "     * - If `data` is empty, `msg.value` must be zero.",
                        "        ERC1967Utils.upgradeBeaconToAndCall(beacon, data);",
                        "     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgrade(address)`",
                        "     * and `upgradeAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,",
                        "     * while `upgradeAndCall` will invoke the `receive` function if the second argument is the empty byte string.",
                        "     * If the getter returns `\"5.0.0\"`, only `upgradeAndCall(address,bytes)` is present, and the second argument must",
                        "     * be the empty byte string if no function should be called, being impossible to invoke the `receive` function",
                        "     * during an upgrade.",
                        "    string public constant UPGRADE_INTERFACE_VERSION = \"5.0.0\";",
                        "     * @dev Sets the initial owner who can perform upgrades.",
                        "    constructor(address initialOwner) Ownable(initialOwner) {}",
                        "     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation.",
                        "     * See {TransparentUpgradeableProxy-_dispatchUpgradeToAndCall}.",
                        "     * - If `data` is empty, `msg.value` must be zero.",
                        " * does not implement this interface directly, and its upgradeability mechanism is implemented by an internal dispatch",
                        "    function upgradeToAndCall(address, bytes calldata) external payable;",
                        " * @dev This contract implements a proxy that is upgradeable through an associated {ProxyAdmin} instance.",
                        " * that call matches the {ITransparentUpgradeableProxy-upgradeToAndCall} function exposed by the proxy itself.",
                        " * 2. If the admin calls the proxy, it can call the `upgradeToAndCall` function but any other call won't be forwarded to the",
                        " * from the proxy implementation. For this reason, the proxy deploys an instance of {ProxyAdmin} and allows upgrades",
                        " * only if they come through it.",
                        " * You should think of the `ProxyAdmin` instance as the administrative interface of the proxy, including the ability to",
                        " * change who can trigger upgrades by transferring ownership.",
                        " * inherit from that interface, and instead `upgradeToAndCall` is implicitly implemented using a custom dispatch mechanism",
                        " * in `_fallback`. Consequently, the compiler will not produce an ABI for this contract. This is necessary to fully",
                        " * implement transparency without decoding reverts caused by selector clashes between the proxy and the",
                        " * render the `upgradeToAndCall` function inaccessible, preventing upgradeability and compromising transparency.",
                        "     * @dev Initializes an upgradeable proxy managed by an instance of a {ProxyAdmin} with an `initialOwner`,",
                        "     * backed by the implementation at `_logic`, and optionally initialized with `_data` as explained in",
                        "     * {ERC1967Proxy-constructor}.",
                        "    constructor(address _logic, address initialOwner, bytes memory _data) payable ERC1967Proxy(_logic, _data) {",
                        "        _admin = address(new ProxyAdmin(initialOwner));",
                        "        ERC1967Utils.changeAdmin(_admin);",
                        "     * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior.",
                        "            if (msg.sig == ITransparentUpgradeableProxy.upgradeToAndCall.selector) {",
                        "                _dispatchUpgradeToAndCall();",
                        "     * @dev Upgrade the implementation of the proxy. See {ERC1967Utils-upgradeToAndCall}.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - If `data` is empty, `msg.value` must be zero.",
                        "    function _dispatchUpgradeToAndCall() private {",
                        "        ERC1967Utils.upgradeToAndCall(newImplementation, data);",
                        "    /**",
                        "     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`",
                        "     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,",
                        "     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.",
                        "     * If the getter returns `\"5.0.0\"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must",
                        "     * be the empty byte string if no function should be called, being impossible to invoke the `receive` function",
                        "     * during an upgrade.",
                        "     */",
                        "    string public constant UPGRADE_INTERFACE_VERSION = \"5.0.0\";",
                        "        _upgradeToAndCallUUPS(newImplementation, data);",
                        "     * {upgradeToAndCall}.",
                        "     * function _authorizeUpgrade(address) internal onlyOwner {}",
                        "    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {",
                        "            ERC1967Utils.upgradeToAndCall(newImplementation, data);"
                    ],
                    "del": [
                        "    function upgradeTo(address) external payable {",
                        "    function upgradeTo(address newImplementation) public override {",
                        "        ERC1967Utils.upgradeToAndCall(newImplementation, bytes(\"\"), false);",
                        "    }",
                        "        ERC1967Utils.upgradeToAndCall(newImplementation, data, false);",
                        "        ERC1967Utils.upgradeToAndCall(_logic, _data, false);",
                        "     * @dev Perform implementation upgrade",
                        "    function upgradeTo(address newImplementation) internal {",
                        "    }",
                        "    /**",
                        "     * @dev Perform implementation upgrade with additional setup call.",
                        "     *",
                        "     * Emits an {IERC1967-Upgraded} event.",
                        "     */",
                        "    function upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {",
                        "        upgradeTo(newImplementation);",
                        "        if (data.length > 0 || forceCall) {",
                        "     * @dev Change the beacon and trigger a setup call.",
                        "    function upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {",
                        "        if (data.length > 0 || forceCall) {",
                        "        ERC1967Utils.upgradeBeaconToAndCall(beacon, data, false);",
                        "     * @dev Sets the initial owner who can perform upgrades.",
                        "    constructor(address initialOwner) Ownable(initialOwner) {}",
                        "     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - This contract must be the admin of `proxy`.",
                        "    function upgrade(ITransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {",
                        "        proxy.upgradeTo(implementation);",
                        "    }",
                        "     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See",
                        "     * {TransparentUpgradeableProxy-upgradeToAndCall}.",
                        " * does not implement this interface directly, and some of its functions are implemented by an internal dispatch",
                        "    function upgradeTo(address) external;",
                        "    function upgradeToAndCall(address, bytes memory) external payable;",
                        " * @dev This contract implements a proxy that is upgradeable by an immutable admin.",
                        " * that call matches one of the admin functions exposed by the proxy itself.",
                        " * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the",
                        " * from the proxy implementation.",
                        " *",
                        " * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,",
                        " * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy, which extends from the",
                        " * {Ownable} contract to allow for changing the proxy's admin owner.",
                        " * inherit from that interface, and instead the admin functions are implicitly implemented using a custom dispatch",
                        " * mechanism in `_fallback`. Consequently, the compiler will not produce an ABI for this contract. This is necessary to",
                        " * fully implement transparency without decoding reverts caused by selector clashes between the proxy and the",
                        " * render the admin operations inaccessible, which could prevent upgradeability. Transparency may also be compromised.",
                        "     * @dev msg.value is not 0.",
                        "     */",
                        "    error ProxyNonPayableFunction();",
                        "    /**",
                        "     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and",
                        "     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.",
                        "    constructor(address _logic, address admin_, bytes memory _data) payable ERC1967Proxy(_logic, _data) {",
                        "        _admin = admin_;",
                        "        ERC1967Utils.changeAdmin(admin_);",
                        "     * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior",
                        "            bytes memory ret;",
                        "            bytes4 selector = msg.sig;",
                        "            if (selector == ITransparentUpgradeableProxy.upgradeTo.selector) {",
                        "                ret = _dispatchUpgradeTo();",
                        "            } else if (selector == ITransparentUpgradeableProxy.upgradeToAndCall.selector) {",
                        "                ret = _dispatchUpgradeToAndCall();",
                        "            assembly {",
                        "                return(add(ret, 0x20), mload(ret))",
                        "            }",
                        "     * @dev Upgrade the implementation of the proxy.",
                        "     */",
                        "    function _dispatchUpgradeTo() private returns (bytes memory) {",
                        "        _requireZeroValue();",
                        "        address newImplementation = abi.decode(msg.data[4:], (address));",
                        "        ERC1967Utils.upgradeToAndCall(newImplementation, bytes(\"\"), false);",
                        "        return \"\";",
                        "    }",
                        "    /**",
                        "     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified",
                        "     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the",
                        "     * proxied contract.",
                        "    function _dispatchUpgradeToAndCall() private returns (bytes memory) {",
                        "        ERC1967Utils.upgradeToAndCall(newImplementation, data, true);",
                        "        return \"\";",
                        "    }",
                        "    /**",
                        "     * @dev To keep this contract fully transparent, the fallback is payable. This helper is here to enforce",
                        "     * non-payability of function implemented through dispatchers while still allowing value to pass through.",
                        "     */",
                        "    function _requireZeroValue() private {",
                        "        if (msg.value != 0) {",
                        "            revert ProxyNonPayableFunction();",
                        "        }",
                        "    /**",
                        "     * @dev Upgrade the implementation of the proxy to `newImplementation`.",
                        "     *",
                        "     * Calls {_authorizeUpgrade}.",
                        "     *",
                        "     * Emits an {Upgraded} event.",
                        "     *",
                        "     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall",
                        "     */",
                        "    function upgradeTo(address newImplementation) public virtual onlyProxy {",
                        "        _authorizeUpgrade(newImplementation);",
                        "        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);",
                        "    }",
                        "        _upgradeToAndCallUUPS(newImplementation, data, true);",
                        "     * {upgradeTo} and {upgradeToAndCall}.",
                        "     * function _authorizeUpgrade(address) internal  onlyOwner {}",
                        "    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) private {",
                        "            ERC1967Utils.upgradeToAndCall(newImplementation, data, forceCall);"
                    ]
                }
            }
        ],
        "- `ERC721URIStorage`, `ERC721Royalty`: Stop resetting token-specific URI and royalties when burning. ([#4561](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4561))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4561": {
                    "add": [],
                    "del": [
                        "    /**",
                        "     * @dev See {ERC721-_update}. When burning, this override will additionally clear the royalty information for the token.",
                        "     */",
                        "    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {",
                        "        address previousOwner = super._update(to, tokenId, auth);",
                        "        if (to == address(0)) {",
                        "            _resetTokenRoyalty(tokenId);",
                        "        }",
                        "        return previousOwner;",
                        "    }",
                        "    /**",
                        "     * @dev See {ERC721-_update}. When burning, this override will additionally check if a",
                        "     * token-specific URI was set for the token, and if so, it deletes the token URI from",
                        "     * the storage mapping.",
                        "     */",
                        "    function _update(address to, uint256 tokenId, address auth) internal virtual override returns (address) {",
                        "        address previousOwner = super._update(to, tokenId, auth);",
                        "        if (to == address(0) && bytes(_tokenURIs[tokenId]).length != 0) {",
                        "            delete _tokenURIs[tokenId];",
                        "        }",
                        "        return previousOwner;",
                        "    }"
                    ]
                }
            }
        ],
        "- `Address`: Removed the ability to customize error messages. A common custom error is always used if the underlying revert reason cannot be bubbled up. ([#4502](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4502))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4502": {
                    "add": [
                        " *",
                        " * NOTE: When using this contract with any token whose balance is adjusted automatically (i.e. a rebase token), make sure",
                        " * to account the supply/balance adjustment in the vesting schedule to ensure the vested amount is as intended.",
                        "        } else if (timestamp >= end()) {",
                        "    /**",
                        "     * @dev Initializes the contract with a trusted forwarder, which will be able to",
                        "     * invoke functions on this contract on behalf of other accounts.",
                        "     *",
                        "     * NOTE: The trusted forwarder can be replaced by overriding {trustedForwarder}.",
                        "     */",
                        "    constructor(address trustedForwarder_) {",
                        "        _trustedForwarder = trustedForwarder_;",
                        "    /**",
                        "     * @dev Returns the address of the trusted forwarder.",
                        "     */",
                        "    function trustedForwarder() public view virtual returns (address) {",
                        "        return _trustedForwarder;",
                        "    }",
                        "    /**",
                        "     * @dev Indicates whether any particular address is the trusted forwarder.",
                        "     */",
                        "        return forwarder == trustedForwarder();",
                        "    /**",
                        "     * @dev Override for `msg.sender`. Defaults to the original `msg.sender` whenever",
                        "     * a call is not performed by the trusted forwarder or the calldata length is less than",
                        "     * 20 bytes (an address length).",
                        "     */",
                        "    /**",
                        "     * @dev Override for `msg.data`. Defaults to the original `msg.data` whenever",
                        "     * a call is not performed by the trusted forwarder or the calldata length is less than",
                        "     * 20 bytes (an address length).",
                        "     */",
                        " * WARNING: Do not approve this contract to spend tokens. Anyone can use this forwarder",
                        " * to execute calls with an arbitrary calldata to any address. Any form of approval may",
                        " * result in a loss of funds for the approving party.",
                        " *",
                        " * NOTE: Batching requests includes an optional refund for unused `msg.value` that is achieved by",
                        " * performing a call with empty calldata. While this is within the bounds of ERC-2771 compliance,",
                        " * if the refund receiver happens to consider the forwarder a trusted forwarder, it MUST properly",
                        " * handle `msg.data.length == 0`. `ERC2771Context` in OpenZeppelin Contracts versions prior to 4.9.3",
                        " * do not handle this properly.",
                        " *",
                        "    /**",
                        "     * @dev The request target doesn't trust the `forwarder`.",
                        "     */",
                        "    error ERC2771UntrustfulTarget(address target, address forwarder);",
                        "     * A transaction is considered valid when the target trusts this forwarder, the request hasn't expired",
                        "     * (deadline is not met), and the signer matches the `from` parameter of the signed request.",
                        "        (bool isTrustedForwarder, bool active, bool signerMatch, ) = _validate(request);",
                        "        return isTrustedForwarder && active && signerMatch;",
                        "    ) internal view virtual returns (bool isTrustedForwarder, bool active, bool signerMatch, address signer) {",
                        "        (bool isValid, address recovered) = _recoverForwardRequestSigner(request);",
                        "        return (",
                        "            _isTrustedByTarget(request.to),",
                        "            request.deadline >= block.timestamp,",
                        "            isValid && recovered == request.from,",
                        "            recovered",
                        "        );",
                        "     * @dev Returns a tuple with the recovered the signer of an EIP712 forward request message hash",
                        "     * and a boolean indicating if the signature is valid.",
                        "     *",
                        "     * NOTE: The signature is considered valid if {ECDSA-tryRecover} indicates no recover error for it.",
                        "    function _recoverForwardRequestSigner(",
                        "        ForwardRequestData calldata request",
                        "    ) internal view virtual returns (bool, address) {",
                        "        (address recovered, ECDSA.RecoverError err, ) = _hashTypedDataV4(",
                        "            keccak256(",
                        "                abi.encode(",
                        "                    _FORWARD_REQUEST_TYPEHASH,",
                        "                    request.from,",
                        "                    request.to,",
                        "                    request.value,",
                        "                    request.gas,",
                        "                    nonces(request.from),",
                        "                    request.deadline,",
                        "                    keccak256(request.data)",
                        "            )",
                        "        ).tryRecover(request.signature);",
                        "        return (err == ECDSA.RecoverError.NoError, recovered);",
                        "        (bool isTrustedForwarder, bool active, bool signerMatch, address signer) = _validate(request);",
                        "            if (!isTrustedForwarder) {",
                        "                revert ERC2771UntrustfulTarget(request.to, address(this));",
                        "            }",
                        "            if (!active) {",
                        "        if (isTrustedForwarder && signerMatch && active) {",
                        "    /**",
                        "     * @dev Returns whether the target trusts this forwarder.",
                        "     *",
                        "     * This function performs a static call to the target contract calling the",
                        "     * {ERC2771Context-isTrustedForwarder} function.",
                        "     */",
                        "    function _isTrustedByTarget(address target) private view returns (bool) {",
                        "        bytes memory encodedParams = abi.encodeCall(ERC2771Context.isTrustedForwarder, (address(this)));",
                        "        bool success;",
                        "        uint256 returnSize;",
                        "        uint256 returnValue;",
                        "        assembly {",
                        "            success := staticcall(gas(), target, add(encodedParams, 0x20), mload(encodedParams), 0, 0x20)",
                        "            returnSize := returndatasize()",
                        "            returnValue := mload(0)",
                        "        }",
                        "        return success && returnSize >= 0x20 && returnValue > 0;",
                        "    }",
                        "contract CallReceiverMockTrustingForwarder is CallReceiverMock {",
                        "    address private _trustedForwarder;",
                        "    constructor(address trustedForwarder_) {",
                        "        _trustedForwarder = trustedForwarder_;",
                        "    }",
                        "    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {",
                        "        return forwarder == _trustedForwarder;",
                        "    }",
                        "}",
                        "contract UpgradeableBeaconMock is IBeacon {",
                        "    address public implementation;",
                        "    constructor(address impl) {",
                        "        implementation = impl;",
                        "    }",
                        "}",
                        "interface IProxyExposed {",
                        "    function $getBeacon() external view returns (address);",
                        "}",
                        "contract UpgradeableBeaconReentrantMock is IBeacon {",
                        "    error BeaconProxyBeaconSlotAddress(address beacon);",
                        "    function implementation() external view override returns (address) {",
                        "        revert BeaconProxyBeaconSlotAddress(IProxyExposed(msg.sender).$getBeacon());",
                        "    }",
                        "}",
                        "     * @dev Initializes the upgradeable proxy with an initial implementation specified by `implementation`.",
                        "     * If `_data` is nonempty, it's used as data in a delegate call to `implementation`. This will typically be an encoded",
                        "    constructor(address implementation, bytes memory _data) payable {",
                        "        ERC1967Utils.upgradeToAndCall(implementation, _data);",
                        "    function _implementation() internal view virtual override returns (address) {",
                        "     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1.",
                        "     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.",
                        "     * This is the keccak-256 hash of \"eip1967.proxy.beacon\" subtracted by 1.",
                        "        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;",
                        "     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract",
                        "     * if an upgrade doesn't perform an initialization call.",
                        "     * {UpgradeableBeacon} will check that this address is a contract.",
                        "        emit Upgraded(newImplementation);",
                        "     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function",
                        " * NOTE: This proxy does not inherit from {Context} deliberately. The {ProxyAdmin} of this contract won't send a",
                        " * meta-transaction in any way, and any other meta-transaction setup should be made in the implementation contract.",
                        " *",
                        "        ERC1967Utils.changeAdmin(_proxyAdmin());",
                        "    }",
                        "    /**",
                        "     * @dev Returns the admin of this proxy.",
                        "     */",
                        "    function _proxyAdmin() internal virtual returns (address) {",
                        "        return _admin;",
                        "        if (msg.sender == _proxyAdmin()) {",
                        "            if (msg.sig != ITransparentUpgradeableProxy.upgradeToAndCall.selector) {",
                        "            } else {",
                        "                _dispatchUpgradeToAndCall();",
                        "     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function",
                        "     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.",
                        "     *",
                        "     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value",
                        "     * is expected to be the implementation slot in ERC1967.",
                        "     * If `target` reverts with a revert reason or custom error, it is bubbled",
                        "     * up by this function (like regular Solidity function calls). However, if",
                        "     * the call reverted with no returned reason, this function reverts with a",
                        "     * {FailedInnerCall} error.",
                        "        return functionCallWithValue(target, data, 0);",
                        "        return verifyCallResultFromTarget(target, success, returndata);",
                        "        return verifyCallResultFromTarget(target, success, returndata);",
                        "        return verifyCallResultFromTarget(target, success, returndata);",
                        "     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target",
                        "     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an",
                        "     * unsuccessful call.",
                        "        bytes memory returndata",
                        "        if (!success) {",
                        "            _revert(returndata);",
                        "        } else {",
                        "            if (returndata.length == 0 && target.code.length == 0) {",
                        "                revert AddressEmptyCode(target);",
                        "     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the",
                        "     * revert reason or with a default {FailedInnerCall} error.",
                        "    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {",
                        "        if (!success) {",
                        "            _revert(returndata);",
                        "            return returndata;",
                        "     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.",
                        "    function _revert(bytes memory returndata) private pure {",
                        "    bytes16 private constant _HEX_DIGITS = \"0123456789abcdef\";",
                        "                    mstore8(ptr, byte(mod(value, 10), _HEX_DIGITS))",
                        "            buffer[i] = _HEX_DIGITS[localValue & 0xf];",
                        "    CallReceiverMockTrustingForwarder internal _receiver;",
                        "        _receiver = new CallReceiverMockTrustingForwarder(address(_erc2771Forwarder));"
                    ],
                    "del": [
                        "        } else if (timestamp > end()) {",
                        "    constructor(address trustedForwarder) {",
                        "        _trustedForwarder = trustedForwarder;",
                        "        return forwarder == _trustedForwarder;",
                        "     * A transaction is considered valid when it hasn't expired (deadline is not met), and the signer",
                        "     * matches the `from` parameter of the signed request.",
                        "        (bool alive, bool signerMatch, ) = _validate(request);",
                        "        return alive && signerMatch;",
                        "    ) internal view virtual returns (bool alive, bool signerMatch, address signer) {",
                        "        signer = _recoverForwardRequestSigner(request);",
                        "        return (request.deadline >= block.timestamp, signer == request.from, signer);",
                        "     * @dev Recovers the signer of an EIP712 message hash for a forward `request` and its corresponding `signature`.",
                        "     * See {ECDSA-recover}.",
                        "    function _recoverForwardRequestSigner(ForwardRequestData calldata request) internal view virtual returns (address) {",
                        "        return",
                        "            _hashTypedDataV4(",
                        "                keccak256(",
                        "                    abi.encode(",
                        "                        _FORWARD_REQUEST_TYPEHASH,",
                        "                        request.from,",
                        "                        request.to,",
                        "                        request.value,",
                        "                        request.gas,",
                        "                        nonces(request.from),",
                        "                        request.deadline,",
                        "                        keccak256(request.data)",
                        "                    )",
                        "            ).recover(request.signature);",
                        "        (bool alive, bool signerMatch, address signer) = _validate(request);",
                        "            if (!alive) {",
                        "        if (signerMatch && alive) {",
                        "/**",
                        " * @dev A mock to expose `Address`'s functions with function pointers.",
                        " */",
                        "contract AddressFnPointerMock {",
                        "    error CustomRevert();",
                        "    function functionCall(address target, bytes memory data) external returns (bytes memory) {",
                        "        return Address.functionCall(target, data, _customRevert);",
                        "    }",
                        "    function functionCallWithValue(address target, bytes memory data, uint256 value) external returns (bytes memory) {",
                        "        return Address.functionCallWithValue(target, data, value, _customRevert);",
                        "    }",
                        "    function functionStaticCall(address target, bytes memory data) external view returns (bytes memory) {",
                        "        return Address.functionStaticCall(target, data, _customRevert);",
                        "    }",
                        "    function functionDelegateCall(address target, bytes memory data) external returns (bytes memory) {",
                        "        return Address.functionDelegateCall(target, data, _customRevert);",
                        "    }",
                        "    function verifyCallResultFromTarget(",
                        "        address target,",
                        "        bool success,",
                        "        bytes memory returndata",
                        "    ) external view returns (bytes memory) {",
                        "        return Address.verifyCallResultFromTarget(target, success, returndata, _customRevert);",
                        "    }",
                        "    function verifyCallResult(bool success, bytes memory returndata) external view returns (bytes memory) {",
                        "        return Address.verifyCallResult(success, returndata, _customRevert);",
                        "    }",
                        "    function verifyCallResultVoid(bool success, bytes memory returndata) external view returns (bytes memory) {",
                        "        return Address.verifyCallResult(success, returndata, _customRevertVoid);",
                        "    }",
                        "    function _customRevert() internal pure {",
                        "        revert CustomRevert();",
                        "    }",
                        "    function _customRevertVoid() internal pure {}",
                        "}",
                        "contract UpgradeableBeaconMock is IBeacon {",
                        "    address public implementation;",
                        "    constructor(address impl) {",
                        "        implementation = impl;",
                        "    }",
                        "}",
                        "     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.",
                        "     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded",
                        "    constructor(address _logic, bytes memory _data) payable {",
                        "        ERC1967Utils.upgradeToAndCall(_logic, _data);",
                        "    function _implementation() internal view virtual override returns (address impl) {",
                        "     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is",
                        "     * validated in the constructor.",
                        "     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is",
                        "     * validated in the constructor.",
                        "     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1) and is validated in the constructor.",
                        "        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;",
                        "     * @dev Reverts if `msg.value` is not zero.",
                        "        _beforeFallback();",
                        "    /**",
                        "     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`",
                        "     * call, or as part of the Solidity `fallback` or `receive` functions.",
                        "     *",
                        "     * If overridden should call `super._beforeFallback()`.",
                        "     */",
                        "    function _beforeFallback() internal virtual {}",
                        "     * {BeaconProxy} will check that this address is a contract.",
                        "        emit Upgraded(newImplementation);",
                        "     * be the empty byte string if no function should be called, being impossible to invoke the `receive` function",
                        "        ERC1967Utils.changeAdmin(_admin);",
                        "        if (msg.sender == _admin) {",
                        "            if (msg.sig == ITransparentUpgradeableProxy.upgradeToAndCall.selector) {",
                        "                _dispatchUpgradeToAndCall();",
                        "            } else {",
                        "     * be the empty byte string if no function should be called, being impossible to invoke the `receive` function",
                        "     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.",
                        "     * If `target` reverts with a revert reason, it is bubbled up by this",
                        "     * function (like regular Solidity function calls).",
                        "        return functionCallWithValue(target, data, 0, defaultRevert);",
                        "    }",
                        "    /**",
                        "     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with a",
                        "     * `customRevert` function as a fallback when `target` reverts.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `customRevert` must be a reverting function.",
                        "     */",
                        "    function functionCall(",
                        "        address target,",
                        "        bytes memory data,",
                        "        function() internal view customRevert",
                        "    ) internal returns (bytes memory) {",
                        "        return functionCallWithValue(target, data, 0, customRevert);",
                        "        return functionCallWithValue(target, data, value, defaultRevert);",
                        "    }",
                        "    /**",
                        "     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but",
                        "     * with a `customRevert` function as a fallback revert reason when `target` reverts.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `customRevert` must be a reverting function.",
                        "     */",
                        "    function functionCallWithValue(",
                        "        address target,",
                        "        bytes memory data,",
                        "        uint256 value,",
                        "        function() internal view customRevert",
                        "    ) internal returns (bytes memory) {",
                        "        return verifyCallResultFromTarget(target, success, returndata, customRevert);",
                        "        return functionStaticCall(target, data, defaultRevert);",
                        "    }",
                        "    /**",
                        "     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],",
                        "     * but performing a static call.",
                        "     */",
                        "    function functionStaticCall(",
                        "        address target,",
                        "        bytes memory data,",
                        "        function() internal view customRevert",
                        "    ) internal view returns (bytes memory) {",
                        "        return verifyCallResultFromTarget(target, success, returndata, customRevert);",
                        "        return functionDelegateCall(target, data, defaultRevert);",
                        "    }",
                        "    /**",
                        "     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],",
                        "     * but performing a delegate call.",
                        "     */",
                        "    function functionDelegateCall(",
                        "        address target,",
                        "        bytes memory data,",
                        "        function() internal view customRevert",
                        "    ) internal returns (bytes memory) {",
                        "        return verifyCallResultFromTarget(target, success, returndata, customRevert);",
                        "     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling",
                        "     * the revert reason or using the provided `customRevert`) in case of unsuccessful call or if target was not a contract.",
                        "        bytes memory returndata,",
                        "        function() internal view customRevert",
                        "        if (success) {",
                        "            if (returndata.length == 0) {",
                        "                if (target.code.length == 0) {",
                        "                    revert AddressEmptyCode(target);",
                        "                }",
                        "        } else {",
                        "            _revert(returndata, customRevert);",
                        "     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the",
                        "     * revert reason or with a default revert error.",
                        "    function verifyCallResult(bool success, bytes memory returndata) internal view returns (bytes memory) {",
                        "        return verifyCallResult(success, returndata, defaultRevert);",
                        "    }",
                        "    /**",
                        "     * @dev Same as {xref-Address-verifyCallResult-bool-bytes-}[`verifyCallResult`], but with a",
                        "     * `customRevert` function as a fallback when `success` is `false`.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `customRevert` must be a reverting function.",
                        "     */",
                        "    function verifyCallResult(",
                        "        bool success,",
                        "        bytes memory returndata,",
                        "        function() internal view customRevert",
                        "    ) internal view returns (bytes memory) {",
                        "        if (success) {",
                        "            return returndata;",
                        "            _revert(returndata, customRevert);",
                        "     * @dev Default reverting function when no `customRevert` is provided in a function call.",
                        "    function defaultRevert() internal pure {",
                        "        revert FailedInnerCall();",
                        "    }",
                        "    function _revert(bytes memory returndata, function() internal view customRevert) private view {",
                        "            customRevert();",
                        "    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";",
                        "                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))",
                        "            buffer[i] = _SYMBOLS[localValue & 0xf];",
                        "    CallReceiverMock internal _receiver;",
                        "        _receiver = new CallReceiverMock();"
                    ]
                }
            }
        ],
        "- `SafeERC20`: Removed `safePermit` in favor of documentation-only `permit` recommendations. ([#4582](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4582))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4582": {
                    "add": [
                        "     * @inheritdoc IERC20Permit",
                        "     * @inheritdoc IERC20Permit",
                        "     * @inheritdoc IERC20Permit",
                        " *",
                        " * ==== Security Considerations",
                        " *",
                        " * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature",
                        " * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be",
                        " * considered as an intention to spend the allowance in any specific way. The second is that because permits have",
                        " * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should",
                        " * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be",
                        " * generally recommended is:",
                        " *",
                        " * ```solidity",
                        " * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {",
                        " *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}",
                        " *     doThing(..., value);",
                        " * }",
                        " *",
                        " * function doThing(..., uint256 value) public {",
                        " *     token.safeTransferFrom(msg.sender, address(this), value);",
                        " *     ...",
                        " * }",
                        " * ```",
                        " *",
                        " * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of",
                        " * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also",
                        " * {SafeERC20-safeTransferFrom}).",
                        " *",
                        " * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so",
                        " * contracts should have entry points that don't rely on permit.",
                        "     *",
                        "     * CAUTION: See Security Considerations above."
                    ],
                    "del": [
                        "abstract contract ERC20PermitNoRevertMock is ERC20Permit {",
                        "    function permitThatMayRevert(",
                        "        address owner,",
                        "        address spender,",
                        "        uint256 value,",
                        "        uint256 deadline,",
                        "        uint8 v,",
                        "        bytes32 r,",
                        "        bytes32 s",
                        "    ) public virtual {",
                        "        super.permit(owner, spender, value, deadline, v, r, s);",
                        "    }",
                        "    function permit(",
                        "        address owner,",
                        "        address spender,",
                        "        uint256 value,",
                        "        uint256 deadline,",
                        "        uint8 v,",
                        "        bytes32 r,",
                        "        bytes32 s",
                        "    ) public virtual override {",
                        "        try this.permitThatMayRevert(owner, spender, value, deadline, v, r, s) {",
                        "        } catch {",
                        "        }",
                        "    }",
                        "}",
                        "     * @dev See {IERC20Permit-permit}.",
                        "     * @dev See {IERC20Permit-nonces}.",
                        "     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.",
                        "    /**",
                        "     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.",
                        "     * Revert on invalid signature.",
                        "     */",
                        "    function safePermit(",
                        "        IERC20Permit token,",
                        "        address owner,",
                        "        address spender,",
                        "        uint256 value,",
                        "        uint256 deadline,",
                        "        uint8 v,",
                        "        bytes32 r,",
                        "        bytes32 s",
                        "    ) internal {",
                        "        uint256 nonceBefore = token.nonces(owner);",
                        "        token.permit(owner, spender, value, deadline, v, r, s);",
                        "        uint256 nonceAfter = token.nonces(owner);",
                        "        if (nonceAfter != nonceBefore + 1) {",
                        "            revert SafeERC20FailedOperation(address(token));",
                        "        }",
                        "    }"
                    ]
                }
            }
        ],
        "- `Governor`: Optimized use of storage for proposal data ([#4268](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4268))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4268": {
                    "add": [
                        "        uint48 voteStart;",
                        "        uint32 voteDuration;",
                        "        ProposalCore memory proposal = _proposals[proposalId];",
                        "        return _proposals[proposalId].voteStart + _proposals[proposalId].voteDuration;",
                        "        uint256 duration = votingPeriod();",
                        "            voteStart: SafeCast.toUint48(snapshot),",
                        "            voteDuration: SafeCast.toUint32(duration),",
                        "            canceled: false",
                        "            snapshot + duration,",
                        "        uint256 weight = _getVotes(account, proposalSnapshot(proposalId), params);",
                        "     *",
                        "     * NOTE: While this interface returns a uint256, timepoints are stored as uint48 following the ERC-6372 clock type.",
                        "     * Consequently this value must fit in a uint48 (when added to the current clock). See {IERC6372-clock}.",
                        "     *",
                        "     * NOTE: This value is stored when the proposal is submitted so that possible changes to the value do not affect",
                        "     * proposals that have already been submitted. The type used to save it is a uint32. Consequently, while this",
                        "     * interface returns a uint256, the value it returns should fit in a uint32.",
                        "    uint48 private _voteExtension;",
                        "    mapping(uint256 => uint48) private _extendedDeadlines;",
                        "    constructor(uint48 initialVoteExtension) {",
                        "            uint48 extendedDeadline = clock() + lateQuorumVoteExtension();",
                        "    function lateQuorumVoteExtension() public view virtual returns (uint48) {",
                        "    function setLateQuorumVoteExtension(uint48 newVoteExtension) public virtual onlyGovernance {",
                        "    function _setLateQuorumVoteExtension(uint48 newVoteExtension) internal virtual {",
                        "    uint48 private _votingDelay;",
                        "    uint32 private _votingPeriod;",
                        "    constructor(uint48 initialVotingDelay, uint32 initialVotingPeriod, uint256 initialProposalThreshold) {",
                        "    function setVotingDelay(uint48 newVotingDelay) public virtual onlyGovernance {",
                        "    function setVotingPeriod(uint32 newVotingPeriod) public virtual onlyGovernance {",
                        "    function _setVotingDelay(uint48 newVotingDelay) internal virtual {",
                        "    function _setVotingPeriod(uint32 newVotingPeriod) internal virtual {",
                        "    mapping(uint256 => uint256) private _proposalTimelocks;",
                        "        _proposalTimelocks[proposalId] = eta;"
                    ],
                    "del": [
                        "        uint64 voteStart;",
                        "        bytes4 __gap_unused0;",
                        "        uint64 voteEnd;",
                        "        bytes24 __gap_unused1;",
                        "        ProposalCore storage proposal = _proposals[proposalId];",
                        "        return _proposals[proposalId].voteEnd;",
                        "        uint256 deadline = snapshot + votingPeriod();",
                        "            voteStart: SafeCast.toUint64(snapshot),",
                        "            voteEnd: SafeCast.toUint64(deadline),",
                        "            canceled: false,",
                        "            __gap_unused0: 0,",
                        "            __gap_unused1: 0",
                        "            deadline,",
                        "        ProposalCore storage proposal = _proposals[proposalId];",
                        "        uint256 weight = _getVotes(account, proposal.voteStart, params);",
                        "    uint64 private _voteExtension;",
                        "    mapping(uint256 => uint64) private _extendedDeadlines;",
                        "    constructor(uint64 initialVoteExtension) {",
                        "            uint64 extendedDeadline = clock() + lateQuorumVoteExtension();",
                        "    function lateQuorumVoteExtension() public view virtual returns (uint64) {",
                        "    function setLateQuorumVoteExtension(uint64 newVoteExtension) public virtual onlyGovernance {",
                        "    function _setLateQuorumVoteExtension(uint64 newVoteExtension) internal virtual {",
                        "    uint256 private _votingDelay;",
                        "    uint256 private _votingPeriod;",
                        "    constructor(uint256 initialVotingDelay, uint256 initialVotingPeriod, uint256 initialProposalThreshold) {",
                        "    function setVotingDelay(uint256 newVotingDelay) public virtual onlyGovernance {",
                        "    function setVotingPeriod(uint256 newVotingPeriod) public virtual onlyGovernance {",
                        "    function _setVotingDelay(uint256 newVotingDelay) internal virtual {",
                        "    function _setVotingPeriod(uint256 newVotingPeriod) internal virtual {",
                        "    mapping(uint256 => uint64) private _proposalTimelocks;",
                        "        _proposalTimelocks[proposalId] = SafeCast.toUint64(eta);"
                    ]
                }
            }
        ],
        "- `TransparentUpgradeableProxy`: Admin is now stored in an immutable variable (set during construction) to avoid unnecessary storage reads on every proxy call. This removed the ability to ever change the admin. Transfer of the upgrade capability is exclusively handled through the ownership of the `ProxyAdmin`. ([#4354](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4354))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4354": {
                    "add": [
                        "    function unsafeOverrideAdmin(address newAdmin) public {",
                        "        StorageSlot.getAddressSlot(ERC1967Utils.ADMIN_SLOT).value = newAdmin;",
                        "    }",
                        "    function upgradeTo(address) external payable {",
                        " * @dev This contract implements a proxy that is upgradeable by an immutable admin.",
                        " * implementation. If the admin tries to call a function on the implementation it will fail with an error indicating the",
                        " * proxy admin cannot fallback to the target implementation.",
                        " * These properties mean that the admin account can only be used for upgrading the proxy, so it's best if it's a dedicated",
                        " * account that is not used for anything else. This will avoid headaches due to sudden errors when trying to call a function",
                        " * from the proxy implementation.",
                        " * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy, which extends from the",
                        " * {Ownable} contract to allow for changing the proxy's admin owner.",
                        " * IMPORTANT: This contract avoids unnecessary storage reads by setting the admin only during construction as an immutable variable,",
                        " * preventing any changes thereafter. However, the admin slot defined in ERC-1967 can still be overwritten by the implementation",
                        " * logic pointed to by this proxy. In such cases, the contract may end up in an undesirable state where the admin slot is different",
                        " * from the actual admin.",
                        " *",
                        "    address private immutable _admin;",
                        "        _admin = admin_;",
                        "        if (msg.sender == _admin) {"
                    ],
                    "del": [
                        "    function changeAdmin(address) external payable {",
                        "    /**",
                        "     * @dev Changes the admin of `proxy` to `newAdmin`.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - This contract must be the current admin of `proxy`.",
                        "     */",
                        "    function changeProxyAdmin(ITransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {",
                        "        proxy.changeAdmin(newAdmin);",
                        "    }",
                        "    function changeAdmin(address) external;",
                        " * @dev This contract implements a proxy that is upgradeable by an admin.",
                        " * implementation. If the admin tries to call a function on the implementation it will fail with an error that says",
                        " * \"admin cannot fallback to proxy target\".",
                        " * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing",
                        " * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due",
                        " * to sudden errors when trying to call a function from the proxy implementation.",
                        " * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.",
                        "        if (msg.sender == ERC1967Utils.getAdmin()) {",
                        "            } else if (selector == ITransparentUpgradeableProxy.changeAdmin.selector) {",
                        "                ret = _dispatchChangeAdmin();",
                        "    /**",
                        "     * @dev Changes the admin of the proxy.",
                        "     *",
                        "     * Emits an {AdminChanged} event.",
                        "     */",
                        "    function _dispatchChangeAdmin() private returns (bytes memory) {",
                        "        _requireZeroValue();",
                        "        address newAdmin = abi.decode(msg.data[4:], (address));",
                        "        ERC1967Utils.changeAdmin(newAdmin);",
                        "        return \"\";",
                        "    }"
                    ]
                }
            }
        ],
        "- `VestingWallet`: Use `Ownable` instead of an immutable `beneficiary`. ([#4508](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4508))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4508": {
                    "add": [
                        " * @dev A vesting wallet is an ownable contract that can receive native currency and ERC20 tokens, and release these",
                        " * assets to the wallet owner, also referred to as \"beneficiary\", according to a vesting schedule.",
                        " * Any assets transferred to this contract will follow the vesting schedule as if they were locked from the beginning.",
                        " * NOTE: Since the wallet is {Ownable}, and ownership can be transferred, it is possible to sell unvested tokens.",
                        " * Preventing this in a smart contract is difficult, considering that: 1) a beneficiary address could be a",
                        " * counterfactually deployed contract, 2) there is likely to be a migration path for EOAs to become contracts in the",
                        " * near future.",
                        " *",
                        "contract VestingWallet is Context, Ownable {",
                        "     * @dev Sets the sender as the initial owner, the beneficiary as the pending owner, the start timestamp and the",
                        "     * vesting duration of the vesting wallet.",
                        "    constructor(address beneficiary, uint64 startTimestamp, uint64 durationSeconds) payable Ownable(beneficiary) {",
                        "        if (beneficiary == address(0)) {",
                        "        Address.sendValue(payable(owner()), amount);",
                        "        SafeERC20.safeTransfer(IERC20(token), owner(), amount);"
                    ],
                    "del": [
                        " * @title VestingWallet",
                        " * @dev This contract handles the vesting of Eth and ERC20 tokens for a given beneficiary. Custody of multiple tokens",
                        " * can be given to this contract, which will release the token to the beneficiary following a given vesting schedule.",
                        " * The vesting schedule is customizable through the {vestedAmount} function.",
                        " * Any token transferred to this contract will follow the vesting schedule as if they were locked from the beginning.",
                        "contract VestingWallet is Context {",
                        "    address private immutable _beneficiary;",
                        "     * @dev Set the beneficiary, start timestamp and vesting duration of the vesting wallet.",
                        "    constructor(address beneficiaryAddress, uint64 startTimestamp, uint64 durationSeconds) payable {",
                        "        if (beneficiaryAddress == address(0)) {",
                        "        _beneficiary = beneficiaryAddress;",
                        "    /**",
                        "     * @dev Getter for the beneficiary address.",
                        "     */",
                        "    function beneficiary() public view virtual returns (address) {",
                        "        return _beneficiary;",
                        "    }",
                        "        Address.sendValue(payable(beneficiary()), amount);",
                        "        SafeERC20.safeTransfer(IERC20(token), beneficiary(), amount);"
                    ]
                }
            }
        ],
        "- `ERC20`: Remove `Approval` event previously emitted in `transferFrom` to indicate that part of the allowance was consumed. With this change, allowances are no longer reconstructible from events. See the code for guidelines on how to re-enable this event if needed. ([#4370](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4370))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4370": {
                    "add": [
                        "abstract contract ERC20ApprovalMock is ERC20 {",
                        "    function _approve(address owner, address spender, uint256 amount, bool) internal virtual override {",
                        "        super._approve(owner, spender, amount, true);",
                        "    }",
                        "}",
                        "        _approve(owner, spender, amount, true);",
                        "    }",
                        "    /**",
                        "     * @dev Alternative version of {_approve} with an optional flag that can enable or disable the Approval event.",
                        "     *",
                        "     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by",
                        "     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any",
                        "     * `Approval` event during `transferFrom` operations.",
                        "     *",
                        "     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to true",
                        "     * using the following override:",
                        "     * ```",
                        "     * function _approve(address owner, address spender, uint256 amount, bool) internal virtual override {",
                        "     *     super._approve(owner, spender, amount, true);",
                        "     * }",
                        "     * ```",
                        "     *",
                        "     * Requirements are the same as {_approve}.",
                        "     */",
                        "    function _approve(address owner, address spender, uint256 amount, bool emitEvent) internal virtual {",
                        "        if (emitEvent) {",
                        "            emit Approval(owner, spender, amount);",
                        "        }",
                        "                _approve(owner, spender, currentAllowance - amount, false);"
                    ],
                    "del": [
                        "        emit Approval(owner, spender, amount);",
                        "                _approve(owner, spender, currentAllowance - amount);"
                    ]
                }
            }
        ],
        "- Move the logic to validate ERC-1822 during an upgrade from `ERC1967Utils` to `UUPSUpgradeable`. ([#4356](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4356))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4356": {
                    "add": [
                        "contract UUPSUnsupportedProxiableUUID is UUPSUpgradeableMock {",
                        "    function proxiableUUID() external pure override returns (bytes32) {",
                        "        return keccak256(\"invalid UUID\");",
                        "    }",
                        "}",
                        "    /**",
                        "     * @dev The storage `slot` is unsupported as a UUID.",
                        "     */",
                        "    error UUPSUnsupportedProxiableUUID(bytes32 slot);",
                        "        if (",
                        "        ) {",
                        "        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);",
                        "        _upgradeToAndCallUUPS(newImplementation, data, true);",
                        "    /**",
                        "     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.",
                        "     *",
                        "     * Emits an {IERC1967-Upgraded} event.",
                        "     */",
                        "    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) private {",
                        "        try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {",
                        "            if (slot != ERC1967Utils.IMPLEMENTATION_SLOT) {",
                        "                revert UUPSUnsupportedProxiableUUID(slot);",
                        "            }",
                        "            ERC1967Utils.upgradeToAndCall(newImplementation, data, forceCall);",
                        "        } catch {",
                        "            revert ERC1967Utils.ERC1967InvalidImplementation(newImplementation);",
                        "        }",
                        "    }"
                    ],
                    "del": [
                        "contract UUPSUpgradeableLegacyMock is UUPSUpgradeableMock {",
                        "    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;",
                        "    function __setImplementation(address newImplementation) private {",
                        "        require(newImplementation.code.length > 0, \"ERC1967: new implementation is not a contract\");",
                        "        StorageSlot.getAddressSlot(ERC1967Utils.IMPLEMENTATION_SLOT).value = newImplementation;",
                        "    }",
                        "    function _upgradeToAndCallSecureLegacyV1(address newImplementation, bytes memory data, bool forceCall) internal {",
                        "        address oldImplementation = ERC1967Utils.getImplementation();",
                        "        __setImplementation(newImplementation);",
                        "        if (data.length > 0 || forceCall) {",
                        "            Address.functionDelegateCall(newImplementation, data);",
                        "        }",
                        "        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);",
                        "        if (!rollbackTesting.value) {",
                        "            rollbackTesting.value = true;",
                        "            Address.functionDelegateCall(newImplementation, abi.encodeCall(this.upgradeTo, (oldImplementation)));",
                        "            rollbackTesting.value = false;",
                        "            require(",
                        "                oldImplementation == ERC1967Utils.getImplementation(),",
                        "                \"ERC1967Utils: upgrade breaks further upgrades\"",
                        "            );",
                        "            ERC1967Utils.upgradeTo(newImplementation);",
                        "        }",
                        "    }",
                        "    function upgradeTo(address newImplementation) public override {",
                        "        _upgradeToAndCallSecureLegacyV1(newImplementation, bytes(\"\"), false);",
                        "    }",
                        "    function upgradeToAndCall(address newImplementation, bytes memory data) public payable override {",
                        "        _upgradeToAndCallSecureLegacyV1(newImplementation, data, false);",
                        "    }",
                        "}",
                        "    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;",
                        "    /**",
                        "     * @dev The storage `slot` is unsupported as a UUID.",
                        "     */",
                        "    error ERC1967UnsupportedProxiableUUID(bytes32 slot);",
                        "    /**",
                        "     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.",
                        "     *",
                        "     * Emits an {IERC1967-Upgraded} event.",
                        "     */",
                        "    function upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {",
                        "        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {",
                        "            _setImplementation(newImplementation);",
                        "        } else {",
                        "            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {",
                        "                if (slot != IMPLEMENTATION_SLOT) {",
                        "                    revert ERC1967UnsupportedProxiableUUID(slot);",
                        "                }",
                        "            } catch {",
                        "                revert ERC1967InvalidImplementation(newImplementation);",
                        "            }",
                        "            upgradeToAndCall(newImplementation, data, forceCall);",
                        "        }",
                        "    }",
                        "        if (address(this) == __self) {",
                        "            revert UUPSUnauthorizedCallContext();",
                        "        }",
                        "        if (ERC1967Utils.getImplementation() != __self) {",
                        "        ERC1967Utils.upgradeToAndCallUUPS(newImplementation, new bytes(0), false);",
                        "        ERC1967Utils.upgradeToAndCallUUPS(newImplementation, data, true);"
                    ]
                }
            }
        ],
        "- Replace revert strings and require statements with custom errors. ([#4261](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4261))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4261": {
                    "add": [
                        "            revert AccessControlUnauthorizedAccount(account, role);",
                        "     * - the caller must be `callerConfirmation`.",
                        "    function renounceRole(bytes32 role, address callerConfirmation) public virtual {",
                        "        if (callerConfirmation != _msgSender()) {",
                        "            revert AccessControlBadConfirmation();",
                        "        }",
                        "        _revokeRole(role, callerConfirmation);",
                        "        if (initialDefaultAdmin == address(0)) {",
                        "            revert AccessControlInvalidDefaultAdmin(address(0));",
                        "        }",
                        "        if (role == DEFAULT_ADMIN_ROLE) {",
                        "            revert AccessControlEnforcedDefaultAdminRules();",
                        "        }",
                        "        if (role == DEFAULT_ADMIN_ROLE) {",
                        "            revert AccessControlEnforcedDefaultAdminRules();",
                        "        }",
                        "            if (newDefaultAdmin != address(0) || !_isScheduleSet(schedule) || !_hasSchedulePassed(schedule)) {",
                        "                revert AccessControlEnforcedDefaultAdminDelay(schedule);",
                        "            }",
                        "            if (defaultAdmin() != address(0)) {",
                        "                revert AccessControlEnforcedDefaultAdminRules();",
                        "            }",
                        "        if (role == DEFAULT_ADMIN_ROLE) {",
                        "            revert AccessControlEnforcedDefaultAdminRules();",
                        "        }",
                        "        if (_msgSender() != newDefaultAdmin) {",
                        "            revert AccessControlInvalidDefaultAdmin(_msgSender());",
                        "        }",
                        "        if (!_isScheduleSet(schedule) || !_hasSchedulePassed(schedule)) {",
                        "            revert AccessControlEnforcedDefaultAdminDelay(schedule);",
                        "        }",
                        "    /**",
                        "     * @dev The `account` is missing a role.",
                        "     */",
                        "    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);",
                        "    /**",
                        "     * @dev The caller of a function is not the expected one.",
                        "     *",
                        "     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.",
                        "     */",
                        "    error AccessControlBadConfirmation();",
                        "     * - the caller must be `callerConfirmation`.",
                        "    function renounceRole(bytes32 role, address callerConfirmation) external;",
                        "    /**",
                        "     * @dev The new default admin is not a valid default admin.",
                        "     */",
                        "    error AccessControlInvalidDefaultAdmin(address defaultAdmin);",
                        "    /**",
                        "     * @dev At least one of the following rules was violated:",
                        "     *",
                        "     * - The `DEFAULT_ADMIN_ROLE` must only be managed by itself.",
                        "     * - The `DEFAULT_ADMIN_ROLE` must only be held by one account at the time.",
                        "     * - Any `DEFAULT_ADMIN_ROLE` transfer must be in two delayed steps.",
                        "     */",
                        "    error AccessControlEnforcedDefaultAdminRules();",
                        "    /**",
                        "     * @dev The delay for transferring the default admin delay is enforced and",
                        "     * the operation must wait until `schedule`.",
                        "     *",
                        "     * NOTE: `schedule` can be 0 indicating there's no transfer scheduled.",
                        "     */",
                        "    error AccessControlEnforcedDefaultAdminDelay(uint48 schedule);",
                        "    /**",
                        "     * @dev The caller account is not authorized to perform an operation.",
                        "     */",
                        "    error OwnableUnauthorizedAccount(address account);",
                        "    /**",
                        "     * @dev The owner is not a valid owner account. (eg. `address(0)`)",
                        "     */",
                        "    error OwnableInvalidOwner(address owner);",
                        "        if (owner() != _msgSender()) {",
                        "            revert OwnableUnauthorizedAccount(_msgSender());",
                        "        }",
                        "        if (newOwner == address(0)) {",
                        "            revert OwnableInvalidOwner(address(0));",
                        "        }",
                        "        if (pendingOwner() != sender) {",
                        "            revert OwnableUnauthorizedAccount(sender);",
                        "        }",
                        "    /**",
                        "     * @dev The `beneficiary` is not a valid account.",
                        "     */",
                        "    error VestingWalletInvalidBeneficiary(address beneficiary);",
                        "        if (beneficiaryAddress == address(0)) {",
                        "            revert VestingWalletInvalidBeneficiary(address(0));",
                        "        }",
                        "    bytes32 private constant _ALL_PROPOSAL_STATES_BITMAP = bytes32((2 ** (uint8(type(ProposalState).max) + 1)) - 1);",
                        "        if (_msgSender() != _executor()) {",
                        "            revert GovernorOnlyExecutor(_msgSender());",
                        "        }",
                        "        if (_executor() != address(this)) {",
                        "            revert GovernorDisabledDeposit();",
                        "        }",
                        "            revert GovernorNonexistentProposal(proposalId);",
                        "        {",
                        "            uint256 proposerVotes = getVotes(proposer, currentTimepoint - 1);",
                        "            uint256 votesThreshold = proposalThreshold();",
                        "            if (proposerVotes < votesThreshold) {",
                        "                revert GovernorInsufficientProposerVotes(proposer, proposerVotes, votesThreshold);",
                        "            }",
                        "        }",
                        "        if (targets.length != values.length || targets.length != calldatas.length || targets.length == 0) {",
                        "            revert GovernorInvalidProposalLength(targets.length, calldatas.length, values.length);",
                        "        }",
                        "        if (_proposals[proposalId].voteStart != 0) {",
                        "            revert GovernorUnexpectedProposalState(proposalId, state(proposalId), bytes32(0));",
                        "        }",
                        "        if (currentState != ProposalState.Succeeded && currentState != ProposalState.Queued) {",
                        "            revert GovernorUnexpectedProposalState(",
                        "                proposalId,",
                        "                currentState,",
                        "                _encodeStateBitmap(ProposalState.Succeeded) | _encodeStateBitmap(ProposalState.Queued)",
                        "            );",
                        "        }",
                        "        ProposalState currentState = state(proposalId);",
                        "        if (currentState != ProposalState.Pending) {",
                        "            revert GovernorUnexpectedProposalState(proposalId, currentState, _encodeStateBitmap(ProposalState.Pending));",
                        "        }",
                        "        if (_msgSender() != proposalProposer(proposalId)) {",
                        "            revert GovernorOnlyProposer(_msgSender());",
                        "        }",
                        "            Address.verifyCallResult(success, returndata);",
                        "        bytes32 forbiddenStates = _encodeStateBitmap(ProposalState.Canceled) |",
                        "            _encodeStateBitmap(ProposalState.Expired) |",
                        "            _encodeStateBitmap(ProposalState.Executed);",
                        "        if (forbiddenStates & _encodeStateBitmap(currentState) != 0) {",
                        "            revert GovernorUnexpectedProposalState(",
                        "                proposalId,",
                        "                currentState,",
                        "                _ALL_PROPOSAL_STATES_BITMAP ^ forbiddenStates",
                        "            );",
                        "        }",
                        "        ProposalState currentState = state(proposalId);",
                        "        if (currentState != ProposalState.Active) {",
                        "            revert GovernorUnexpectedProposalState(proposalId, currentState, _encodeStateBitmap(ProposalState.Active));",
                        "        }",
                        "        Address.verifyCallResult(success, returndata);",
                        "     * @dev Encodes a `ProposalState` into a `bytes32` representation where each bit enabled corresponds to",
                        "     * the underlying position in the `ProposalState` enum. For example:",
                        "     *",
                        "     * 0x000...10000",
                        "     *   ^^^^^^------ ...",
                        "     *         ^----- Succeeded",
                        "     *          ^---- Defeated",
                        "     *           ^--- Canceled",
                        "     *            ^-- Active",
                        "     *             ^- Pending",
                        "     */",
                        "    function _encodeStateBitmap(ProposalState proposalState) internal pure returns (bytes32) {",
                        "        return bytes32(1 << uint8(proposalState));",
                        "    }",
                        "    /*",
                        "    /**",
                        "     * @dev Empty proposal or a mismatch between the parameters length for a proposal call.",
                        "     */",
                        "    error GovernorInvalidProposalLength(uint256 targets, uint256 calldatas, uint256 values);",
                        "    /**",
                        "     * @dev The vote was already cast.",
                        "     */",
                        "    error GovernorAlreadyCastVote(address voter);",
                        "    /**",
                        "     * @dev Token deposits are disabled in this contract.",
                        "     */",
                        "    error GovernorDisabledDeposit();",
                        "    /**",
                        "     * @dev The `account` is not a proposer.",
                        "     */",
                        "    error GovernorOnlyProposer(address account);",
                        "    /**",
                        "     * @dev The `account` is not the governance executor.",
                        "     */",
                        "    error GovernorOnlyExecutor(address account);",
                        "    /**",
                        "     * @dev The `proposalId` doesn't exist.",
                        "     */",
                        "    error GovernorNonexistentProposal(uint256 proposalId);",
                        "    /**",
                        "     * @dev The current state of a proposal is not the required for performing an operation.",
                        "     * The `expectedStates` is a bitmap with the bits enabled for each ProposalState enum position",
                        "     * counting from right to left.",
                        "     *",
                        "     * NOTE: If `expectedState` is `bytes32(0)`, the proposal is expected to not be in any state (i.e. not exist).",
                        "     * This is the case when a proposal that is expected to be unset is already initiated (the proposal is duplicated).",
                        "     *",
                        "     * See {Governor-_encodeStateBitmap}.",
                        "     */",
                        "    error GovernorUnexpectedProposalState(uint256 proposalId, ProposalState current, bytes32 expectedStates);",
                        "    /**",
                        "     * @dev The voting period set is not a valid period.",
                        "     */",
                        "    error GovernorInvalidVotingPeriod(uint256 votingPeriod);",
                        "    /**",
                        "     * @dev The `proposer` does not have the required votes to operate on a proposal.",
                        "     */",
                        "    error GovernorInsufficientProposerVotes(address proposer, uint256 votes, uint256 threshold);",
                        "    /**",
                        "     * @dev The vote type used is not valid for the corresponding counting module.",
                        "     */",
                        "    error GovernorInvalidVoteType();",
                        "    enum OperationState {",
                        "        Unset,",
                        "        Pending,",
                        "        Ready,",
                        "        Done",
                        "    }",
                        "    /**",
                        "     * @dev Mismatch between the parameters length for an operation call.",
                        "     */",
                        "    error TimelockInvalidOperationLength(uint256 targets, uint256 payloads, uint256 values);",
                        "    /**",
                        "     * @dev The schedule operation doesn't meet the minimum delay.",
                        "     */",
                        "    error TimelockInsufficientDelay(uint256 delay, uint256 minDelay);",
                        "    /**",
                        "     * @dev The current state of an operation is not as required.",
                        "     */",
                        "    error TimelockUnexpectedOperationState(bytes32 operationId, OperationState expected);",
                        "    /**",
                        "     * @dev The predecessor to an operation not yet done.",
                        "     */",
                        "    error TimelockUnexecutedPredecessor(bytes32 predecessorId);",
                        "    /**",
                        "     * @dev The caller account is not authorized.",
                        "     */",
                        "    error TimelockUnauthorizedCaller(address caller);",
                        "        if (targets.length != values.length || targets.length != payloads.length) {",
                        "            revert TimelockInvalidOperationLength(targets.length, payloads.length, values.length);",
                        "        }",
                        "        if (isOperation(id)) {",
                        "            revert TimelockUnexpectedOperationState(id, OperationState.Unset);",
                        "        }",
                        "        uint256 minDelay = getMinDelay();",
                        "        if (delay < minDelay) {",
                        "            revert TimelockInsufficientDelay(delay, minDelay);",
                        "        }",
                        "        if (!isOperationPending(id)) {",
                        "            revert TimelockUnexpectedOperationState(id, OperationState.Pending);",
                        "        }",
                        "        if (targets.length != values.length || targets.length != payloads.length) {",
                        "            revert TimelockInvalidOperationLength(targets.length, payloads.length, values.length);",
                        "        }",
                        "        (bool success, bytes memory returndata) = target.call{value: value}(data);",
                        "        Address.verifyCallResult(success, returndata);",
                        "        if (!isOperationReady(id)) {",
                        "            revert TimelockUnexpectedOperationState(id, OperationState.Ready);",
                        "        }",
                        "        if (predecessor != bytes32(0) && !isOperationDone(predecessor)) {",
                        "            revert TimelockUnexecutedPredecessor(predecessor);",
                        "        }",
                        "        if (!isOperationReady(id)) {",
                        "            revert TimelockUnexpectedOperationState(id, OperationState.Ready);",
                        "        }",
                        "        if (msg.sender != address(this)) {",
                        "            revert TimelockUnauthorizedCaller(msg.sender);",
                        "        }",
                        "        if (signatures.length != calldatas.length) {",
                        "            revert GovernorInvalidSignaturesLength(signatures.length, calldatas.length);",
                        "        }",
                        "        uint256 proposerVotes = getVotes(proposer, clock() - 1);",
                        "        uint256 votesThreshold = proposalThreshold();",
                        "        if (_msgSender() != proposer && proposerVotes >= votesThreshold) {",
                        "            revert GovernorInsufficientProposerVotes(proposer, proposerVotes, votesThreshold);",
                        "        }",
                        "        if (receipt.hasVoted) {",
                        "            revert GovernorAlreadyCastVote(account);",
                        "        }",
                        "            revert GovernorInvalidVoteType();",
                        "    /**",
                        "     * @dev Mismatch between the parameters length for a proposal call.",
                        "     */",
                        "    error GovernorInvalidSignaturesLength(uint256 signatures, uint256 calldatas);",
                        "        if (proposalVote.hasVoted[account]) {",
                        "            revert GovernorAlreadyCastVote(account);",
                        "        }",
                        "            revert GovernorInvalidVoteType();",
                        "        if (newVotingPeriod == 0) {",
                        "            revert GovernorInvalidVotingPeriod(0);",
                        "        }",
                        "        ProposalState currentState = state(proposalId);",
                        "        if (currentState != ProposalState.Succeeded) {",
                        "            revert GovernorUnexpectedProposalState(",
                        "                proposalId,",
                        "                currentState,",
                        "                _encodeStateBitmap(ProposalState.Succeeded)",
                        "            );",
                        "        }",
                        "            if (_timelock.queuedTransactions(keccak256(abi.encode(targets[i], values[i], \"\", calldatas[i], eta)))) {",
                        "                revert GovernorAlreadyQueuedProposal(proposalId);",
                        "            }",
                        "        if (eta == 0) {",
                        "            revert GovernorNotQueuedProposal(proposalId);",
                        "        }",
                        "        ProposalState currentState = state(proposalId);",
                        "        if (currentState != ProposalState.Succeeded) {",
                        "            revert GovernorUnexpectedProposalState(",
                        "                proposalId,",
                        "                currentState,",
                        "                _encodeStateBitmap(ProposalState.Succeeded)",
                        "            );",
                        "        }",
                        "    /**",
                        "     * @dev The quorum set is not a valid fraction.",
                        "     */",
                        "    error GovernorInvalidQuorumFraction(uint256 quorumNumerator, uint256 quorumDenominator);",
                        "        uint256 denominator = quorumDenominator();",
                        "        if (newQuorumNumerator > denominator) {",
                        "            revert GovernorInvalidQuorumFraction(newQuorumNumerator, denominator);",
                        "        }",
                        "    /**",
                        "     * @dev The proposal hasn't been queued yet.",
                        "     */",
                        "    error GovernorNotQueuedProposal(uint256 proposalId);",
                        "    /**",
                        "     * @dev The proposal has already been queued.",
                        "     */",
                        "    error GovernorAlreadyQueuedProposal(uint256 proposalId);",
                        "    /**",
                        "     * @dev The signature used has expired.",
                        "     */",
                        "    error VotesExpiredSignature(uint256 expiry);",
                        "    /**",
                        "     * @dev The clock was incorrectly modified.",
                        "     */",
                        "    error ERC6372InconsistentClock();",
                        "    /**",
                        "     * @dev Lookup to future votes is not available.",
                        "     */",
                        "    error ERC5805FutureLookup(uint256 timepoint, uint48 clock);",
                        "        if (clock() != block.number) {",
                        "            revert ERC6372InconsistentClock();",
                        "        }",
                        "        uint48 currentTimepoint = clock();",
                        "        if (timepoint >= currentTimepoint) {",
                        "            revert ERC5805FutureLookup(timepoint, currentTimepoint);",
                        "        }",
                        "        uint48 currentTimepoint = clock();",
                        "        if (timepoint >= currentTimepoint) {",
                        "            revert ERC5805FutureLookup(timepoint, currentTimepoint);",
                        "        }",
                        "        if (block.timestamp > expiry) {",
                        "            revert VotesExpiredSignature(expiry);",
                        "        }",
                        "        _useCheckedNonce(signer, nonce);",
                        "/**",
                        " * @dev Standard ERC20 Errors",
                        " * Interface of the ERC6093 custom errors for ERC20 tokens",
                        " * as defined in https://eips.ethereum.org/EIPS/eip-6093",
                        " */",
                        "interface IERC20Errors {",
                        "    /**",
                        "     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.",
                        "     * @param sender Address whose tokens are being transferred.",
                        "     * @param balance Current balance for the interacting account.",
                        "     * @param needed Minimum amount required to perform a transfer.",
                        "     */",
                        "    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);",
                        "    /**",
                        "     * @dev Indicates a failure with the token `sender`. Used in transfers.",
                        "     * @param sender Address whose tokens are being transferred.",
                        "     */",
                        "    error ERC20InvalidSender(address sender);",
                        "    /**",
                        "     * @dev Indicates a failure with the token `receiver`. Used in transfers.",
                        "     * @param receiver Address to which tokens are being transferred.",
                        "     */",
                        "    error ERC20InvalidReceiver(address receiver);",
                        "    /**",
                        "     * @dev Indicates a failure with the `spender`\u2019s `allowance`. Used in transfers.",
                        "     * @param spender Address that may be allowed to operate on tokens without being their owner.",
                        "     * @param allowance Amount of tokens a `spender` is allowed to operate with.",
                        "     * @param needed Minimum amount required to perform a transfer.",
                        "     */",
                        "    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);",
                        "    /**",
                        "     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.",
                        "     * @param approver Address initiating an approval operation.",
                        "     */",
                        "    error ERC20InvalidApprover(address approver);",
                        "    /**",
                        "     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.",
                        "     * @param spender Address that may be allowed to operate on tokens without being their owner.",
                        "     */",
                        "    error ERC20InvalidSpender(address spender);",
                        "}",
                        "/**",
                        " * @dev Standard ERC721 Errors",
                        " * Interface of the ERC6093 custom errors for ERC721 tokens",
                        " * as defined in https://eips.ethereum.org/EIPS/eip-6093",
                        " */",
                        "interface IERC721Errors {",
                        "    /**",
                        "     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.",
                        "     * Used in balance queries.",
                        "     * @param owner Address of the current owner of a token.",
                        "     */",
                        "    error ERC721InvalidOwner(address owner);",
                        "    /**",
                        "     * @dev Indicates a `tokenId` whose `owner` is the zero address.",
                        "     * @param tokenId Identifier number of a token.",
                        "     */",
                        "    error ERC721NonexistentToken(uint256 tokenId);",
                        "    /**",
                        "     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.",
                        "     * @param sender Address whose tokens are being transferred.",
                        "     * @param tokenId Identifier number of a token.",
                        "     * @param owner Address of the current owner of a token.",
                        "     */",
                        "    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);",
                        "    /**",
                        "     * @dev Indicates a failure with the token `sender`. Used in transfers.",
                        "     * @param sender Address whose tokens are being transferred.",
                        "     */",
                        "    error ERC721InvalidSender(address sender);",
                        "    /**",
                        "     * @dev Indicates a failure with the token `receiver`. Used in transfers.",
                        "     * @param receiver Address to which tokens are being transferred.",
                        "     */",
                        "    error ERC721InvalidReceiver(address receiver);",
                        "    /**",
                        "     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.",
                        "     * @param operator Address that may be allowed to operate on tokens without being their owner.",
                        "     * @param tokenId Identifier number of a token.",
                        "     */",
                        "    error ERC721InsufficientApproval(address operator, uint256 tokenId);",
                        "    /**",
                        "     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.",
                        "     * @param approver Address initiating an approval operation.",
                        "     */",
                        "    error ERC721InvalidApprover(address approver);",
                        "    /**",
                        "     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.",
                        "     * @param operator Address that may be allowed to operate on tokens without being their owner.",
                        "     */",
                        "    error ERC721InvalidOperator(address operator);",
                        "}",
                        "/**",
                        " * @dev Standard ERC1155 Errors",
                        " * Interface of the ERC6093 custom errors for ERC1155 tokens",
                        " * as defined in https://eips.ethereum.org/EIPS/eip-6093",
                        " */",
                        "interface IERC1155Errors {",
                        "    /**",
                        "     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.",
                        "     * @param sender Address whose tokens are being transferred.",
                        "     * @param balance Current balance for the interacting account.",
                        "     * @param needed Minimum amount required to perform a transfer.",
                        "     */",
                        "    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);",
                        "    /**",
                        "     * @dev Indicates a failure with the token `sender`. Used in transfers.",
                        "     * @param sender Address whose tokens are being transferred.",
                        "     */",
                        "    error ERC1155InvalidSender(address sender);",
                        "    /**",
                        "     * @dev Indicates a failure with the token `receiver`. Used in transfers.",
                        "     * @param receiver Address to which tokens are being transferred.",
                        "     */",
                        "    error ERC1155InvalidReceiver(address receiver);",
                        "    /**",
                        "     * @dev Indicates a failure with the `operator`\u2019s approval. Used in transfers.",
                        "     * @param operator Address that may be allowed to operate on tokens without being their owner.",
                        "     * @param owner Address of the current owner of a token.",
                        "     */",
                        "    error ERC1155InsufficientApprovalForAll(address operator, address owner);",
                        "    /**",
                        "     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.",
                        "     * @param approver Address initiating an approval operation.",
                        "     */",
                        "    error ERC1155InvalidApprover(address approver);",
                        "    /**",
                        "     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.",
                        "     * @param operator Address that may be allowed to operate on tokens without being their owner.",
                        "     */",
                        "    error ERC1155InvalidOperator(address operator);",
                        "    /**",
                        "     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.",
                        "     * Used in batch transfers.",
                        "     * @param idsLength Length of the array of token identifiers",
                        "     * @param valuesLength Length of the array of token amounts",
                        "     */",
                        "    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);",
                        "}",
                        "    /**",
                        "     * @dev The request `from` doesn't match with the recovered `signer`.",
                        "     */",
                        "    error MinimalForwarderInvalidSigner(address signer, address from);",
                        "    /**",
                        "     * @dev The request nonce doesn't match with the `current` nonce for the request signer.",
                        "     */",
                        "    error MinimalForwarderInvalidNonce(address signer, uint256 current);",
                        "        address signer = _recover(req, signature);",
                        "        (bool correctFrom, bool correctNonce) = _validateReq(req, signer);",
                        "        return correctFrom && correctNonce;",
                        "        address signer = _recover(req, signature);",
                        "        (bool correctFrom, bool correctNonce) = _validateReq(req, signer);",
                        "        if (!correctFrom) {",
                        "            revert MinimalForwarderInvalidSigner(signer, req.from);",
                        "        }",
                        "        if (!correctNonce) {",
                        "            revert MinimalForwarderInvalidNonce(signer, _nonces[req.from]);",
                        "        }",
                        "    function _recover(ForwardRequest calldata req, bytes calldata signature) internal view returns (address) {",
                        "        return",
                        "            _hashTypedDataV4(",
                        "                keccak256(abi.encode(_TYPEHASH, req.from, req.to, req.value, req.gas, req.nonce, keccak256(req.data)))",
                        "            ).recover(signature);",
                        "    }",
                        "    function _validateReq(",
                        "        ForwardRequest calldata req,",
                        "        address signer",
                        "    ) internal view returns (bool correctFrom, bool correctNonce) {",
                        "        return (signer == req.from, _nonces[req.from] == req.nonce);",
                        "    }",
                        "/**",
                        " * @dev A mock to expose `Address`'s functions with function pointers.",
                        " */",
                        "contract AddressFnPointerMock {",
                        "    error CustomRevert();",
                        "    function functionCall(address target, bytes memory data) external returns (bytes memory) {",
                        "        return Address.functionCall(target, data, _customRevert);",
                        "    }",
                        "    function functionCallWithValue(address target, bytes memory data, uint256 value) external returns (bytes memory) {",
                        "        return Address.functionCallWithValue(target, data, value, _customRevert);",
                        "    }",
                        "    function functionStaticCall(address target, bytes memory data) external view returns (bytes memory) {",
                        "        return Address.functionStaticCall(target, data, _customRevert);",
                        "    }",
                        "    function functionDelegateCall(address target, bytes memory data) external returns (bytes memory) {",
                        "        return Address.functionDelegateCall(target, data, _customRevert);",
                        "    }",
                        "    function verifyCallResultFromTarget(",
                        "        address target,",
                        "        bool success,",
                        "        bytes memory returndata",
                        "    ) external view returns (bytes memory) {",
                        "        return Address.verifyCallResultFromTarget(target, success, returndata, _customRevert);",
                        "    }",
                        "    function verifyCallResult(bool success, bytes memory returndata) external view returns (bytes memory) {",
                        "        return Address.verifyCallResult(success, returndata, _customRevert);",
                        "    }",
                        "    function verifyCallResultVoid(bool success, bytes memory returndata) external view returns (bytes memory) {",
                        "        return Address.verifyCallResult(success, returndata, _customRevertVoid);",
                        "    }",
                        "    function _customRevert() internal pure {",
                        "        revert CustomRevert();",
                        "    }",
                        "    function _customRevertVoid() internal pure {}",
                        "}",
                        "    /**",
                        "     * @dev A clone instance deployment failed.",
                        "     */",
                        "    error ERC1167FailedCreateClone();",
                        "        if (instance == address(0)) {",
                        "            revert ERC1167FailedCreateClone();",
                        "        }",
                        "        if (instance == address(0)) {",
                        "            revert ERC1167FailedCreateClone();",
                        "        }",
                        "    /**",
                        "     * @dev The `implementation` of the proxy is invalid.",
                        "     */",
                        "    error ERC1967InvalidImplementation(address implementation);",
                        "    /**",
                        "     * @dev The `admin` of the proxy is invalid.",
                        "     */",
                        "    error ERC1967InvalidAdmin(address admin);",
                        "    /**",
                        "     * @dev The `beacon` of the proxy is invalid.",
                        "     */",
                        "    error ERC1967InvalidBeacon(address beacon);",
                        "    /**",
                        "     * @dev The storage `slot` is unsupported as a UUID.",
                        "     */",
                        "    error ERC1967UnsupportedProxiableUUID(bytes32 slot);",
                        "        if (newImplementation.code.length == 0) {",
                        "            revert ERC1967InvalidImplementation(newImplementation);",
                        "        }",
                        "                if (slot != _IMPLEMENTATION_SLOT) {",
                        "                    revert ERC1967UnsupportedProxiableUUID(slot);",
                        "                }",
                        "                revert ERC1967InvalidImplementation(newImplementation);",
                        "        if (newAdmin == address(0)) {",
                        "            revert ERC1967InvalidAdmin(address(0));",
                        "        }",
                        "        if (newBeacon.code.length == 0) {",
                        "            revert ERC1967InvalidBeacon(newBeacon);",
                        "        }",
                        "        address beaconImplementation = IBeacon(newBeacon).implementation();",
                        "        if (beaconImplementation.code.length == 0) {",
                        "            revert ERC1967InvalidImplementation(beaconImplementation);",
                        "        }",
                        "    /**",
                        "     * @dev The `implementation` of the beacon is invalid.",
                        "     */",
                        "    error BeaconInvalidImplementation(address implementation);",
                        "        if (newImplementation.code.length == 0) {",
                        "            revert BeaconInvalidImplementation(newImplementation);",
                        "        }",
                        "    /**",
                        "     * @dev The proxy caller is the current admin, and can't fallback to the proxy target.",
                        "     */",
                        "    error ProxyDeniedAdminAccess();",
                        "    /**",
                        "     * @dev msg.value is not 0.",
                        "     */",
                        "    error ProxyNonPayableFunction();",
                        "                revert ProxyDeniedAdminAccess();",
                        "        if (msg.value != 0) {",
                        "            revert ProxyNonPayableFunction();",
                        "        }",
                        "    /**",
                        "     * @dev The contract is already initialized.",
                        "     */",
                        "    error AlreadyInitialized();",
                        "    /**",
                        "     * @dev The contract is not initializing.",
                        "     */",
                        "    error NotInitializing();",
                        "        if (!(isTopLevelCall && _initialized < 1) && !(address(this).code.length == 0 && _initialized == 1)) {",
                        "            revert AlreadyInitialized();",
                        "        }",
                        "        if (_initializing || _initialized >= version) {",
                        "            revert AlreadyInitialized();",
                        "        }",
                        "        if (!_initializing) {",
                        "            revert NotInitializing();",
                        "        }",
                        "        if (_initializing) {",
                        "            revert AlreadyInitialized();",
                        "        }",
                        "    /**",
                        "     * @dev The call is from an unauthorized context.",
                        "     */",
                        "    error UUPSUnauthorizedCallContext();",
                        "        if (address(this) == __self) {",
                        "            revert UUPSUnauthorizedCallContext();",
                        "        }",
                        "        if (_getImplementation() != __self) {",
                        "            revert UUPSUnauthorizedCallContext();",
                        "        }",
                        "        if (address(this) != __self) {",
                        "            revert UUPSUnauthorizedCallContext();",
                        "        }",
                        "    bool private _paused;",
                        "    /**",
                        "     * @dev The operation failed because the contract is paused.",
                        "     */",
                        "    error EnforcedPause();",
                        "    /**",
                        "     * @dev The operation failed because the contract is not paused.",
                        "     */",
                        "    error ExpectedPause();",
                        "        if (paused()) {",
                        "            revert EnforcedPause();",
                        "        }",
                        "        if (!paused()) {",
                        "            revert ExpectedPause();",
                        "        }",
                        "    /**",
                        "     * @dev Unauthorized reentrant call.",
                        "     */",
                        "    error ReentrancyGuardReentrantCall();",
                        "        if (_status == _ENTERED) {",
                        "            revert ReentrancyGuardReentrantCall();",
                        "        }",
                        "contract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI, IERC1155Errors {",
                        "        if (accounts.length != ids.length) {",
                        "            revert ERC1155InvalidArrayLength(ids.length, accounts.length);",
                        "        }",
                        "        if (from != _msgSender() && !isApprovedForAll(from, _msgSender())) {",
                        "            revert ERC1155InsufficientApprovalForAll(_msgSender(), from);",
                        "        }",
                        "        if (from != _msgSender() && !isApprovedForAll(from, _msgSender())) {",
                        "            revert ERC1155InsufficientApprovalForAll(_msgSender(), from);",
                        "        }",
                        "        if (ids.length != amounts.length) {",
                        "            revert ERC1155InvalidArrayLength(ids.length, amounts.length);",
                        "        }",
                        "                if (fromBalance < amount) {",
                        "                    revert ERC1155InsufficientBalance(from, fromBalance, amount, id);",
                        "                }",
                        "        if (to == address(0)) {",
                        "            revert ERC1155InvalidReceiver(address(0));",
                        "        }",
                        "        if (from == address(0)) {",
                        "            revert ERC1155InvalidSender(address(0));",
                        "        }",
                        "        if (to == address(0)) {",
                        "            revert ERC1155InvalidReceiver(address(0));",
                        "        }",
                        "        if (from == address(0)) {",
                        "            revert ERC1155InvalidSender(address(0));",
                        "        }",
                        "        if (to == address(0)) {",
                        "            revert ERC1155InvalidReceiver(address(0));",
                        "        }",
                        "        if (to == address(0)) {",
                        "            revert ERC1155InvalidReceiver(address(0));",
                        "        }",
                        "        if (from == address(0)) {",
                        "            revert ERC1155InvalidSender(address(0));",
                        "        }",
                        "        if (from == address(0)) {",
                        "            revert ERC1155InvalidSender(address(0));",
                        "        }",
                        "        if (owner == operator) {",
                        "            revert ERC1155InvalidOperator(operator);",
                        "        }",
                        "                    revert ERC1155InvalidReceiver(to);",
                        "                revert ERC1155InvalidReceiver(to);",
                        "                    revert ERC1155InvalidReceiver(to);",
                        "                revert ERC1155InvalidReceiver(to);",
                        "        if (account != _msgSender() && !isApprovedForAll(account, _msgSender())) {",
                        "            revert ERC1155InsufficientApprovalForAll(_msgSender(), account);",
                        "        }",
                        "        if (account != _msgSender() && !isApprovedForAll(account, _msgSender())) {",
                        "            revert ERC1155InsufficientApprovalForAll(_msgSender(), account);",
                        "        }",
                        "    ) internal virtual override whenNotPaused {",
                        "                _totalSupply[id] -= amount;",
                        "contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {",
                        "    /**",
                        "     * @dev Indicates a failed `decreaseAllowance` request.",
                        "     */",
                        "    error ERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);",
                        "     * `requestedDecrease`.",
                        "    function decreaseAllowance(address spender, uint256 requestedDecrease) public virtual returns (bool) {",
                        "        if (currentAllowance < requestedDecrease) {",
                        "            revert ERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);",
                        "        }",
                        "            _approve(owner, spender, currentAllowance - requestedDecrease);",
                        "        if (from == address(0)) {",
                        "            revert ERC20InvalidSender(address(0));",
                        "        }",
                        "        if (to == address(0)) {",
                        "            revert ERC20InvalidReceiver(address(0));",
                        "        }",
                        "            if (fromBalance < amount) {",
                        "                revert ERC20InsufficientBalance(from, fromBalance, amount);",
                        "            }",
                        "        if (account == address(0)) {",
                        "            revert ERC20InvalidReceiver(address(0));",
                        "        }",
                        "        if (account == address(0)) {",
                        "            revert ERC20InvalidSender(address(0));",
                        "        }",
                        "        if (owner == address(0)) {",
                        "            revert ERC20InvalidApprover(address(0));",
                        "        }",
                        "        if (spender == address(0)) {",
                        "            revert ERC20InvalidSpender(address(0));",
                        "        }",
                        "            if (currentAllowance < amount) {",
                        "                revert ERC20InsufficientAllowance(spender, currentAllowance, amount);",
                        "            }",
                        "    /**",
                        "     * @dev Total supply cap has been exceeded.",
                        "     */",
                        "    error ERC20ExceededCap(uint256 increasedSupply, uint256 cap);",
                        "    /**",
                        "     * @dev The supplied cap is not a valid cap.",
                        "     */",
                        "    error ERC20InvalidCap(uint256 cap);",
                        "        if (cap_ == 0) {",
                        "            revert ERC20InvalidCap(0);",
                        "        }",
                        "        super._update(from, to, amount);",
                        "            uint256 maxSupply = cap();",
                        "            uint256 supply = totalSupply();",
                        "            if (supply > maxSupply) {",
                        "                revert ERC20ExceededCap(supply, maxSupply);",
                        "            }",
                        "    /**",
                        "     * @dev The loan token is not valid.",
                        "     */",
                        "    error ERC3156UnsupportedToken(address token);",
                        "    /**",
                        "     * @dev The requested loan exceeds the max loan amount for `token`.",
                        "     */",
                        "    error ERC3156ExceededMaxLoan(uint256 maxLoan);",
                        "    /**",
                        "     * @dev The receiver of a flashloan is not a valid {onFlashLoan} implementer.",
                        "     */",
                        "    error ERC3156InvalidReceiver(address receiver);",
                        "        if (token != address(this)) {",
                        "            revert ERC3156UnsupportedToken(token);",
                        "        }",
                        "        uint256 maxLoan = maxFlashLoan(token);",
                        "        if (amount > maxLoan) {",
                        "            revert ERC3156ExceededMaxLoan(maxLoan);",
                        "        }",
                        "        if (receiver.onFlashLoan(msg.sender, token, amount, fee, data) != _RETURN_VALUE) {",
                        "            revert ERC3156InvalidReceiver(address(receiver));",
                        "        }",
                        "    function _update(address from, address to, uint256 amount) internal virtual override whenNotPaused {",
                        "    /**",
                        "     * @dev Permit deadline has expired.",
                        "     */",
                        "    error ERC2612ExpiredSignature(uint256 deadline);",
                        "    /**",
                        "     * @dev Mismatched signature.",
                        "     */",
                        "    error ERC2612InvalidSigner(address signer, address owner);",
                        "        if (block.timestamp > deadline) {",
                        "            revert ERC2612ExpiredSignature(deadline);",
                        "        }",
                        "        if (signer != owner) {",
                        "            revert ERC2612InvalidSigner(signer, owner);",
                        "        }",
                        "    /**",
                        "     * @dev Total supply cap has been exceeded, introducing a risk of votes overflowing.",
                        "     */",
                        "    error ERC20ExceededSafeSupply(uint256 increasedSupply, uint256 cap);",
                        "            uint256 supply = totalSupply();",
                        "            uint256 cap = _maxSupply();",
                        "            if (supply > cap) {",
                        "                revert ERC20ExceededSafeSupply(supply, cap);",
                        "            }",
                        "    /**",
                        "     * @dev The underlying token couldn't be wrapped.",
                        "     */",
                        "    error ERC20InvalidUnderlying(address token);",
                        "        if (underlyingToken == this) {",
                        "            revert ERC20InvalidUnderlying(address(this));",
                        "        }",
                        "        if (sender == address(this)) {",
                        "            revert ERC20InvalidSender(address(this));",
                        "        }",
                        "    /**",
                        "     * @dev Attempted to deposit more assets than the max amount for `receiver`.",
                        "     */",
                        "    error ERC4626ExceededMaxDeposit(address receiver, uint256 assets, uint256 max);",
                        "    /**",
                        "     * @dev Attempted to mint more shares than the max amount for `receiver`.",
                        "     */",
                        "    error ERC4626ExceededMaxMint(address receiver, uint256 shares, uint256 max);",
                        "    /**",
                        "     * @dev Attempted to withdraw more assets than the max amount for `receiver`.",
                        "     */",
                        "    error ERC4626ExceededMaxWithdraw(address owner, uint256 assets, uint256 max);",
                        "    /**",
                        "     * @dev Attempted to redeem more shares than the max amount for `receiver`.",
                        "     */",
                        "    error ERC4626ExceededMaxRedeem(address owner, uint256 shares, uint256 max);",
                        "        uint256 maxAssets = maxDeposit(receiver);",
                        "        if (assets > maxAssets) {",
                        "            revert ERC4626ExceededMaxDeposit(receiver, assets, maxAssets);",
                        "        }",
                        "        uint256 maxShares = maxMint(receiver);",
                        "        if (shares > maxShares) {",
                        "            revert ERC4626ExceededMaxMint(receiver, shares, maxShares);",
                        "        }",
                        "        uint256 maxAssets = maxWithdraw(owner);",
                        "        if (assets > maxAssets) {",
                        "            revert ERC4626ExceededMaxWithdraw(owner, assets, maxAssets);",
                        "        }",
                        "        uint256 maxShares = maxRedeem(owner);",
                        "        if (shares > maxShares) {",
                        "            revert ERC4626ExceededMaxRedeem(owner, shares, maxShares);",
                        "        }",
                        "    /**",
                        "     * @dev An operation with an ERC20 token failed.",
                        "     */",
                        "    error SafeERC20FailedOperation(address token);",
                        "    /**",
                        "     * @dev Indicates a failed `decreaseAllowance` request.",
                        "     */",
                        "    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);",
                        "     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no value,",
                        "    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {",
                        "            uint256 currentAllowance = token.allowance(address(this), spender);",
                        "            if (currentAllowance < requestedDecrease) {",
                        "                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);",
                        "            }",
                        "            forceApprove(token, spender, currentAllowance - requestedDecrease);",
                        "        if (nonceAfter != nonceBefore + 1) {",
                        "            revert SafeERC20FailedOperation(address(token));",
                        "        }",
                        "        bytes memory returndata = address(token).functionCall(data);",
                        "        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {",
                        "            revert SafeERC20FailedOperation(address(token));",
                        "        }",
                        "contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Errors {",
                        "        if (owner == address(0)) {",
                        "            revert ERC721InvalidOwner(address(0));",
                        "        }",
                        "        if (owner == address(0)) {",
                        "            revert ERC721NonexistentToken(tokenId);",
                        "        }",
                        "        if (to == owner) {",
                        "            revert ERC721InvalidOperator(owner);",
                        "        }",
                        "        if (_msgSender() != owner && !isApprovedForAll(owner, _msgSender())) {",
                        "            revert ERC721InvalidApprover(_msgSender());",
                        "        }",
                        "        if (!_isApprovedOrOwner(_msgSender(), tokenId)) {",
                        "            revert ERC721InsufficientApproval(_msgSender(), tokenId);",
                        "        }",
                        "        if (!_isApprovedOrOwner(_msgSender(), tokenId)) {",
                        "            revert ERC721InsufficientApproval(_msgSender(), tokenId);",
                        "        }",
                        "        if (!_checkOnERC721Received(from, to, tokenId, data)) {",
                        "            revert ERC721InvalidReceiver(to);",
                        "        }",
                        "        if (!_checkOnERC721Received(address(0), to, tokenId, data)) {",
                        "            revert ERC721InvalidReceiver(to);",
                        "        }",
                        "        if (to == address(0)) {",
                        "            revert ERC721InvalidReceiver(address(0));",
                        "        }",
                        "        if (_exists(tokenId)) {",
                        "            revert ERC721InvalidSender(address(0));",
                        "        }",
                        "        if (_exists(tokenId)) {",
                        "            revert ERC721InvalidSender(address(0));",
                        "        }",
                        "        address owner = ownerOf(tokenId);",
                        "        if (owner != from) {",
                        "            revert ERC721IncorrectOwner(from, tokenId, owner);",
                        "        }",
                        "        if (to == address(0)) {",
                        "            revert ERC721InvalidReceiver(address(0));",
                        "        }",
                        "        owner = ownerOf(tokenId);",
                        "        if (owner != from) {",
                        "            revert ERC721IncorrectOwner(from, tokenId, owner);",
                        "        }",
                        "        if (owner == operator) {",
                        "            revert ERC721InvalidOperator(owner);",
                        "        }",
                        "        if (!_exists(tokenId)) {",
                        "            revert ERC721NonexistentToken(tokenId);",
                        "        }",
                        "                    revert ERC721InvalidReceiver(to);",
                        "        if (!_isApprovedOrOwner(_msgSender(), tokenId)) {",
                        "            revert ERC721InsufficientApproval(_msgSender(), tokenId);",
                        "        }",
                        "    /**",
                        "     * @dev Batch mint is restricted to the constructor.",
                        "     * Any batch mint not emitting the {IERC721-Transfer} event outside of the constructor",
                        "     * is non-ERC721 compliant.",
                        "     */",
                        "    error ERC721ForbiddenBatchMint();",
                        "    /**",
                        "     * @dev Exceeds the max amount of mints per batch.",
                        "     */",
                        "    error ERC721ExceededMaxBatchMint(uint256 batchSize, uint256 maxBatch);",
                        "    /**",
                        "     * @dev Individual minting is not allowed.",
                        "     */",
                        "    error ERC721ForbiddenMint();",
                        "    /**",
                        "     * @dev Batch burn is not supported.",
                        "     */",
                        "    error ERC721ForbiddenBatchBurn();",
                        "            if (address(this).code.length > 0) {",
                        "                revert ERC721ForbiddenBatchMint();",
                        "            }",
                        "            if (to == address(0)) {",
                        "                revert ERC721InvalidReceiver(address(0));",
                        "            }",
                        "            uint256 maxBatchSize = _maxBatchSize();",
                        "            if (batchSize > maxBatchSize) {",
                        "                revert ERC721ExceededMaxBatchMint(batchSize, maxBatchSize);",
                        "            }",
                        "        if (address(this).code.length == 0) {",
                        "            revert ERC721ForbiddenMint();",
                        "        }",
                        "            if (batchSize != 1) {",
                        "                revert ERC721ForbiddenBatchBurn();",
                        "            }",
                        "    /**",
                        "     * @dev An `owner`'s token query was out of bounds for `index`.",
                        "     *",
                        "     * NOTE: The owner being `address(0)` indicates a global out of bounds index.",
                        "     */",
                        "    error ERC721OutOfBoundsIndex(address owner, uint256 index);",
                        "    /**",
                        "     * @dev Batch mint is not allowed.",
                        "     */",
                        "    error ERC721EnumerableForbiddenBatchMint();",
                        "        if (index >= balanceOf(owner)) {",
                        "            revert ERC721OutOfBoundsIndex(owner, index);",
                        "        }",
                        "        if (index >= totalSupply()) {",
                        "            revert ERC721OutOfBoundsIndex(address(0), index);",
                        "        }",
                        "            revert ERC721EnumerableForbiddenBatchMint();",
                        "        _requireNotPaused();",
                        "        if (!_exists(tokenId)) {",
                        "            revert ERC721NonexistentToken(tokenId);",
                        "        }",
                        "    /**",
                        "     * @dev The received ERC721 token couldn't be wrapped.",
                        "     */",
                        "    error ERC721UnsupportedToken(address token);",
                        "            if (!_isApprovedOrOwner(_msgSender(), tokenId)) {",
                        "                revert ERC721InsufficientApproval(_msgSender(), tokenId);",
                        "            }",
                        "        if (address(underlying()) != _msgSender()) {",
                        "            revert ERC721UnsupportedToken(_msgSender());",
                        "        }",
                        "        address owner = underlying().ownerOf(tokenId);",
                        "        if (owner != address(this)) {",
                        "            revert ERC721IncorrectOwner(address(this), tokenId, owner);",
                        "        }",
                        "    /**",
                        "     * @dev The default royalty set is invalid (eg. (numerator / denominator) >= 1).",
                        "     */",
                        "    error ERC2981InvalidDefaultRoyalty(uint256 numerator, uint256 denominator);",
                        "    /**",
                        "     * @dev The default royalty receiver is invalid.",
                        "     */",
                        "    error ERC2981InvalidDefaultRoyaltyReceiver(address receiver);",
                        "    /**",
                        "     * @dev The royalty set for an specific `tokenId` is invalid (eg. (numerator / denominator) >= 1).",
                        "     */",
                        "    error ERC2981InvalidTokenRoyalty(uint256 tokenId, uint256 numerator, uint256 denominator);",
                        "    /**",
                        "     * @dev The royalty receiver for `tokenId` is invalid.",
                        "     */",
                        "    error ERC2981InvalidTokenRoyaltyReceiver(uint256 tokenId, address receiver);",
                        "        uint256 denominator = _feeDenominator();",
                        "        if (feeNumerator > denominator) {",
                        "            revert ERC2981InvalidDefaultRoyalty(feeNumerator, denominator);",
                        "        }",
                        "        if (receiver == address(0)) {",
                        "            revert ERC2981InvalidDefaultRoyaltyReceiver(address(0));",
                        "        }",
                        "        uint256 denominator = _feeDenominator();",
                        "        if (feeNumerator > denominator) {",
                        "            revert ERC2981InvalidTokenRoyalty(tokenId, feeNumerator, denominator);",
                        "        }",
                        "        if (receiver == address(0)) {",
                        "            revert ERC2981InvalidTokenRoyaltyReceiver(tokenId, address(0));",
                        "        }",
                        "    /**",
                        "     * @dev The ETH balance of the account is not enough to perform the operation.",
                        "     */",
                        "    error AddressInsufficientBalance(address account);",
                        "    /**",
                        "     * @dev There's no code at `target` (it is not a contract).",
                        "     */",
                        "    error AddressEmptyCode(address target);",
                        "    /**",
                        "     * @dev A call to an address target failed. The target may have reverted.",
                        "     */",
                        "    error FailedInnerCall();",
                        "        if (address(this).balance < amount) {",
                        "            revert AddressInsufficientBalance(address(this));",
                        "        }",
                        "        if (!success) {",
                        "            revert FailedInnerCall();",
                        "        }",
                        "        return functionCallWithValue(target, data, 0, defaultRevert);",
                        "     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with a",
                        "     * `customRevert` function as a fallback when `target` reverts.",
                        "     * Requirements:",
                        "     *",
                        "     * - `customRevert` must be a reverting function.",
                        "     *",
                        "     * _Available since v5.0._",
                        "        function() internal view customRevert",
                        "        return functionCallWithValue(target, data, 0, customRevert);",
                        "        return functionCallWithValue(target, data, value, defaultRevert);",
                        "     * with a `customRevert` function as a fallback revert reason when `target` reverts.",
                        "     * Requirements:",
                        "     *",
                        "     * - `customRevert` must be a reverting function.",
                        "     *",
                        "     * _Available since v5.0._",
                        "        function() internal view customRevert",
                        "        if (address(this).balance < value) {",
                        "            revert AddressInsufficientBalance(address(this));",
                        "        }",
                        "        return verifyCallResultFromTarget(target, success, returndata, customRevert);",
                        "        return functionStaticCall(target, data, defaultRevert);",
                        "        function() internal view customRevert",
                        "        return verifyCallResultFromTarget(target, success, returndata, customRevert);",
                        "        return functionDelegateCall(target, data, defaultRevert);",
                        "        function() internal view customRevert",
                        "        return verifyCallResultFromTarget(target, success, returndata, customRevert);",
                        "     * the revert reason or using the provided `customRevert`) in case of unsuccessful call or if target was not a contract.",
                        "     * _Available since v5.0._",
                        "        function() internal view customRevert",
                        "                if (target.code.length == 0) {",
                        "                    revert AddressEmptyCode(target);",
                        "                }",
                        "            _revert(returndata, customRevert);",
                        "     * revert reason or with a default revert error.",
                        "     *",
                        "     * _Available since v5.0._",
                        "     */",
                        "    function verifyCallResult(bool success, bytes memory returndata) internal view returns (bytes memory) {",
                        "        return verifyCallResult(success, returndata, defaultRevert);",
                        "    }",
                        "    /**",
                        "     * @dev Same as {xref-Address-verifyCallResult-bool-bytes-}[`verifyCallResult`], but with a",
                        "     * `customRevert` function as a fallback when `success` is `false`.",
                        "     * Requirements:",
                        "     *",
                        "     * - `customRevert` must be a reverting function.",
                        "     *",
                        "     * _Available since v5.0._",
                        "        function() internal view customRevert",
                        "    ) internal view returns (bytes memory) {",
                        "            _revert(returndata, customRevert);",
                        "    /**",
                        "     * @dev Default reverting function when no `customRevert` is provided in a function call.",
                        "     */",
                        "    function defaultRevert() internal pure {",
                        "        revert FailedInnerCall();",
                        "    }",
                        "    function _revert(bytes memory returndata, function() internal view customRevert) private view {",
                        "            customRevert();",
                        "            revert FailedInnerCall();",
                        "    /**",
                        "     * @dev Not enough balance for performing a CREATE2 deploy.",
                        "     */",
                        "    error Create2InsufficientBalance(uint256 balance, uint256 needed);",
                        "    /**",
                        "     * @dev There's no code to deploy.",
                        "     */",
                        "    error Create2EmptyBytecode();",
                        "    /**",
                        "     * @dev The deployment failed.",
                        "     */",
                        "    error Create2FailedDeployment();",
                        "        if (address(this).balance < amount) {",
                        "            revert Create2InsufficientBalance(address(this).balance, amount);",
                        "        }",
                        "        if (bytecode.length == 0) {",
                        "            revert Create2EmptyBytecode();",
                        "        }",
                        "        if (addr == address(0)) {",
                        "            revert Create2FailedDeployment();",
                        "        }",
                        "    /**",
                        "     * @dev The nonce used for an `account` is not the expected current nonce.",
                        "     */",
                        "    error InvalidAccountNonce(address account, uint256 currentNonce);",
                        "    /**",
                        "     * @dev Same as {_useNonce} but checking that `nonce` is the next valid for `owner`.",
                        "     */",
                        "    function _useCheckedNonce(address owner, uint256 nonce) internal virtual returns (uint256) {",
                        "        uint256 current = _useNonce(owner);",
                        "        if (nonce != current) {",
                        "            revert InvalidAccountNonce(owner, current);",
                        "        }",
                        "        return current;",
                        "    }",
                        " *         require(newImplementation.code.length > 0);",
                        "    /**",
                        "     * @dev The `value` string doesn't fit in the specified `length`.",
                        "     */",
                        "    error StringsInsufficientHexLength(uint256 value, uint256 length);",
                        "        uint256 localValue = value;",
                        "            buffer[i] = _SYMBOLS[localValue & 0xf];",
                        "            localValue >>= 4;",
                        "        }",
                        "        if (localValue != 0) {",
                        "            revert StringsInsufficientHexLength(value, length);",
                        "    /**",
                        "     * @dev The signature derives the `address(0)`.",
                        "     */",
                        "    error ECDSAInvalidSignature();",
                        "    /**",
                        "     * @dev The signature has an invalid length.",
                        "     */",
                        "    error ECDSAInvalidSignatureLength(uint256 length);",
                        "    /**",
                        "     * @dev The signature has an S value that is in the upper half order.",
                        "     */",
                        "    error ECDSAInvalidSignatureS(bytes32 s);",
                        "    function _throwError(RecoverError error, bytes32 errorArg) private pure {",
                        "            revert ECDSAInvalidSignature();",
                        "            revert ECDSAInvalidSignatureLength(uint256(errorArg));",
                        "            revert ECDSAInvalidSignatureS(errorArg);",
                        "    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError, bytes32) {",
                        "            return (address(0), RecoverError.InvalidSignatureLength, bytes32(signature.length));",
                        "        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, signature);",
                        "        _throwError(error, errorArg);",
                        "    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError, bytes32) {",
                        "        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, r, vs);",
                        "        _throwError(error, errorArg);",
                        "    function tryRecover(",
                        "        bytes32 hash,",
                        "        uint8 v,",
                        "        bytes32 r,",
                        "        bytes32 s",
                        "    ) internal pure returns (address, RecoverError, bytes32) {",
                        "            return (address(0), RecoverError.InvalidSignatureS, s);",
                        "            return (address(0), RecoverError.InvalidSignature, bytes32(0));",
                        "        return (signer, RecoverError.NoError, bytes32(0));",
                        "        (address recovered, RecoverError error, bytes32 errorArg) = tryRecover(hash, v, r, s);",
                        "        _throwError(error, errorArg);",
                        "    /**",
                        "     *@dev The multiproof provided is not valid.",
                        "     */",
                        "    error MerkleProofInvalidMultiproof();",
                        "        if (leavesLen + proof.length - 1 != totalHashes) {",
                        "            revert MerkleProofInvalidMultiproof();",
                        "        }",
                        "        if (leavesLen + proof.length - 1 != totalHashes) {",
                        "            revert MerkleProofInvalidMultiproof();",
                        "        }",
                        "        (address recovered, ECDSA.RecoverError error, ) = ECDSA.tryRecover(hash, signature);",
                        "    /**",
                        "     * @dev Muldiv operation overflow.",
                        "     */",
                        "    error MathOverflowedMulDiv();",
                        "            if (denominator <= prod1) {",
                        "                revert MathOverflowedMulDiv();",
                        "            }",
                        "    /**",
                        "     * @dev Value doesn't fit in an uint of `bits` size.",
                        "     */",
                        "    error SafeCastOverflowedUintDowncast(uint8 bits, uint256 value);",
                        "    /**",
                        "     * @dev An int value doesn't fit in an uint of `bits` size.",
                        "     */",
                        "    error SafeCastOverflowedIntToUint(int256 value);",
                        "    /**",
                        "     * @dev Value doesn't fit in an int of `bits` size.",
                        "     */",
                        "    error SafeCastOverflowedIntDowncast(uint8 bits, int256 value);",
                        "    /**",
                        "     * @dev An uint value doesn't fit in an int of `bits` size.",
                        "     */",
                        "    error SafeCastOverflowedUintToInt(uint256 value);",
                        "        if (value > type(uint248).max) {",
                        "            revert SafeCastOverflowedUintDowncast(248, value);",
                        "        }",
                        "        if (value > type(uint240).max) {",
                        "            revert SafeCastOverflowedUintDowncast(240, value);",
                        "        }",
                        "        if (value > type(uint232).max) {",
                        "            revert SafeCastOverflowedUintDowncast(232, value);",
                        "        }",
                        "        if (value > type(uint224).max) {",
                        "            revert SafeCastOverflowedUintDowncast(224, value);",
                        "        }",
                        "        if (value > type(uint216).max) {",
                        "            revert SafeCastOverflowedUintDowncast(216, value);",
                        "        }",
                        "        if (value > type(uint208).max) {",
                        "            revert SafeCastOverflowedUintDowncast(208, value);",
                        "        }",
                        "        if (value > type(uint200).max) {",
                        "            revert SafeCastOverflowedUintDowncast(200, value);",
                        "        }",
                        "        if (value > type(uint192).max) {",
                        "            revert SafeCastOverflowedUintDowncast(192, value);",
                        "        }",
                        "        if (value > type(uint184).max) {",
                        "            revert SafeCastOverflowedUintDowncast(184, value);",
                        "        }",
                        "        if (value > type(uint176).max) {",
                        "            revert SafeCastOverflowedUintDowncast(176, value);",
                        "        }",
                        "        if (value > type(uint168).max) {",
                        "            revert SafeCastOverflowedUintDowncast(168, value);",
                        "        }",
                        "        if (value > type(uint160).max) {",
                        "            revert SafeCastOverflowedUintDowncast(160, value);",
                        "        }",
                        "        if (value > type(uint152).max) {",
                        "            revert SafeCastOverflowedUintDowncast(152, value);",
                        "        }",
                        "        if (value > type(uint144).max) {",
                        "            revert SafeCastOverflowedUintDowncast(144, value);",
                        "        }",
                        "        if (value > type(uint136).max) {",
                        "            revert SafeCastOverflowedUintDowncast(136, value);",
                        "        }",
                        "        if (value > type(uint128).max) {",
                        "            revert SafeCastOverflowedUintDowncast(128, value);",
                        "        }",
                        "        if (value > type(uint120).max) {",
                        "            revert SafeCastOverflowedUintDowncast(120, value);",
                        "        }",
                        "        if (value > type(uint112).max) {",
                        "            revert SafeCastOverflowedUintDowncast(112, value);",
                        "        }",
                        "        if (value > type(uint104).max) {",
                        "            revert SafeCastOverflowedUintDowncast(104, value);",
                        "        }",
                        "        if (value > type(uint96).max) {",
                        "            revert SafeCastOverflowedUintDowncast(96, value);",
                        "        }",
                        "        if (value > type(uint88).max) {",
                        "            revert SafeCastOverflowedUintDowncast(88, value);",
                        "        }",
                        "        if (value > type(uint80).max) {",
                        "            revert SafeCastOverflowedUintDowncast(80, value);",
                        "        }",
                        "        if (value > type(uint72).max) {",
                        "            revert SafeCastOverflowedUintDowncast(72, value);",
                        "        }",
                        "        if (value > type(uint64).max) {",
                        "            revert SafeCastOverflowedUintDowncast(64, value);",
                        "        }",
                        "        if (value > type(uint56).max) {",
                        "            revert SafeCastOverflowedUintDowncast(56, value);",
                        "        }",
                        "        if (value > type(uint48).max) {",
                        "            revert SafeCastOverflowedUintDowncast(48, value);",
                        "        }",
                        "        if (value > type(uint40).max) {",
                        "            revert SafeCastOverflowedUintDowncast(40, value);",
                        "        }",
                        "        if (value > type(uint32).max) {",
                        "            revert SafeCastOverflowedUintDowncast(32, value);",
                        "        }",
                        "        if (value > type(uint24).max) {",
                        "            revert SafeCastOverflowedUintDowncast(24, value);",
                        "        }",
                        "        if (value > type(uint16).max) {",
                        "            revert SafeCastOverflowedUintDowncast(16, value);",
                        "        }",
                        "        if (value > type(uint8).max) {",
                        "            revert SafeCastOverflowedUintDowncast(8, value);",
                        "        }",
                        "        if (value < 0) {",
                        "            revert SafeCastOverflowedIntToUint(value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(248, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(240, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(232, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(224, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(216, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(208, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(200, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(192, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(184, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(176, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(168, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(160, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(152, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(144, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(136, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(128, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(120, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(112, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(104, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(96, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(88, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(80, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(72, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(64, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(56, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(48, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(40, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(32, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(24, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(16, value);",
                        "        }",
                        "        if (downcasted != value) {",
                        "            revert SafeCastOverflowedIntDowncast(8, value);",
                        "        }",
                        "        if (value > uint256(type(int256).max)) {",
                        "            revert SafeCastOverflowedUintToInt(value);",
                        "        }",
                        "    /**",
                        "     * @dev A value was attempted to be inserted on a past checkpoint.",
                        "     */",
                        "    error CheckpointUnorderedInsertion();",
                        "            if (last._key > key) {",
                        "                revert CheckpointUnorderedInsertion();",
                        "            }",
                        "            if (last._key > key) {",
                        "                revert CheckpointUnorderedInsertion();",
                        "            }",
                        "    error QueueEmpty();",
                        "    error QueueOutOfBounds();",
                        "     * Reverts with `QueueEmpty` if the queue is empty.",
                        "        if (empty(deque)) revert QueueEmpty();",
                        "     * Reverts with `QueueEmpty` if the queue is empty.",
                        "        if (empty(deque)) revert QueueEmpty();",
                        "     * Reverts with `QueueEmpty` if the queue is empty.",
                        "        if (empty(deque)) revert QueueEmpty();",
                        "     * Reverts with `QueueEmpty` if the queue is empty.",
                        "        if (empty(deque)) revert QueueEmpty();",
                        "     * Reverts with `QueueOutOfBounds` if the index is out of bounds.",
                        "        if (idx >= deque._end) revert QueueOutOfBounds();",
                        "    /**",
                        "     * @dev Query for a nonexistent map key.",
                        "     */",
                        "    error EnumerableMapNonexistentKey(bytes32 key);",
                        "        if (value == 0 && !contains(map, key)) {",
                        "            revert EnumerableMapNonexistentKey(key);",
                        "        }"
                    ],
                    "del": [
                        "            revert(",
                        "                string(",
                        "                    abi.encodePacked(",
                        "                        \"AccessControl: account \",",
                        "                        Strings.toHexString(account),",
                        "                        \" is missing role \",",
                        "                        Strings.toHexString(uint256(role), 32)",
                        "                    )",
                        "                )",
                        "            );",
                        "     * - the caller must be `account`.",
                        "    function renounceRole(bytes32 role, address account) public virtual {",
                        "        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");",
                        "        _revokeRole(role, account);",
                        "        require(initialDefaultAdmin != address(0), \"AccessControl: 0 default admin\");",
                        "        require(role != DEFAULT_ADMIN_ROLE, \"AccessControl: can't directly grant default admin role\");",
                        "        require(role != DEFAULT_ADMIN_ROLE, \"AccessControl: can't directly revoke default admin role\");",
                        "            require(",
                        "                newDefaultAdmin == address(0) && _isScheduleSet(schedule) && _hasSchedulePassed(schedule),",
                        "                \"AccessControl: only can renounce in two delayed steps\"",
                        "            );",
                        "            require(defaultAdmin() == address(0), \"AccessControl: default admin already granted\");",
                        "        require(role != DEFAULT_ADMIN_ROLE, \"AccessControl: can't violate default admin rules\");",
                        "        require(_msgSender() == newDefaultAdmin, \"AccessControl: pending admin must accept\");",
                        "        require(_isScheduleSet(schedule) && _hasSchedulePassed(schedule), \"AccessControl: transfer delay not passed\");",
                        "     * - the caller must be `account`.",
                        "    function renounceRole(bytes32 role, address account) external;",
                        "        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");",
                        "        require(newOwner != address(0), \"Ownable: new owner is the zero address\");",
                        "        require(pendingOwner() == sender, \"Ownable2Step: caller is not the new owner\");",
                        "        require(beneficiaryAddress != address(0), \"VestingWallet: beneficiary is zero address\");",
                        "        require(_msgSender() == _executor(), \"Governor: onlyGovernance\");",
                        "        require(_executor() == address(this), \"Governor: must send to executor\");",
                        "            revert(\"Governor: unknown proposal id\");",
                        "        require(",
                        "            getVotes(proposer, currentTimepoint - 1) >= proposalThreshold(),",
                        "            \"Governor: proposer votes below proposal threshold\"",
                        "        );",
                        "        require(targets.length == values.length, \"Governor: invalid proposal length\");",
                        "        require(targets.length == calldatas.length, \"Governor: invalid proposal length\");",
                        "        require(targets.length > 0, \"Governor: empty proposal\");",
                        "        require(_proposals[proposalId].voteStart == 0, \"Governor: proposal already exists\");",
                        "        require(",
                        "            currentState == ProposalState.Succeeded || currentState == ProposalState.Queued,",
                        "            \"Governor: proposal not successful\"",
                        "        );",
                        "        require(state(proposalId) == ProposalState.Pending, \"Governor: too late to cancel\");",
                        "        require(_msgSender() == _proposals[proposalId].proposer, \"Governor: only proposer can cancel\");",
                        "        string memory errorMessage = \"Governor: call reverted without message\";",
                        "            Address.verifyCallResult(success, returndata, errorMessage);",
                        "        require(",
                        "            currentState != ProposalState.Canceled &&",
                        "                currentState != ProposalState.Expired &&",
                        "                currentState != ProposalState.Executed,",
                        "            \"Governor: proposal not active\"",
                        "        );",
                        "        require(state(proposalId) == ProposalState.Active, \"Governor: vote not currently active\");",
                        "        Address.verifyCallResult(success, returndata, \"Governor: relay reverted without message\");",
                        "        require(targets.length == values.length, \"TimelockController: length mismatch\");",
                        "        require(targets.length == payloads.length, \"TimelockController: length mismatch\");",
                        "        require(!isOperation(id), \"TimelockController: operation already scheduled\");",
                        "        require(delay >= getMinDelay(), \"TimelockController: insufficient delay\");",
                        "        require(isOperationPending(id), \"TimelockController: operation cannot be cancelled\");",
                        "        require(targets.length == values.length, \"TimelockController: length mismatch\");",
                        "        require(targets.length == payloads.length, \"TimelockController: length mismatch\");",
                        "        (bool success, ) = target.call{value: value}(data);",
                        "        require(success, \"TimelockController: underlying transaction reverted\");",
                        "        require(isOperationReady(id), \"TimelockController: operation is not ready\");",
                        "        require(predecessor == bytes32(0) || isOperationDone(predecessor), \"TimelockController: missing dependency\");",
                        "        require(isOperationReady(id), \"TimelockController: operation is not ready\");",
                        "        require(msg.sender == address(this), \"TimelockController: caller must be timelock\");",
                        "        require(signatures.length == calldatas.length, \"GovernorBravo: invalid signatures length\");",
                        "        require(",
                        "            _msgSender() == proposer || getVotes(proposer, clock() - 1) < proposalThreshold(),",
                        "            \"GovernorBravo: proposer above threshold\"",
                        "        );",
                        "        require(!receipt.hasVoted, \"GovernorCompatibilityBravo: vote already cast\");",
                        "            revert(\"GovernorCompatibilityBravo: invalid vote type\");",
                        "        require(!proposalVote.hasVoted[account], \"GovernorVotingSimple: vote already cast\");",
                        "            revert(\"GovernorVotingSimple: invalid value for enum VoteType\");",
                        "        require(newVotingPeriod > 0, \"GovernorSettings: voting period too low\");",
                        "        require(state(proposalId) == ProposalState.Succeeded, \"Governor: proposal not successful\");",
                        "            require(",
                        "                !_timelock.queuedTransactions(keccak256(abi.encode(targets[i], values[i], \"\", calldatas[i], eta))),",
                        "                \"GovernorTimelockCompound: identical proposal action already queued\"",
                        "            );",
                        "        require(eta > 0, \"GovernorTimelockCompound: proposal not yet queued\");",
                        "        require(state(proposalId) == ProposalState.Succeeded, \"Governor: proposal not successful\");",
                        "        require(",
                        "            newQuorumNumerator <= quorumDenominator(),",
                        "            \"GovernorVotesQuorumFraction: quorumNumerator over quorumDenominator\"",
                        "        );",
                        "        require(clock() == block.number, \"Votes: broken clock mode\");",
                        "        require(timepoint < clock(), \"Votes: future lookup\");",
                        "        require(timepoint < clock(), \"Votes: future lookup\");",
                        "        require(block.timestamp <= expiry, \"Votes: signature expired\");",
                        "        require(nonce == _useNonce(signer), \"Votes: invalid nonce\");",
                        "        address signer = _hashTypedDataV4(",
                        "            keccak256(abi.encode(_TYPEHASH, req.from, req.to, req.value, req.gas, req.nonce, keccak256(req.data)))",
                        "        ).recover(signature);",
                        "        return _nonces[req.from] == req.nonce && signer == req.from;",
                        "        require(verify(req, signature), \"MinimalForwarder: signature does not match request\");",
                        "        require(instance != address(0), \"ERC1167: create failed\");",
                        "        require(instance != address(0), \"ERC1167: create2 failed\");",
                        "        require(newImplementation.code.length > 0, \"ERC1967: new implementation is not a contract\");",
                        "                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");",
                        "                revert(\"ERC1967Upgrade: new implementation is not UUPS\");",
                        "        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");",
                        "        require(newBeacon.code.length > 0, \"ERC1967: new beacon is not a contract\");",
                        "        require(",
                        "            IBeacon(newBeacon).implementation().code.length > 0,",
                        "            \"ERC1967: beacon implementation is not a contract\"",
                        "        );",
                        "        require(newImplementation.code.length > 0, \"UpgradeableBeacon: implementation is not a contract\");",
                        "                revert(\"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");",
                        "        require(msg.value == 0);",
                        "        require(",
                        "            (isTopLevelCall && _initialized < 1) || (address(this).code.length == 0 && _initialized == 1),",
                        "            \"Initializable: contract is already initialized\"",
                        "        );",
                        "        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");",
                        "        require(_initializing, \"Initializable: contract is not initializing\");",
                        "        require(!_initializing, \"Initializable: contract is initializing\");",
                        "        require(address(this) != __self, \"Function must be called through delegatecall\");",
                        "        require(_getImplementation() == __self, \"Function must be called through active proxy\");",
                        "        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");",
                        "    bool private _paused;",
                        "        require(!paused(), \"Pausable: paused\");",
                        "        require(paused(), \"Pausable: not paused\");",
                        "        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");",
                        "contract ERC1155 is Context, ERC165, IERC1155, IERC1155MetadataURI {",
                        "        require(accounts.length == ids.length, \"ERC1155: accounts and ids length mismatch\");",
                        "        require(",
                        "            from == _msgSender() || isApprovedForAll(from, _msgSender()),",
                        "            \"ERC1155: caller is not token owner or approved\"",
                        "        );",
                        "        require(",
                        "            from == _msgSender() || isApprovedForAll(from, _msgSender()),",
                        "            \"ERC1155: caller is not token owner or approved\"",
                        "        );",
                        "        require(ids.length == amounts.length, \"ERC1155: ids and amounts length mismatch\");",
                        "                require(fromBalance >= amount, \"ERC1155: insufficient balance for transfer\");",
                        "        require(to != address(0), \"ERC1155: transfer to the zero address\");",
                        "        require(from != address(0), \"ERC1155: transfer from the zero address\");",
                        "        require(to != address(0), \"ERC1155: transfer to the zero address\");",
                        "        require(from != address(0), \"ERC1155: transfer from the zero address\");",
                        "        require(to != address(0), \"ERC1155: mint to the zero address\");",
                        "        require(to != address(0), \"ERC1155: mint to the zero address\");",
                        "        require(from != address(0), \"ERC1155: burn from the zero address\");",
                        "        require(from != address(0), \"ERC1155: burn from the zero address\");",
                        "        require(owner != operator, \"ERC1155: setting approval status for self\");",
                        "                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");",
                        "                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");",
                        "                    revert(\"ERC1155: ERC1155Receiver rejected tokens\");",
                        "                revert(\"ERC1155: transfer to non-ERC1155Receiver implementer\");",
                        "        require(",
                        "            account == _msgSender() || isApprovedForAll(account, _msgSender()),",
                        "            \"ERC1155: caller is not token owner or approved\"",
                        "        );",
                        "        require(",
                        "            account == _msgSender() || isApprovedForAll(account, _msgSender()),",
                        "            \"ERC1155: caller is not token owner or approved\"",
                        "        );",
                        "    ) internal virtual override {",
                        "        require(!paused(), \"ERC1155Pausable: token transfer while paused\");",
                        "                uint256 supply = _totalSupply[id];",
                        "                require(supply >= amount, \"ERC1155: burn amount exceeds totalSupply\");",
                        "                    _totalSupply[id] = supply - amount;",
                        "contract ERC20 is Context, IERC20, IERC20Metadata {",
                        "     * `subtractedValue`.",
                        "    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {",
                        "        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");",
                        "            _approve(owner, spender, currentAllowance - subtractedValue);",
                        "        require(from != address(0), \"ERC20: transfer from the zero address\");",
                        "        require(to != address(0), \"ERC20: transfer to the zero address\");",
                        "            require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");",
                        "        require(account != address(0), \"ERC20: mint to the zero address\");",
                        "        require(account != address(0), \"ERC20: burn from the zero address\");",
                        "        require(owner != address(0), \"ERC20: approve from the zero address\");",
                        "        require(spender != address(0), \"ERC20: approve to the zero address\");",
                        "            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");",
                        "        require(cap_ > 0, \"ERC20Capped: cap is 0\");",
                        "            require(totalSupply() + amount <= cap(), \"ERC20Capped: cap exceeded\");",
                        "        super._update(from, to, amount);",
                        "        require(token == address(this), \"ERC20FlashMint: wrong token\");",
                        "        require(amount <= maxFlashLoan(token), \"ERC20FlashMint: amount exceeds maxFlashLoan\");",
                        "        require(",
                        "            receiver.onFlashLoan(msg.sender, token, amount, fee, data) == _RETURN_VALUE,",
                        "            \"ERC20FlashMint: invalid return value\"",
                        "        );",
                        "    function _update(address from, address to, uint256 amount) internal virtual override {",
                        "        require(!paused(), \"ERC20Pausable: token transfer while paused\");",
                        "        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");",
                        "        require(signer == owner, \"ERC20Permit: invalid signature\");",
                        "            require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");",
                        "        require(underlyingToken != this, \"ERC20Wrapper: cannot self wrap\");",
                        "        require(sender != address(this), \"ERC20Wrapper: wrapper can't deposit\");",
                        "        require(assets <= maxDeposit(receiver), \"ERC4626: deposit more than max\");",
                        "        require(shares <= maxMint(receiver), \"ERC4626: mint more than max\");",
                        "        require(assets <= maxWithdraw(owner), \"ERC4626: withdraw more than max\");",
                        "        require(shares <= maxRedeem(owner), \"ERC4626: redeem more than max\");",
                        "     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,",
                        "    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {",
                        "            uint256 oldAllowance = token.allowance(address(this), spender);",
                        "            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");",
                        "            forceApprove(token, spender, oldAllowance - value);",
                        "        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");",
                        "        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");",
                        "        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");",
                        "contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {",
                        "        require(owner != address(0), \"ERC721: address zero is not a valid owner\");",
                        "        require(owner != address(0), \"ERC721: invalid token ID\");",
                        "        require(to != owner, \"ERC721: approval to current owner\");",
                        "        require(",
                        "            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),",
                        "            \"ERC721: approve caller is not token owner or approved for all\"",
                        "        );",
                        "        //solhint-disable-next-line max-line-length",
                        "        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");",
                        "        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");",
                        "        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");",
                        "        require(",
                        "            _checkOnERC721Received(address(0), to, tokenId, data),",
                        "            \"ERC721: transfer to non ERC721Receiver implementer\"",
                        "        );",
                        "        require(to != address(0), \"ERC721: mint to the zero address\");",
                        "        require(!_exists(tokenId), \"ERC721: token already minted\");",
                        "        require(!_exists(tokenId), \"ERC721: token already minted\");",
                        "        require(ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");",
                        "        require(to != address(0), \"ERC721: transfer to the zero address\");",
                        "        require(ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");",
                        "        require(owner != operator, \"ERC721: approve to caller\");",
                        "        require(_exists(tokenId), \"ERC721: invalid token ID\");",
                        "                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");",
                        "        //solhint-disable-next-line max-line-length",
                        "        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");",
                        "            require(address(this).code.length == 0, \"ERC721Consecutive: batch minting restricted to constructor\");",
                        "            require(to != address(0), \"ERC721Consecutive: mint to the zero address\");",
                        "            require(batchSize <= _maxBatchSize(), \"ERC721Consecutive: batch too large\");",
                        "        require(address(this).code.length > 0, \"ERC721Consecutive: can't mint during construction\");",
                        "            require(batchSize == 1, \"ERC721Consecutive: batch burn not supported\");",
                        "        require(index < balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");",
                        "        require(index < totalSupply(), \"ERC721Enumerable: global index out of bounds\");",
                        "            revert(\"ERC721Enumerable: consecutive transfers not supported\");",
                        "        require(!paused(), \"ERC721Pausable: token transfer while paused\");",
                        "        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");",
                        "            require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721Wrapper: caller is not token owner or approved\");",
                        "        require(address(underlying()) == _msgSender(), \"ERC721Wrapper: caller is not underlying\");",
                        "        require(underlying().ownerOf(tokenId) == address(this), \"ERC721Wrapper: wrapper is not token owner\");",
                        "        require(feeNumerator <= _feeDenominator(), \"ERC2981: royalty fee will exceed salePrice\");",
                        "        require(receiver != address(0), \"ERC2981: invalid receiver\");",
                        "        require(feeNumerator <= _feeDenominator(), \"ERC2981: royalty fee will exceed salePrice\");",
                        "        require(receiver != address(0), \"ERC2981: Invalid parameters\");",
                        "        require(address(this).balance >= amount, \"Address: insufficient balance\");",
                        "        require(success, \"Address: unable to send value, recipient may have reverted\");",
                        "        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");",
                        "     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with",
                        "     * `errorMessage` as a fallback revert reason when `target` reverts.",
                        "     * _Available since v3.1._",
                        "        string memory errorMessage",
                        "        return functionCallWithValue(target, data, 0, errorMessage);",
                        "        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");",
                        "     * with `errorMessage` as a fallback revert reason when `target` reverts.",
                        "     * _Available since v3.1._",
                        "        string memory errorMessage",
                        "        require(address(this).balance >= value, \"Address: insufficient balance for call\");",
                        "        return verifyCallResultFromTarget(target, success, returndata, errorMessage);",
                        "        return functionStaticCall(target, data, \"Address: low-level static call failed\");",
                        "        string memory errorMessage",
                        "        return verifyCallResultFromTarget(target, success, returndata, errorMessage);",
                        "        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");",
                        "        string memory errorMessage",
                        "        return verifyCallResultFromTarget(target, success, returndata, errorMessage);",
                        "     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.",
                        "     * _Available since v4.8._",
                        "        string memory errorMessage",
                        "                require(target.code.length > 0, \"Address: call to non-contract\");",
                        "            _revert(returndata, errorMessage);",
                        "     * revert reason or using the provided one.",
                        "     * _Available since v4.3._",
                        "        string memory errorMessage",
                        "    ) internal pure returns (bytes memory) {",
                        "            _revert(returndata, errorMessage);",
                        "    function _revert(bytes memory returndata, string memory errorMessage) private pure {",
                        "            revert(errorMessage);",
                        "        require(address(this).balance >= amount, \"Create2: insufficient balance\");",
                        "        require(bytecode.length != 0, \"Create2: bytecode length is zero\");",
                        "        require(addr != address(0), \"Create2: Failed on deploy\");",
                        " *         require(newImplementation.code.length > 0, \"ERC1967: new implementation is not a contract\");",
                        "            buffer[i] = _SYMBOLS[value & 0xf];",
                        "            value >>= 4;",
                        "        require(value == 0, \"Strings: hex length insufficient\");",
                        "    function _throwError(RecoverError error) private pure {",
                        "            revert(\"ECDSA: invalid signature\");",
                        "            revert(\"ECDSA: invalid signature length\");",
                        "            revert(\"ECDSA: invalid signature 's' value\");",
                        "    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {",
                        "            return (address(0), RecoverError.InvalidSignatureLength);",
                        "        (address recovered, RecoverError error) = tryRecover(hash, signature);",
                        "        _throwError(error);",
                        "    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {",
                        "        (address recovered, RecoverError error) = tryRecover(hash, r, vs);",
                        "        _throwError(error);",
                        "    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {",
                        "            return (address(0), RecoverError.InvalidSignatureS);",
                        "            return (address(0), RecoverError.InvalidSignature);",
                        "        return (signer, RecoverError.NoError);",
                        "        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);",
                        "        _throwError(error);",
                        "        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");",
                        "        require(leavesLen + proof.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");",
                        "        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);",
                        "            require(denominator > prod1, \"Math: mulDiv overflow\");",
                        "        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");",
                        "        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");",
                        "        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");",
                        "        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");",
                        "        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");",
                        "        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");",
                        "        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");",
                        "        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");",
                        "        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");",
                        "        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");",
                        "        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");",
                        "        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");",
                        "        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");",
                        "        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");",
                        "        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");",
                        "        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");",
                        "        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");",
                        "        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");",
                        "        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");",
                        "        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");",
                        "        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");",
                        "        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");",
                        "        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");",
                        "        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");",
                        "        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");",
                        "        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");",
                        "        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");",
                        "        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");",
                        "        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");",
                        "        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");",
                        "        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");",
                        "        require(value >= 0, \"SafeCast: value must be positive\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");",
                        "        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");",
                        "            require(last._key <= key, \"Checkpoint: decreasing keys\");",
                        "            require(last._key <= key, \"Checkpoint: decreasing keys\");",
                        "    error Empty();",
                        "    error OutOfBounds();",
                        "     * Reverts with `Empty` if the queue is empty.",
                        "        if (empty(deque)) revert Empty();",
                        "     * Reverts with `Empty` if the queue is empty.",
                        "        if (empty(deque)) revert Empty();",
                        "     * Reverts with `Empty` if the queue is empty.",
                        "        if (empty(deque)) revert Empty();",
                        "     * Reverts with `Empty` if the queue is empty.",
                        "        if (empty(deque)) revert Empty();",
                        "     * Reverts with `OutOfBounds` if the index is out of bounds.",
                        "        if (idx >= deque._end) revert OutOfBounds();",
                        "        require(value != 0 || contains(map, key), \"EnumerableMap: nonexistent key\");"
                    ]
                }
            }
        ],
        "- `Nonces`: Added a new contract to keep track of user nonces. Used for signatures in `ERC20Permit`, `ERC20Votes`, and `ERC721Votes`. ([#3816](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3816))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3816": {
                    "add": [
                        "abstract contract Votes is IVotes, Context, EIP712, Nonces {",
                        "     * @dev Get number of checkpoints for `account`.",
                        "    function _numCheckpoints(address account) internal view virtual returns (uint32) {",
                        "        return SafeCast.toUint32(_delegateCheckpoints[account].length());",
                        "     * @dev Get the `pos`-th checkpoint for `account`.",
                        "    function _checkpoints(address account, uint32 pos) internal view virtual returns (Checkpoints.Checkpoint memory) {",
                        "        return _delegateCheckpoints[account].getAtPosition(pos);",
                        "    }",
                        "    function _add(uint256 a, uint256 b) private pure returns (uint256) {",
                        "        return a + b;",
                        "    }",
                        "    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {",
                        "        return a - b;",
                        "    constructor(string memory name, string memory symbol) ERC20(name, symbol) EIP712(name, \"1\") {}",
                        "    constructor(string memory name, string memory symbol) ERC20(name, symbol) EIP712(name, \"1\") {}",
                        "    function burn(address, uint256 tokenId) public {",
                        "contract NoncesImpl is Nonces {",
                        "    function useNonce(address owner) public {",
                        "        super._useNonce(owner);",
                        "    }",
                        "}",
                        "    function burn(address, uint256 voteId) external {",
                        "abstract contract ERC20Permit is ERC20, IERC20Permit, EIP712, Nonces {",
                        "    function nonces(address owner) public view virtual override(IERC20Permit, Nonces) returns (uint256) {",
                        "        return super.nonces(owner);",
                        "abstract contract ERC20Votes is ERC20, Votes {",
                        "        _transferVotingUnits(from, to, amount);",
                        "     * @dev Get number of checkpoints for `account`.",
                        "    function numCheckpoints(address account) public view virtual returns (uint32) {",
                        "        return _numCheckpoints(account);",
                        "    /**",
                        "     * @dev Get the `pos`-th checkpoint for `account`.",
                        "     */",
                        "    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoints.Checkpoint memory) {",
                        "        return _checkpoints(account, pos);",
                        "    /**",
                        "     * @dev Returns the balance of `account`.",
                        "     */",
                        "    function _getVotingUnits(address account) internal view virtual override returns (uint256) {",
                        "        return balanceOf(account);",
                        "    /**",
                        "     * @dev Snapshots the totalSupply after it has been increased.",
                        "     */",
                        "    function _mint(address account, uint256 amount) internal virtual override {",
                        "        super._mint(account, amount);",
                        "        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");",
                        "    /**",
                        "     * @dev Returns checkpoint at given position.",
                        "     */",
                        "    function getAtPosition(History storage self, uint32 pos) internal view returns (Checkpoint memory) {",
                        "        return self._checkpoints[pos];",
                        "    }",
                        "/**",
                        " * @dev Provides tracking nonces for addresses. Nonces will only increment.",
                        " */",
                        "abstract contract Nonces {",
                        "    using Counters for Counters.Counter;",
                        "    mapping(address => Counters.Counter) private _nonces;",
                        "    /**",
                        "     * @dev Returns an address nonce.",
                        "     */",
                        "    function nonces(address owner) public view virtual returns (uint256) {",
                        "        return _nonces[owner].current();",
                        "    }",
                        "    /**",
                        "     * @dev Consumes a nonce.",
                        "     *",
                        "     * Returns the current value and increments nonce.",
                        "     */",
                        "    function _useNonce(address owner) internal virtual returns (uint256 current) {",
                        "        Counters.Counter storage nonce = _nonces[owner];",
                        "        current = nonce.current();",
                        "        nonce.increment();",
                        "    }",
                        "}"
                    ],
                    "del": [
                        "abstract contract Votes is IVotes, Context, EIP712 {",
                        "    using Counters for Counters.Counter;",
                        "    mapping(address => Counters.Counter) private _nonces;",
                        "    function _add(uint256 a, uint256 b) private pure returns (uint256) {",
                        "        return a + b;",
                        "    }",
                        "    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {",
                        "        return a - b;",
                        "    }",
                        "     * @dev Consumes a nonce.",
                        "     *",
                        "     * Returns the current value and increments nonce.",
                        "    function _useNonce(address owner) internal virtual returns (uint256 current) {",
                        "        Counters.Counter storage nonce = _nonces[owner];",
                        "        current = nonce.current();",
                        "        nonce.increment();",
                        "     * @dev Returns an address nonce.",
                        "    function nonces(address owner) public view virtual returns (uint256) {",
                        "        return _nonces[owner].current();",
                        "    constructor(string memory name, string memory symbol) ERC20(name, symbol) ERC20Permit(name) {}",
                        "    constructor(string memory name, string memory symbol) ERC20(name, symbol) ERC20Permit(name) {}",
                        "    function burn(uint256 tokenId) public {",
                        "    function burn(uint256 voteId) external {",
                        "abstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {",
                        "    using Counters for Counters.Counter;",
                        "    mapping(address => Counters.Counter) private _nonces;",
                        "    function nonces(address owner) public view virtual override returns (uint256) {",
                        "        return _nonces[owner].current();",
                        "    /**",
                        "     * @dev \"Consume a nonce\": return the current value and increment.",
                        "     *",
                        "     * _Available since v4.1._",
                        "     */",
                        "    function _useNonce(address owner) internal virtual returns (uint256 current) {",
                        "        Counters.Counter storage nonce = _nonces[owner];",
                        "        current = nonce.current();",
                        "        nonce.increment();",
                        "    }",
                        "abstract contract ERC20Votes is IVotes, ERC20Permit {",
                        "    struct Checkpoint {",
                        "        uint32 fromBlock;",
                        "        uint224 votes;",
                        "    }",
                        "    bytes32 private constant _DELEGATION_TYPEHASH =",
                        "        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");",
                        "    mapping(address => address) private _delegates;",
                        "    mapping(address => Checkpoint[]) private _checkpoints;",
                        "    Checkpoint[] private _totalSupplyCheckpoints;",
                        "    /**",
                        "     * @dev Get the `pos`-th checkpoint for `account`.",
                        "     */",
                        "    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {",
                        "        return _checkpoints[account][pos];",
                        "    }",
                        "    /**",
                        "     * @dev Get number of checkpoints for `account`.",
                        "     */",
                        "    function numCheckpoints(address account) public view virtual returns (uint32) {",
                        "        return SafeCast.toUint32(_checkpoints[account].length);",
                        "    }",
                        "    /**",
                        "     * @dev Get the address `account` is currently delegating to.",
                        "     */",
                        "    function delegates(address account) public view virtual override returns (address) {",
                        "        return _delegates[account];",
                        "    }",
                        "    /**",
                        "     * @dev Gets the current votes balance for `account`",
                        "     */",
                        "    function getVotes(address account) public view virtual override returns (uint256) {",
                        "        uint256 pos = _checkpoints[account].length;",
                        "        unchecked {",
                        "            return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `blockNumber` must have been already mined",
                        "     */",
                        "    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");",
                        "        return _checkpointsLookup(_checkpoints[account], blockNumber);",
                        "    }",
                        "    /**",
                        "     * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.",
                        "     * It is NOT the sum of all the delegated votes!",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `blockNumber` must have been already mined",
                        "     */",
                        "    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");",
                        "        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);",
                        "    }",
                        "    /**",
                        "     * @dev Lookup a value in a list of (sorted) checkpoints.",
                        "     */",
                        "    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {",
                        "        //",
                        "        uint256 length = ckpts.length;",
                        "        uint256 low = 0;",
                        "        uint256 high = length;",
                        "        if (length > 5) {",
                        "            uint256 mid = length - Math.sqrt(length);",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > blockNumber) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }",
                        "        }",
                        "        while (low < high) {",
                        "            uint256 mid = Math.average(low, high);",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > blockNumber) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }",
                        "        }",
                        "        unchecked {",
                        "            return high == 0 ? 0 : _unsafeAccess(ckpts, high - 1).votes;",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Delegate votes from the sender to `delegatee`.",
                        "     */",
                        "    function delegate(address delegatee) public virtual override {",
                        "        _delegate(_msgSender(), delegatee);",
                        "    }",
                        "    /**",
                        "     * @dev Delegates votes from signer to `delegatee`",
                        "     */",
                        "    function delegateBySig(",
                        "        address delegatee,",
                        "        uint256 nonce,",
                        "        uint256 expiry,",
                        "        uint8 v,",
                        "        bytes32 r,",
                        "        bytes32 s",
                        "    ) public virtual override {",
                        "        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");",
                        "        address signer = ECDSA.recover(",
                        "            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),",
                        "            v,",
                        "            r,",
                        "            s",
                        "        );",
                        "        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");",
                        "        _delegate(signer, delegatee);",
                        "    }",
                        "    /**",
                        "     * @dev Snapshots the totalSupply after it has been increased.",
                        "     */",
                        "    function _mint(address account, uint256 amount) internal virtual override {",
                        "        super._mint(account, amount);",
                        "        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");",
                        "        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);",
                        "    }",
                        "    /**",
                        "     * @dev Snapshots the totalSupply after it has been decreased.",
                        "     */",
                        "    function _burn(address account, uint256 amount) internal virtual override {",
                        "        super._burn(account, amount);",
                        "        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);",
                        "    }",
                        "        _moveVotingPower(delegates(from), delegates(to), amount);",
                        "     * @dev Change delegation for `delegator` to `delegatee`.",
                        "     *",
                        "     * Emits events {IVotes-DelegateChanged} and {IVotes-DelegateVotesChanged}.",
                        "    function _delegate(address delegator, address delegatee) internal virtual {",
                        "        address currentDelegate = delegates(delegator);",
                        "        uint256 delegatorBalance = balanceOf(delegator);",
                        "        _delegates[delegator] = delegatee;",
                        "        emit DelegateChanged(delegator, currentDelegate, delegatee);",
                        "        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);",
                        "    }",
                        "    function _moveVotingPower(",
                        "        address src,",
                        "        address dst,",
                        "        uint256 amount",
                        "    ) private {",
                        "        if (src != dst && amount > 0) {",
                        "            if (src != address(0)) {",
                        "                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);",
                        "                emit DelegateVotesChanged(src, oldWeight, newWeight);",
                        "            }",
                        "            if (dst != address(0)) {",
                        "                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);",
                        "                emit DelegateVotesChanged(dst, oldWeight, newWeight);",
                        "            }",
                        "        }",
                        "    }",
                        "    function _writeCheckpoint(",
                        "        Checkpoint[] storage ckpts,",
                        "        function(uint256, uint256) view returns (uint256) op,",
                        "        uint256 delta",
                        "    ) private returns (uint256 oldWeight, uint256 newWeight) {",
                        "        uint256 pos = ckpts.length;",
                        "        unchecked {",
                        "            Checkpoint memory oldCkpt = pos == 0 ? Checkpoint(0, 0) : _unsafeAccess(ckpts, pos - 1);",
                        "            oldWeight = oldCkpt.votes;",
                        "            newWeight = op(oldWeight, delta);",
                        "            if (pos > 0 && oldCkpt.fromBlock == block.number) {",
                        "                _unsafeAccess(ckpts, pos - 1).votes = SafeCast.toUint224(newWeight);",
                        "            } else {",
                        "                ckpts.push(",
                        "                    Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)})",
                        "                );",
                        "            }",
                        "        }",
                        "    function _add(uint256 a, uint256 b) private pure returns (uint256) {",
                        "        return a + b;",
                        "    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {",
                        "        return a - b;",
                        "    function _unsafeAccess(Checkpoint[] storage ckpts, uint256 pos) private pure returns (Checkpoint storage result) {",
                        "        assembly {",
                        "            mstore(0, ckpts.slot)",
                        "            result.slot := add(keccak256(0, 0x20), pos)",
                        "        }"
                    ]
                }
            }
        ],
        "- `Governor`: Add support for casting votes with ERC-1271 signatures by using a `bytes memory signature` instead of `r`, `s` and `v` arguments in the `castVoteBySig` and `castVoteWithReasonAndParamsBySig` functions. ([#4418](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4418))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4418": {
                    "add": [
                        "        bytes memory signature",
                        "        bool valid = SignatureChecker.isValidSignatureNow(",
                        "            voter,",
                        "            signature",
                        "        if (!valid) {",
                        "            revert GovernorInvalidSignature(voter);",
                        "        return _castVote(proposalId, voter, support, \"\");",
                        "        bytes memory signature",
                        "        bool valid = SignatureChecker.isValidSignatureNow(",
                        "            voter,",
                        "            signature",
                        "        if (!valid) {",
                        "            revert GovernorInvalidSignature(voter);",
                        "        return _castVote(proposalId, voter, support, reason, params);",
                        "     * @dev The provided signature is not valid for the expected `voter`.",
                        "     * If the `voter` is a contract, the signature is not valid using {IERC1271-isValidSignature}.",
                        "    error GovernorInvalidSignature(address voter);",
                        "     * @dev Cast a vote using the voter's signature, including ERC-1271 signature support.",
                        "        bytes memory signature",
                        "     * @dev Cast a vote with a reason and additional encoded parameters using the voter's signature,",
                        "     * including ERC-1271 signature support.",
                        "        bytes memory signature",
                        " * Argent and Safe Wallet (previously Gnosis Safe)."
                    ],
                    "del": [
                        "        uint8 v,",
                        "        bytes32 r,",
                        "        bytes32 s",
                        "        address signer = ECDSA.recover(",
                        "            v,",
                        "            r,",
                        "            s",
                        "        if (voter != signer) {",
                        "            revert GovernorInvalidSigner(signer, voter);",
                        "        return _castVote(proposalId, signer, support, \"\");",
                        "        uint8 v,",
                        "        bytes32 r,",
                        "        bytes32 s",
                        "        address signer = ECDSA.recover(",
                        "            v,",
                        "            r,",
                        "            s",
                        "        if (voter != signer) {",
                        "            revert GovernorInvalidSigner(signer, voter);",
                        "        return _castVote(proposalId, signer, support, reason, params);",
                        "     * @dev The `voter` doesn't match with the recovered `signer`.",
                        "    error GovernorInvalidSigner(address signer, address voter);",
                        "     * @dev Cast a vote using the user's cryptographic signature.",
                        "        uint8 v,",
                        "        bytes32 r,",
                        "        bytes32 s",
                        "     * @dev Cast a vote with a reason and additional encoded parameters using the user's cryptographic signature.",
                        "        uint8 v,",
                        "        bytes32 r,",
                        "        bytes32 s",
                        " * Argent and Gnosis Safe."
                    ]
                }
            }
        ],
        "- `GovernorTimelockControl`: Add the Governor instance address as part of the TimelockController operation `salt` to avoid operation id collisions between governors using the same TimelockController.\r": [],
        "- `ProxyAdmin`: Removed `getProxyAdmin` and `getProxyImplementation` getters. ([#3820](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3820))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3820": {
                    "add": [
                        "     *",
                        "     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the",
                        "     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.",
                        "     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`",
                        "     *",
                        "     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the",
                        "     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.",
                        "     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`"
                    ],
                    "del": [
                        "    /**",
                        "     * @dev Returns the current implementation of `proxy`.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - This contract must be the admin of `proxy`.",
                        "     */",
                        "    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {",
                        "        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");",
                        "        require(success);",
                        "        return abi.decode(returndata, (address));",
                        "    }",
                        "    /**",
                        "     * @dev Returns the current admin of `proxy`.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - This contract must be the admin of `proxy`.",
                        "     */",
                        "    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {",
                        "        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");",
                        "        require(success);",
                        "        return abi.decode(returndata, (address));",
                        "    }",
                        "    /**",
                        "     * @dev Returns the current admin.",
                        "     *",
                        "     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.",
                        "     *",
                        "     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the",
                        "     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.",
                        "     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`",
                        "     */",
                        "    function admin() external ifAdmin returns (address admin_) {",
                        "        admin_ = _getAdmin();",
                        "    }",
                        "    /**",
                        "     * @dev Returns the current implementation.",
                        "     *",
                        "     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.",
                        "     *",
                        "     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the",
                        "     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.",
                        "     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`",
                        "     */",
                        "    function implementation() external ifAdmin returns (address implementation_) {",
                        "        implementation_ = _implementation();",
                        "    }"
                    ]
                }
            }
        ],
        "- `ERC20Votes`: Changed internal vote accounting to reusable `Votes` module previously used by `ERC721Votes`. Removed implicit `ERC20Permit` inheritance. Note that the `DOMAIN_SEPARATOR` getter was previously guaranteed to be available for `ERC20Votes` contracts, but is no longer available unless `ERC20Permit` is explicitly used; ERC-5267 support is included in `ERC20Votes` with `EIP712` and is recommended as an alternative. ([#3816](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3816))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3816": {
                    "add": [
                        "abstract contract Votes is IVotes, Context, EIP712, Nonces {",
                        "     * @dev Get number of checkpoints for `account`.",
                        "    function _numCheckpoints(address account) internal view virtual returns (uint32) {",
                        "        return SafeCast.toUint32(_delegateCheckpoints[account].length());",
                        "     * @dev Get the `pos`-th checkpoint for `account`.",
                        "    function _checkpoints(address account, uint32 pos) internal view virtual returns (Checkpoints.Checkpoint memory) {",
                        "        return _delegateCheckpoints[account].getAtPosition(pos);",
                        "    }",
                        "    function _add(uint256 a, uint256 b) private pure returns (uint256) {",
                        "        return a + b;",
                        "    }",
                        "    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {",
                        "        return a - b;",
                        "    constructor(string memory name, string memory symbol) ERC20(name, symbol) EIP712(name, \"1\") {}",
                        "    constructor(string memory name, string memory symbol) ERC20(name, symbol) EIP712(name, \"1\") {}",
                        "    function burn(address, uint256 tokenId) public {",
                        "contract NoncesImpl is Nonces {",
                        "    function useNonce(address owner) public {",
                        "        super._useNonce(owner);",
                        "    }",
                        "}",
                        "    function burn(address, uint256 voteId) external {",
                        "abstract contract ERC20Permit is ERC20, IERC20Permit, EIP712, Nonces {",
                        "    function nonces(address owner) public view virtual override(IERC20Permit, Nonces) returns (uint256) {",
                        "        return super.nonces(owner);",
                        "abstract contract ERC20Votes is ERC20, Votes {",
                        "        _transferVotingUnits(from, to, amount);",
                        "     * @dev Get number of checkpoints for `account`.",
                        "    function numCheckpoints(address account) public view virtual returns (uint32) {",
                        "        return _numCheckpoints(account);",
                        "    /**",
                        "     * @dev Get the `pos`-th checkpoint for `account`.",
                        "     */",
                        "    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoints.Checkpoint memory) {",
                        "        return _checkpoints(account, pos);",
                        "    /**",
                        "     * @dev Returns the balance of `account`.",
                        "     */",
                        "    function _getVotingUnits(address account) internal view virtual override returns (uint256) {",
                        "        return balanceOf(account);",
                        "    /**",
                        "     * @dev Snapshots the totalSupply after it has been increased.",
                        "     */",
                        "    function _mint(address account, uint256 amount) internal virtual override {",
                        "        super._mint(account, amount);",
                        "        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");",
                        "    /**",
                        "     * @dev Returns checkpoint at given position.",
                        "     */",
                        "    function getAtPosition(History storage self, uint32 pos) internal view returns (Checkpoint memory) {",
                        "        return self._checkpoints[pos];",
                        "    }",
                        "/**",
                        " * @dev Provides tracking nonces for addresses. Nonces will only increment.",
                        " */",
                        "abstract contract Nonces {",
                        "    using Counters for Counters.Counter;",
                        "    mapping(address => Counters.Counter) private _nonces;",
                        "    /**",
                        "     * @dev Returns an address nonce.",
                        "     */",
                        "    function nonces(address owner) public view virtual returns (uint256) {",
                        "        return _nonces[owner].current();",
                        "    }",
                        "    /**",
                        "     * @dev Consumes a nonce.",
                        "     *",
                        "     * Returns the current value and increments nonce.",
                        "     */",
                        "    function _useNonce(address owner) internal virtual returns (uint256 current) {",
                        "        Counters.Counter storage nonce = _nonces[owner];",
                        "        current = nonce.current();",
                        "        nonce.increment();",
                        "    }",
                        "}"
                    ],
                    "del": [
                        "abstract contract Votes is IVotes, Context, EIP712 {",
                        "    using Counters for Counters.Counter;",
                        "    mapping(address => Counters.Counter) private _nonces;",
                        "    function _add(uint256 a, uint256 b) private pure returns (uint256) {",
                        "        return a + b;",
                        "    }",
                        "    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {",
                        "        return a - b;",
                        "    }",
                        "     * @dev Consumes a nonce.",
                        "     *",
                        "     * Returns the current value and increments nonce.",
                        "    function _useNonce(address owner) internal virtual returns (uint256 current) {",
                        "        Counters.Counter storage nonce = _nonces[owner];",
                        "        current = nonce.current();",
                        "        nonce.increment();",
                        "     * @dev Returns an address nonce.",
                        "    function nonces(address owner) public view virtual returns (uint256) {",
                        "        return _nonces[owner].current();",
                        "    constructor(string memory name, string memory symbol) ERC20(name, symbol) ERC20Permit(name) {}",
                        "    constructor(string memory name, string memory symbol) ERC20(name, symbol) ERC20Permit(name) {}",
                        "    function burn(uint256 tokenId) public {",
                        "    function burn(uint256 voteId) external {",
                        "abstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {",
                        "    using Counters for Counters.Counter;",
                        "    mapping(address => Counters.Counter) private _nonces;",
                        "    function nonces(address owner) public view virtual override returns (uint256) {",
                        "        return _nonces[owner].current();",
                        "    /**",
                        "     * @dev \"Consume a nonce\": return the current value and increment.",
                        "     *",
                        "     * _Available since v4.1._",
                        "     */",
                        "    function _useNonce(address owner) internal virtual returns (uint256 current) {",
                        "        Counters.Counter storage nonce = _nonces[owner];",
                        "        current = nonce.current();",
                        "        nonce.increment();",
                        "    }",
                        "abstract contract ERC20Votes is IVotes, ERC20Permit {",
                        "    struct Checkpoint {",
                        "        uint32 fromBlock;",
                        "        uint224 votes;",
                        "    }",
                        "    bytes32 private constant _DELEGATION_TYPEHASH =",
                        "        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");",
                        "    mapping(address => address) private _delegates;",
                        "    mapping(address => Checkpoint[]) private _checkpoints;",
                        "    Checkpoint[] private _totalSupplyCheckpoints;",
                        "    /**",
                        "     * @dev Get the `pos`-th checkpoint for `account`.",
                        "     */",
                        "    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {",
                        "        return _checkpoints[account][pos];",
                        "    }",
                        "    /**",
                        "     * @dev Get number of checkpoints for `account`.",
                        "     */",
                        "    function numCheckpoints(address account) public view virtual returns (uint32) {",
                        "        return SafeCast.toUint32(_checkpoints[account].length);",
                        "    }",
                        "    /**",
                        "     * @dev Get the address `account` is currently delegating to.",
                        "     */",
                        "    function delegates(address account) public view virtual override returns (address) {",
                        "        return _delegates[account];",
                        "    }",
                        "    /**",
                        "     * @dev Gets the current votes balance for `account`",
                        "     */",
                        "    function getVotes(address account) public view virtual override returns (uint256) {",
                        "        uint256 pos = _checkpoints[account].length;",
                        "        unchecked {",
                        "            return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `blockNumber` must have been already mined",
                        "     */",
                        "    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");",
                        "        return _checkpointsLookup(_checkpoints[account], blockNumber);",
                        "    }",
                        "    /**",
                        "     * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.",
                        "     * It is NOT the sum of all the delegated votes!",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `blockNumber` must have been already mined",
                        "     */",
                        "    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");",
                        "        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);",
                        "    }",
                        "    /**",
                        "     * @dev Lookup a value in a list of (sorted) checkpoints.",
                        "     */",
                        "    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {",
                        "        //",
                        "        uint256 length = ckpts.length;",
                        "        uint256 low = 0;",
                        "        uint256 high = length;",
                        "        if (length > 5) {",
                        "            uint256 mid = length - Math.sqrt(length);",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > blockNumber) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }",
                        "        }",
                        "        while (low < high) {",
                        "            uint256 mid = Math.average(low, high);",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > blockNumber) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }",
                        "        }",
                        "        unchecked {",
                        "            return high == 0 ? 0 : _unsafeAccess(ckpts, high - 1).votes;",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Delegate votes from the sender to `delegatee`.",
                        "     */",
                        "    function delegate(address delegatee) public virtual override {",
                        "        _delegate(_msgSender(), delegatee);",
                        "    }",
                        "    /**",
                        "     * @dev Delegates votes from signer to `delegatee`",
                        "     */",
                        "    function delegateBySig(",
                        "        address delegatee,",
                        "        uint256 nonce,",
                        "        uint256 expiry,",
                        "        uint8 v,",
                        "        bytes32 r,",
                        "        bytes32 s",
                        "    ) public virtual override {",
                        "        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");",
                        "        address signer = ECDSA.recover(",
                        "            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),",
                        "            v,",
                        "            r,",
                        "            s",
                        "        );",
                        "        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");",
                        "        _delegate(signer, delegatee);",
                        "    }",
                        "    /**",
                        "     * @dev Snapshots the totalSupply after it has been increased.",
                        "     */",
                        "    function _mint(address account, uint256 amount) internal virtual override {",
                        "        super._mint(account, amount);",
                        "        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");",
                        "        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);",
                        "    }",
                        "    /**",
                        "     * @dev Snapshots the totalSupply after it has been decreased.",
                        "     */",
                        "    function _burn(address account, uint256 amount) internal virtual override {",
                        "        super._burn(account, amount);",
                        "        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);",
                        "    }",
                        "        _moveVotingPower(delegates(from), delegates(to), amount);",
                        "     * @dev Change delegation for `delegator` to `delegatee`.",
                        "     *",
                        "     * Emits events {IVotes-DelegateChanged} and {IVotes-DelegateVotesChanged}.",
                        "    function _delegate(address delegator, address delegatee) internal virtual {",
                        "        address currentDelegate = delegates(delegator);",
                        "        uint256 delegatorBalance = balanceOf(delegator);",
                        "        _delegates[delegator] = delegatee;",
                        "        emit DelegateChanged(delegator, currentDelegate, delegatee);",
                        "        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);",
                        "    }",
                        "    function _moveVotingPower(",
                        "        address src,",
                        "        address dst,",
                        "        uint256 amount",
                        "    ) private {",
                        "        if (src != dst && amount > 0) {",
                        "            if (src != address(0)) {",
                        "                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);",
                        "                emit DelegateVotesChanged(src, oldWeight, newWeight);",
                        "            }",
                        "            if (dst != address(0)) {",
                        "                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);",
                        "                emit DelegateVotesChanged(dst, oldWeight, newWeight);",
                        "            }",
                        "        }",
                        "    }",
                        "    function _writeCheckpoint(",
                        "        Checkpoint[] storage ckpts,",
                        "        function(uint256, uint256) view returns (uint256) op,",
                        "        uint256 delta",
                        "    ) private returns (uint256 oldWeight, uint256 newWeight) {",
                        "        uint256 pos = ckpts.length;",
                        "        unchecked {",
                        "            Checkpoint memory oldCkpt = pos == 0 ? Checkpoint(0, 0) : _unsafeAccess(ckpts, pos - 1);",
                        "            oldWeight = oldCkpt.votes;",
                        "            newWeight = op(oldWeight, delta);",
                        "            if (pos > 0 && oldCkpt.fromBlock == block.number) {",
                        "                _unsafeAccess(ckpts, pos - 1).votes = SafeCast.toUint224(newWeight);",
                        "            } else {",
                        "                ckpts.push(",
                        "                    Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)})",
                        "                );",
                        "            }",
                        "        }",
                        "    function _add(uint256 a, uint256 b) private pure returns (uint256) {",
                        "        return a + b;",
                        "    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {",
                        "        return a - b;",
                        "    function _unsafeAccess(Checkpoint[] storage ckpts, uint256 pos) private pure returns (Checkpoint storage result) {",
                        "        assembly {",
                        "            mstore(0, ckpts.slot)",
                        "            result.slot := add(keccak256(0, 0x20), pos)",
                        "        }"
                    ]
                }
            }
        ],
        "- `ERC20`: Remove the non-standard `increaseAllowance` and `decreaseAllowance` functions. ([#4585](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4585))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4585": {
                    "add": [],
                    "del": [
                        " *",
                        " * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}",
                        " * functions have been added to mitigate the well-known issues around setting",
                        " * allowances. See {IERC20-approve}.",
                        "    /**",
                        "     * @dev Atomically increases the allowance granted to `spender` by the caller.",
                        "     *",
                        "     * This is an alternative to {approve} that can be used as a mitigation for",
                        "     * problems described in {IERC20-approve}.",
                        "     *",
                        "     * Emits an {Approval} event indicating the updated allowance.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `spender` cannot be the zero address.",
                        "     */",
                        "    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {",
                        "        address owner = _msgSender();",
                        "        _approve(owner, spender, allowance(owner, spender) + addedValue);",
                        "        return true;",
                        "    }",
                        "    /**",
                        "     * @dev Atomically decreases the allowance granted to `spender` by the caller.",
                        "     *",
                        "     * This is an alternative to {approve} that can be used as a mitigation for",
                        "     * problems described in {IERC20-approve}.",
                        "     *",
                        "     * Emits an {Approval} event indicating the updated allowance.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `spender` cannot be the zero address.",
                        "     * - `spender` must have allowance for the caller of at least",
                        "     * `requestedDecrease`.",
                        "     *",
                        "     * NOTE: Although this function is designed to avoid double spending with {approval},",
                        "     * it can still be frontrunned, preventing any attempt of allowance reduction.",
                        "     */",
                        "    function decreaseAllowance(address spender, uint256 requestedDecrease) public virtual returns (bool) {",
                        "        address owner = _msgSender();",
                        "        uint256 currentAllowance = allowance(owner, spender);",
                        "        if (currentAllowance < requestedDecrease) {",
                        "            revert ERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);",
                        "        }",
                        "        unchecked {",
                        "            _approve(owner, spender, currentAllowance - requestedDecrease);",
                        "        }",
                        "        return true;",
                        "    }"
                    ]
                }
            }
        ],
        "- `Governor`: Add `voter` and `nonce` parameters in signed ballots, to avoid forging signatures for random addresses, prevent signature replay, and allow invalidating signatures. Add `voter` as a new parameter in the `castVoteBySig` and `castVoteWithReasonAndParamsBySig` functions. ([#4378](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4378))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4378": {
                    "add": [
                        "abstract contract Governor is Context, ERC165, EIP712, Nonces, IGovernor, IERC721Receiver, IERC1155Receiver {",
                        "    bytes32 public constant BALLOT_TYPEHASH =",
                        "        keccak256(\"Ballot(uint256 proposalId,uint8 support,address voter,uint256 nonce)\");",
                        "        keccak256(",
                        "            \"ExtendedBallot(uint256 proposalId,uint8 support,address voter,uint256 nonce,string reason,bytes params)\"",
                        "        );",
                        "        address voter,",
                        "        address signer = ECDSA.recover(",
                        "            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support, voter, _useNonce(voter)))),",
                        "        if (voter != signer) {",
                        "            revert GovernorInvalidSigner(signer, voter);",
                        "        }",
                        "        return _castVote(proposalId, signer, support, \"\");",
                        "        address voter,",
                        "        address signer = ECDSA.recover(",
                        "                        voter,",
                        "                        _useNonce(voter),",
                        "        if (voter != signer) {",
                        "            revert GovernorInvalidSigner(signer, voter);",
                        "        }",
                        "        return _castVote(proposalId, signer, support, reason, params);",
                        "    /**",
                        "     * @dev The `voter` doesn't match with the recovered `signer`.",
                        "     */",
                        "    error GovernorInvalidSigner(address signer, address voter);",
                        "        address voter,",
                        "        address voter,"
                    ],
                    "del": [
                        "abstract contract Governor is Context, ERC165, EIP712, IGovernor, IERC721Receiver, IERC1155Receiver {",
                        "    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,uint8 support)\");",
                        "        keccak256(\"ExtendedBallot(uint256 proposalId,uint8 support,string reason,bytes params)\");",
                        "        address voter = ECDSA.recover(",
                        "            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),",
                        "        return _castVote(proposalId, voter, support, \"\");",
                        "        address voter = ECDSA.recover(",
                        "        return _castVote(proposalId, voter, support, reason, params);"
                    ]
                }
            }
        ],
        "- `TransparentUpgradeableProxy`: Removed `admin` and `implementation` getters, which were only callable by the proxy owner and thus not very useful. ([#3820](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3820))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3820": {
                    "add": [
                        "     *",
                        "     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the",
                        "     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.",
                        "     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`",
                        "     *",
                        "     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the",
                        "     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.",
                        "     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`"
                    ],
                    "del": [
                        "    /**",
                        "     * @dev Returns the current implementation of `proxy`.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - This contract must be the admin of `proxy`.",
                        "     */",
                        "    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {",
                        "        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"5c60da1b\");",
                        "        require(success);",
                        "        return abi.decode(returndata, (address));",
                        "    }",
                        "    /**",
                        "     * @dev Returns the current admin of `proxy`.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - This contract must be the admin of `proxy`.",
                        "     */",
                        "    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {",
                        "        (bool success, bytes memory returndata) = address(proxy).staticcall(hex\"f851a440\");",
                        "        require(success);",
                        "        return abi.decode(returndata, (address));",
                        "    }",
                        "    /**",
                        "     * @dev Returns the current admin.",
                        "     *",
                        "     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.",
                        "     *",
                        "     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the",
                        "     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.",
                        "     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`",
                        "     */",
                        "    function admin() external ifAdmin returns (address admin_) {",
                        "        admin_ = _getAdmin();",
                        "    }",
                        "    /**",
                        "     * @dev Returns the current implementation.",
                        "     *",
                        "     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.",
                        "     *",
                        "     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the",
                        "     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.",
                        "     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`",
                        "     */",
                        "    function implementation() external ifAdmin returns (address implementation_) {",
                        "        implementation_ = _implementation();",
                        "    }"
                    ]
                }
            }
        ],
        "- `ERC1155`: Remove check for address zero in `balanceOf`. ([#4263](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4263))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4263": {
                    "add": [],
                    "del": [
                        "        require(account != address(0), \"ERC1155: address zero is not a valid owner\");"
                    ]
                }
            }
        ],
        "- `ReentrancyGuard`, `Pausable`: Moved to `utils` directory. ([#4551](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4551))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4551": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- `BeaconProxy`: Reject value in initialization unless a payable function is explicitly invoked. ([#4382](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4382))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4382": {
                    "add": [
                        "contract UpgradeableBeaconMock is IBeacon {",
                        "    address public implementation;",
                        "    constructor(address impl) {",
                        "        implementation = impl;",
                        "    }",
                        "}",
                        "    function upgradeToAndCall(address, bytes calldata) external payable {",
                        "        ERC1967Utils.upgradeToAndCall(newImplementation, data);",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - If `data` is empty, `msg.value` must be zero.",
                        "        ERC1967Utils.upgradeToAndCall(_logic, _data);",
                        "    /**",
                        "     * @dev An upgrade function sees `msg.value > 0` that may be lost.",
                        "     */",
                        "    error ERC1967NonPayable();",
                        "     * @dev Performs implementation upgrade with additional setup call if data is nonempty.",
                        "     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected",
                        "     * to avoid stuck value in the contract.",
                        "    function upgradeToAndCall(address newImplementation, bytes memory data) internal {",
                        "        if (data.length > 0) {",
                        "        } else {",
                        "            _checkNonPayable();",
                        "     * @dev Change the beacon and trigger a setup call if data is nonempty.",
                        "     * This function is payable only if the setup call is performed, otherwise `msg.value` is rejected",
                        "     * to avoid stuck value in the contract.",
                        "    function upgradeBeaconToAndCall(address newBeacon, bytes memory data) internal {",
                        "        if (data.length > 0) {",
                        "        } else {",
                        "            _checkNonPayable();",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Reverts if `msg.value` is not zero.",
                        "     */",
                        "    function _checkNonPayable() private {",
                        "        if (msg.value > 0) {",
                        "            revert ERC1967NonPayable();",
                        "     * - If `data` is empty, `msg.value` must be zero.",
                        "        ERC1967Utils.upgradeBeaconToAndCall(beacon, data);",
                        "     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgrade(address)`",
                        "     * and `upgradeAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,",
                        "     * while `upgradeAndCall` will invoke the `receive` function if the second argument is the empty byte string.",
                        "     * If the getter returns `\"5.0.0\"`, only `upgradeAndCall(address,bytes)` is present, and the second argument must",
                        "     * be the empty byte string if no function should be called, being impossible to invoke the `receive` function",
                        "     * during an upgrade.",
                        "    string public constant UPGRADE_INTERFACE_VERSION = \"5.0.0\";",
                        "     * @dev Sets the initial owner who can perform upgrades.",
                        "    constructor(address initialOwner) Ownable(initialOwner) {}",
                        "     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation.",
                        "     * See {TransparentUpgradeableProxy-_dispatchUpgradeToAndCall}.",
                        "     * - If `data` is empty, `msg.value` must be zero.",
                        " * does not implement this interface directly, and its upgradeability mechanism is implemented by an internal dispatch",
                        "    function upgradeToAndCall(address, bytes calldata) external payable;",
                        " * @dev This contract implements a proxy that is upgradeable through an associated {ProxyAdmin} instance.",
                        " * that call matches the {ITransparentUpgradeableProxy-upgradeToAndCall} function exposed by the proxy itself.",
                        " * 2. If the admin calls the proxy, it can call the `upgradeToAndCall` function but any other call won't be forwarded to the",
                        " * from the proxy implementation. For this reason, the proxy deploys an instance of {ProxyAdmin} and allows upgrades",
                        " * only if they come through it.",
                        " * You should think of the `ProxyAdmin` instance as the administrative interface of the proxy, including the ability to",
                        " * change who can trigger upgrades by transferring ownership.",
                        " * inherit from that interface, and instead `upgradeToAndCall` is implicitly implemented using a custom dispatch mechanism",
                        " * in `_fallback`. Consequently, the compiler will not produce an ABI for this contract. This is necessary to fully",
                        " * implement transparency without decoding reverts caused by selector clashes between the proxy and the",
                        " * render the `upgradeToAndCall` function inaccessible, preventing upgradeability and compromising transparency.",
                        "     * @dev Initializes an upgradeable proxy managed by an instance of a {ProxyAdmin} with an `initialOwner`,",
                        "     * backed by the implementation at `_logic`, and optionally initialized with `_data` as explained in",
                        "     * {ERC1967Proxy-constructor}.",
                        "    constructor(address _logic, address initialOwner, bytes memory _data) payable ERC1967Proxy(_logic, _data) {",
                        "        _admin = address(new ProxyAdmin(initialOwner));",
                        "        ERC1967Utils.changeAdmin(_admin);",
                        "     * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior.",
                        "            if (msg.sig == ITransparentUpgradeableProxy.upgradeToAndCall.selector) {",
                        "                _dispatchUpgradeToAndCall();",
                        "     * @dev Upgrade the implementation of the proxy. See {ERC1967Utils-upgradeToAndCall}.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - If `data` is empty, `msg.value` must be zero.",
                        "    function _dispatchUpgradeToAndCall() private {",
                        "        ERC1967Utils.upgradeToAndCall(newImplementation, data);",
                        "    /**",
                        "     * @dev The version of the upgrade interface of the contract. If this getter is missing, both `upgradeTo(address)`",
                        "     * and `upgradeToAndCall(address,bytes)` are present, and `upgradeTo` must be used if no function should be called,",
                        "     * while `upgradeToAndCall` will invoke the `receive` function if the second argument is the empty byte string.",
                        "     * If the getter returns `\"5.0.0\"`, only `upgradeToAndCall(address,bytes)` is present, and the second argument must",
                        "     * be the empty byte string if no function should be called, being impossible to invoke the `receive` function",
                        "     * during an upgrade.",
                        "     */",
                        "    string public constant UPGRADE_INTERFACE_VERSION = \"5.0.0\";",
                        "        _upgradeToAndCallUUPS(newImplementation, data);",
                        "     * {upgradeToAndCall}.",
                        "     * function _authorizeUpgrade(address) internal onlyOwner {}",
                        "    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data) private {",
                        "            ERC1967Utils.upgradeToAndCall(newImplementation, data);"
                    ],
                    "del": [
                        "    function upgradeTo(address) external payable {",
                        "    function upgradeTo(address newImplementation) public override {",
                        "        ERC1967Utils.upgradeToAndCall(newImplementation, bytes(\"\"), false);",
                        "    }",
                        "        ERC1967Utils.upgradeToAndCall(newImplementation, data, false);",
                        "        ERC1967Utils.upgradeToAndCall(_logic, _data, false);",
                        "     * @dev Perform implementation upgrade",
                        "    function upgradeTo(address newImplementation) internal {",
                        "    }",
                        "    /**",
                        "     * @dev Perform implementation upgrade with additional setup call.",
                        "     *",
                        "     * Emits an {IERC1967-Upgraded} event.",
                        "     */",
                        "    function upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {",
                        "        upgradeTo(newImplementation);",
                        "        if (data.length > 0 || forceCall) {",
                        "     * @dev Change the beacon and trigger a setup call.",
                        "    function upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {",
                        "        if (data.length > 0 || forceCall) {",
                        "        ERC1967Utils.upgradeBeaconToAndCall(beacon, data, false);",
                        "     * @dev Sets the initial owner who can perform upgrades.",
                        "    constructor(address initialOwner) Ownable(initialOwner) {}",
                        "     * @dev Upgrades `proxy` to `implementation`. See {TransparentUpgradeableProxy-upgradeTo}.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - This contract must be the admin of `proxy`.",
                        "    function upgrade(ITransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {",
                        "        proxy.upgradeTo(implementation);",
                        "    }",
                        "     * @dev Upgrades `proxy` to `implementation` and calls a function on the new implementation. See",
                        "     * {TransparentUpgradeableProxy-upgradeToAndCall}.",
                        " * does not implement this interface directly, and some of its functions are implemented by an internal dispatch",
                        "    function upgradeTo(address) external;",
                        "    function upgradeToAndCall(address, bytes memory) external payable;",
                        " * @dev This contract implements a proxy that is upgradeable by an immutable admin.",
                        " * that call matches one of the admin functions exposed by the proxy itself.",
                        " * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the",
                        " * from the proxy implementation.",
                        " *",
                        " * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,",
                        " * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy, which extends from the",
                        " * {Ownable} contract to allow for changing the proxy's admin owner.",
                        " * inherit from that interface, and instead the admin functions are implicitly implemented using a custom dispatch",
                        " * mechanism in `_fallback`. Consequently, the compiler will not produce an ABI for this contract. This is necessary to",
                        " * fully implement transparency without decoding reverts caused by selector clashes between the proxy and the",
                        " * render the admin operations inaccessible, which could prevent upgradeability. Transparency may also be compromised.",
                        "     * @dev msg.value is not 0.",
                        "     */",
                        "    error ProxyNonPayableFunction();",
                        "    /**",
                        "     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and",
                        "     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.",
                        "    constructor(address _logic, address admin_, bytes memory _data) payable ERC1967Proxy(_logic, _data) {",
                        "        _admin = admin_;",
                        "        ERC1967Utils.changeAdmin(admin_);",
                        "     * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior",
                        "            bytes memory ret;",
                        "            bytes4 selector = msg.sig;",
                        "            if (selector == ITransparentUpgradeableProxy.upgradeTo.selector) {",
                        "                ret = _dispatchUpgradeTo();",
                        "            } else if (selector == ITransparentUpgradeableProxy.upgradeToAndCall.selector) {",
                        "                ret = _dispatchUpgradeToAndCall();",
                        "            assembly {",
                        "                return(add(ret, 0x20), mload(ret))",
                        "            }",
                        "     * @dev Upgrade the implementation of the proxy.",
                        "     */",
                        "    function _dispatchUpgradeTo() private returns (bytes memory) {",
                        "        _requireZeroValue();",
                        "        address newImplementation = abi.decode(msg.data[4:], (address));",
                        "        ERC1967Utils.upgradeToAndCall(newImplementation, bytes(\"\"), false);",
                        "        return \"\";",
                        "    }",
                        "    /**",
                        "     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified",
                        "     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the",
                        "     * proxied contract.",
                        "    function _dispatchUpgradeToAndCall() private returns (bytes memory) {",
                        "        ERC1967Utils.upgradeToAndCall(newImplementation, data, true);",
                        "        return \"\";",
                        "    }",
                        "    /**",
                        "     * @dev To keep this contract fully transparent, the fallback is payable. This helper is here to enforce",
                        "     * non-payability of function implemented through dispatchers while still allowing value to pass through.",
                        "     */",
                        "    function _requireZeroValue() private {",
                        "        if (msg.value != 0) {",
                        "            revert ProxyNonPayableFunction();",
                        "        }",
                        "    /**",
                        "     * @dev Upgrade the implementation of the proxy to `newImplementation`.",
                        "     *",
                        "     * Calls {_authorizeUpgrade}.",
                        "     *",
                        "     * Emits an {Upgraded} event.",
                        "     *",
                        "     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall",
                        "     */",
                        "    function upgradeTo(address newImplementation) public virtual onlyProxy {",
                        "        _authorizeUpgrade(newImplementation);",
                        "        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);",
                        "    }",
                        "        _upgradeToAndCallUUPS(newImplementation, data, true);",
                        "     * {upgradeTo} and {upgradeToAndCall}.",
                        "     * function _authorizeUpgrade(address) internal  onlyOwner {}",
                        "    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) private {",
                        "            ERC1967Utils.upgradeToAndCall(newImplementation, data, forceCall);"
                    ]
                }
            }
        ],
        "- `Initializable`: Use the namespaced storage pattern to avoid putting critical variables in slot 0. Allow reinitializer versions greater than 256. ([#4460](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4460))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4460": {
                    "add": [
                        "    function getInitializedVersion() public view returns (uint64) {",
                        "    function reinitialize(uint64 i) public reinitializer(i) {",
                        "    function nestedReinitialize(uint64 i, uint64 j) public reinitializer(i) {",
                        "    function chainReinitialize(uint64 i, uint64 j) public {",
                        "     * @dev Storage of the initializable contract.",
                        "     *",
                        "     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions",
                        "     * when using with upgradeable contracts.",
                        "     *",
                        "     * @custom:storage-location erc7201:openzeppelin.storage.Initializable",
                        "    struct InitializableStorage {",
                        "        /**",
                        "         * @dev Indicates that the contract has been initialized.",
                        "         */",
                        "        uint64 _initialized;",
                        "        /**",
                        "         * @dev Indicates that the contract is in the process of being initialized.",
                        "         */",
                        "        bool _initializing;",
                        "    }",
                        "    bytes32 private constant _INITIALIZABLE_STORAGE =",
                        "        0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a0e;",
                        "    event Initialized(uint64 version);",
                        "        InitializableStorage storage $ = _getInitializableStorage();",
                        "        bool isTopLevelCall = !$._initializing;",
                        "        if (!(isTopLevelCall && $._initialized < 1) && !(address(this).code.length == 0 && $._initialized == 1)) {",
                        "        $._initialized = 1;",
                        "            $._initializing = true;",
                        "            $._initializing = false;",
                        "    modifier reinitializer(uint64 version) {",
                        "        InitializableStorage storage $ = _getInitializableStorage();",
                        "        if ($._initializing || $._initialized >= version) {",
                        "        $._initialized = version;",
                        "        $._initializing = true;",
                        "        $._initializing = false;",
                        "        if (!_isInitializing()) {",
                        "        InitializableStorage storage $ = _getInitializableStorage();",
                        "        if ($._initializing) {",
                        "        if ($._initialized != type(uint64).max) {",
                        "            $._initialized = type(uint64).max;",
                        "            emit Initialized(type(uint64).max);",
                        "    function _getInitializedVersion() internal view returns (uint64) {",
                        "        return _getInitializableStorage()._initialized;",
                        "        return _getInitializableStorage()._initializing;",
                        "    }",
                        "    /**",
                        "     * @dev Returns a pointer to the storage namespace.",
                        "     */",
                        "    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {",
                        "        assembly {",
                        "            $.slot := _INITIALIZABLE_STORAGE",
                        "        }"
                    ],
                    "del": [
                        "    function getInitializedVersion() public view returns (uint8) {",
                        "    function reinitialize(uint8 i) public reinitializer(i) {",
                        "    function nestedReinitialize(uint8 i, uint8 j) public reinitializer(i) {",
                        "    function chainReinitialize(uint8 i, uint8 j) public {",
                        "     * @dev Indicates that the contract has been initialized.",
                        "    uint8 private _initialized;",
                        "    /**",
                        "     * @dev Indicates that the contract is in the process of being initialized.",
                        "     */",
                        "    bool private _initializing;",
                        "    event Initialized(uint8 version);",
                        "        bool isTopLevelCall = !_initializing;",
                        "        if (!(isTopLevelCall && _initialized < 1) && !(address(this).code.length == 0 && _initialized == 1)) {",
                        "        _initialized = 1;",
                        "            _initializing = true;",
                        "            _initializing = false;",
                        "    modifier reinitializer(uint8 version) {",
                        "        if (_initializing || _initialized >= version) {",
                        "        _initialized = version;",
                        "        _initializing = true;",
                        "        _initializing = false;",
                        "        if (!_initializing) {",
                        "        if (_initializing) {",
                        "        if (_initialized != type(uint8).max) {",
                        "            _initialized = type(uint8).max;",
                        "            emit Initialized(type(uint8).max);",
                        "    function _getInitializedVersion() internal view returns (uint8) {",
                        "        return _initialized;",
                        "        return _initializing;"
                    ]
                }
            }
        ],
        "- `GovernorTimelockAccess`: Added a module to connect a governor with an instance of `AccessManager`, allowing the governor to make calls that are delay-restricted by the manager using the normal `queue` workflow. ([#4523](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4523))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4523": {
                    "add": [
                        "    struct Schedule {",
                        "        uint48 timepoint;",
                        "        uint32 nonce;",
                        "    }",
                        "    mapping(bytes32 operationId => Schedule) private _schedules;",
                        "        uint48 timepoint = _schedules[id].timepoint;",
                        "    /**",
                        "     * @dev Return the nonce for the latest scheduled operation with a given id. Returns 0 if the operation has never",
                        "     * been scheduled.",
                        "     */",
                        "    function getNonce(bytes32 id) public view virtual returns (uint32) {",
                        "        return _schedules[id].nonce;",
                        "    }",
                        "     * Returns the `operationId` that was scheduled. Since this value is a hash of the parameters, it can reoccur when",
                        "     * the same parameters are used; if this is relevant, the returned `nonce` can be used to uniquely identify this",
                        "     * scheduled operation from other occurrences of the same `operationId` in invocations of {relay} and {cancel}.",
                        "     *",
                        "    function schedule(",
                        "        address target,",
                        "        bytes calldata data,",
                        "        uint48 when",
                        "    ) public virtual returns (bytes32 operationId, uint32 nonce) {",
                        "        if (when == 0) {",
                        "            when = minWhen;",
                        "        }",
                        "        if (!allowed && (setback == 0 || when < minWhen)) {",
                        "        operationId = _hashOperation(caller, target, data);",
                        "        uint48 prevTimepoint = _schedules[operationId].timepoint;",
                        "        unchecked {",
                        "            nonce = _schedules[operationId].nonce + 1;",
                        "        }",
                        "        _schedules[operationId].timepoint = when;",
                        "        _schedules[operationId].nonce = nonce;",
                        "        emit OperationScheduled(operationId, nonce, when, caller, target, data);",
                        "     * Returns the nonce that identifies the previously scheduled operation that is relayed, or 0 if the",
                        "     * operation wasn't previously scheduled (if the caller doesn't have an execution delay).",
                        "     *",
                        "    function relay(address target, bytes calldata data) public payable virtual returns (uint32) {",
                        "        uint32 nonce;",
                        "            nonce = _consumeScheduledOp(operationId);",
                        "        return nonce;",
                        "     *",
                        "     * Returns the nonce of the scheduled operation that is consumed.",
                        "    function _consumeScheduledOp(bytes32 operationId) internal virtual returns (uint32) {",
                        "        uint48 timepoint = _schedules[operationId].timepoint;",
                        "        uint32 nonce = _schedules[operationId].nonce;",
                        "        emit OperationExecuted(operationId, nonce);",
                        "        return nonce;",
                        "     * @dev Cancel a scheduled (delayed) operation. Returns the nonce that identifies the previously scheduled",
                        "     * operation that is cancelled.",
                        "    function cancel(address caller, address target, bytes calldata data) public virtual returns (uint32) {",
                        "        if (_schedules[operationId].timepoint == 0) {",
                        "        delete _schedules[operationId].timepoint;",
                        "        uint32 nonce = _schedules[operationId].nonce;",
                        "        emit OperationCanceled(operationId, nonce);",
                        "        return nonce;",
                        "    event OperationScheduled(",
                        "        bytes32 indexed operationId,",
                        "        uint32 indexed nonce,",
                        "        uint48 schedule,",
                        "        address caller,",
                        "        address target,",
                        "        bytes data",
                        "    );",
                        "    event OperationExecuted(bytes32 indexed operationId, uint32 indexed nonce);",
                        "    event OperationCanceled(bytes32 indexed operationId, uint32 indexed nonce);",
                        "    function getNonce(bytes32 id) external returns (uint32);",
                        "    function schedule(address target, bytes calldata data, uint48 when) external returns (bytes32, uint32);",
                        "    function relay(address target, bytes calldata data) external payable returns (uint32);",
                        "    function cancel(address caller, address target, bytes calldata data) external returns (uint32);",
                        "    function name() public view virtual returns (string memory) {",
                        "    function version() public view virtual returns (string memory) {",
                        "    ) public pure virtual returns (uint256) {",
                        "    function state(uint256 proposalId) public view virtual returns (ProposalState) {",
                        "    function proposalThreshold() public view virtual returns (uint256) {",
                        "    function proposalSnapshot(uint256 proposalId) public view virtual returns (uint256) {",
                        "    function proposalDeadline(uint256 proposalId) public view virtual returns (uint256) {",
                        "    function proposalProposer(uint256 proposalId) public view virtual returns (address) {",
                        "    function proposalEta(uint256 proposalId) public view virtual returns (uint256) {",
                        "    /**",
                        "     * @dev See {IGovernor-proposalNeedsQueuing}.",
                        "     */",
                        "    function proposalNeedsQueuing(uint256) public view virtual returns (bool) {",
                        "        return false;",
                        "    }",
                        "    ) public virtual returns (uint256) {",
                        "    ) public virtual returns (uint256) {",
                        "    ) public payable virtual returns (uint256) {",
                        "    ) public virtual returns (uint256) {",
                        "    function getVotes(address account, uint256 timepoint) public view virtual returns (uint256) {",
                        "    ) public view virtual returns (uint256) {",
                        "    function castVote(uint256 proposalId, uint8 support) public virtual returns (uint256) {",
                        "    ) public virtual returns (uint256) {",
                        "    ) public virtual returns (uint256) {",
                        "    ) public virtual returns (uint256) {",
                        "    ) public virtual returns (uint256) {",
                        "    /**",
                        "     * @notice module:core",
                        "     * @dev Whether a proposal needs to be queued before execution.",
                        "     */",
                        "    function proposalNeedsQueuing(uint256 proposalId) external view returns (bool);",
                        "/**",
                        " * @dev This module connects a {Governor} instance to an {AccessManager} instance, allowing the governor to make calls",
                        " * that are delay-restricted by the manager using the normal {queue} workflow. An optional base delay is applied to",
                        " * operations that are not delayed externally by the manager. Execution of a proposal will be delayed as much as",
                        " * necessary to meet the required delays of all of its operations.",
                        " *",
                        " * This extension allows the governor to hold and use its own assets and permissions, unlike {GovernorTimelockControl}",
                        " * and {GovernorTimelockCompound}, where the timelock is a separate contract that must be the one to hold assets and",
                        " * permissions. Operations that are delay-restricted by the manager, however, will be executed through the",
                        " * {AccessManager-relay} function.",
                        " *",
                        " * Note that some operations may be cancelable in the {AccessManager} by the admin or a set of guardians, depending on",
                        " * the restricted operation being invoked. Since proposals are atomic, the cancellation by a guardian of a single",
                        " * operation in a proposal will cause all of it to become unable to execute.",
                        " */",
                        "abstract contract GovernorTimelockAccess is Governor {",
                        "    struct ExecutionPlan {",
                        "        uint16 length;",
                        "        uint32 delay;",
                        "        mapping(uint256 operationBucket => uint32[8]) managerData;",
                        "    }",
                        "    mapping(uint256 proposalId => ExecutionPlan) private _executionPlan;",
                        "    uint32 private _baseDelay;",
                        "    IAccessManager private immutable _manager;",
                        "    error GovernorUnmetDelay(uint256 proposalId, uint256 neededTimestamp);",
                        "    error GovernorMismatchedNonce(uint256 proposalId, uint256 expectedNonce, uint256 actualNonce);",
                        "    event BaseDelaySet(uint32 oldBaseDelaySeconds, uint32 newBaseDelaySeconds);",
                        "    /**",
                        "     * @dev Initialize the governor with an {AccessManager} and initial base delay.",
                        "     */",
                        "    constructor(address manager, uint32 initialBaseDelay) {",
                        "        _manager = IAccessManager(manager);",
                        "        _setBaseDelaySeconds(initialBaseDelay);",
                        "    }",
                        "    /**",
                        "     * @dev Returns the {AccessManager} instance associated to this governor.",
                        "     */",
                        "    function accessManager() public view virtual returns (IAccessManager) {",
                        "        return _manager;",
                        "    }",
                        "    /**",
                        "     * @dev Base delay that will be applied to all function calls. Some may be further delayed by their associated",
                        "     * `AccessManager` authority; in this case the final delay will be the maximum of the base delay and the one",
                        "     * demanded by the authority.",
                        "     *",
                        "     * NOTE: Execution delays are processed by the `AccessManager` contracts, and according to that contract are",
                        "     * expressed in seconds. Therefore, the base delay is also in seconds, regardless of the governor's clock mode.",
                        "     */",
                        "    function baseDelaySeconds() public view virtual returns (uint32) {",
                        "        return _baseDelay;",
                        "    }",
                        "    /**",
                        "     * @dev Change the value of {baseDelaySeconds}. This operation can only be invoked through a governance proposal.",
                        "     */",
                        "    function setBaseDelaySeconds(uint32 newBaseDelay) public virtual onlyGovernance {",
                        "        _setBaseDelaySeconds(newBaseDelay);",
                        "    }",
                        "    /**",
                        "     * @dev Change the value of {baseDelaySeconds}. Internal function without access control.",
                        "     */",
                        "    function _setBaseDelaySeconds(uint32 newBaseDelay) internal virtual {",
                        "        emit BaseDelaySet(_baseDelay, newBaseDelay);",
                        "        _baseDelay = newBaseDelay;",
                        "    }",
                        "    /**",
                        "     * @dev Public accessor to check the execution plan, including the number of seconds that the proposal will be",
                        "     * delayed since queuing, and an array indicating which of the proposal actions will be executed indirectly through",
                        "     * the associated {AccessManager}.",
                        "     */",
                        "    function proposalExecutionPlan(uint256 proposalId) public view returns (uint32, bool[] memory) {",
                        "        ExecutionPlan storage plan = _executionPlan[proposalId];",
                        "        uint32 delay = plan.delay;",
                        "        uint32 length = plan.length;",
                        "        bool[] memory indirect = new bool[](length);",
                        "        for (uint256 i = 0; i < length; ++i) {",
                        "            (indirect[i], ) = _getManagerData(plan, i);",
                        "        }",
                        "        return (delay, indirect);",
                        "    }",
                        "    /**",
                        "     * @dev See {IGovernor-proposalNeedsQueuing}.",
                        "     */",
                        "    function proposalNeedsQueuing(uint256 proposalId) public view virtual override returns (bool) {",
                        "        return _executionPlan[proposalId].delay > 0;",
                        "    }",
                        "    /**",
                        "     * @dev See {IGovernor-propose}",
                        "     */",
                        "    function propose(",
                        "        address[] memory targets,",
                        "        uint256[] memory values,",
                        "        bytes[] memory calldatas,",
                        "        string memory description",
                        "    ) public virtual override returns (uint256) {",
                        "        uint256 proposalId = super.propose(targets, values, calldatas, description);",
                        "        uint32 neededDelay = baseDelaySeconds();",
                        "        ExecutionPlan storage plan = _executionPlan[proposalId];",
                        "        plan.length = SafeCast.toUint16(targets.length);",
                        "        for (uint256 i = 0; i < targets.length; ++i) {",
                        "            uint32 delay = _detectExecutionRequirements(targets[i], bytes4(calldatas[i]));",
                        "            if (delay > 0) {",
                        "                _setManagerData(plan, i, 0);",
                        "            }",
                        "            neededDelay = uint32(Math.max(delay, neededDelay));",
                        "        }",
                        "        plan.delay = neededDelay;",
                        "        return proposalId;",
                        "    }",
                        "    /**",
                        "     * @dev Mechanism to queue a proposal, potentially scheduling some of its operations in the AccessManager.",
                        "     *",
                        "     * NOTE: The execution delay is chosen based on the delay information retrieved in {propose}. This value may be",
                        "     * off if the delay was updated since proposal creation. In this case, the proposal needs to be recreated.",
                        "     */",
                        "    function _queueOperations(",
                        "        uint256 proposalId,",
                        "        address[] memory targets,",
                        "        uint256[] memory /* values */,",
                        "        bytes[] memory calldatas,",
                        "        bytes32 /* descriptionHash */",
                        "    ) internal virtual override returns (uint48) {",
                        "        ExecutionPlan storage plan = _executionPlan[proposalId];",
                        "        uint48 eta = Time.timestamp() + plan.delay;",
                        "        for (uint256 i = 0; i < targets.length; ++i) {",
                        "            (bool delayed, ) = _getManagerData(plan, i);",
                        "            if (delayed) {",
                        "                (, uint32 nonce) = _manager.schedule(targets[i], calldatas[i], eta);",
                        "                _setManagerData(plan, i, nonce);",
                        "            }",
                        "        }",
                        "        return eta;",
                        "    }",
                        "    /**",
                        "     * @dev Mechanism to execute a proposal, potentially going through {AccessManager-relay} for delayed operations.",
                        "     */",
                        "    function _executeOperations(",
                        "        uint256 proposalId,",
                        "        address[] memory targets,",
                        "        uint256[] memory values,",
                        "        bytes[] memory calldatas,",
                        "        bytes32 /* descriptionHash */",
                        "    ) internal virtual override {",
                        "        uint48 eta = SafeCast.toUint48(proposalEta(proposalId));",
                        "        if (block.timestamp < eta) {",
                        "            revert GovernorUnmetDelay(proposalId, eta);",
                        "        }",
                        "        ExecutionPlan storage plan = _executionPlan[proposalId];",
                        "        for (uint256 i = 0; i < targets.length; ++i) {",
                        "            (bool delayed, uint32 nonce) = _getManagerData(plan, i);",
                        "            if (delayed) {",
                        "                uint32 relayedNonce = _manager.relay{value: values[i]}(targets[i], calldatas[i]);",
                        "                if (relayedNonce != nonce) {",
                        "                    revert GovernorMismatchedNonce(proposalId, nonce, relayedNonce);",
                        "                }",
                        "            } else {",
                        "                (bool success, bytes memory returndata) = targets[i].call{value: values[i]}(calldatas[i]);",
                        "                Address.verifyCallResult(success, returndata);",
                        "            }",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev See {IGovernor-_cancel}",
                        "     */",
                        "    function _cancel(",
                        "        address[] memory targets,",
                        "        uint256[] memory values,",
                        "        bytes[] memory calldatas,",
                        "        bytes32 descriptionHash",
                        "    ) internal virtual override returns (uint256) {",
                        "        uint256 proposalId = super._cancel(targets, values, calldatas, descriptionHash);",
                        "        uint48 eta = SafeCast.toUint48(proposalEta(proposalId));",
                        "        ExecutionPlan storage plan = _executionPlan[proposalId];",
                        "        if (eta != 0) {",
                        "            for (uint256 i = 0; i < targets.length; ++i) {",
                        "                (bool delayed, uint32 nonce) = _getManagerData(plan, i);",
                        "                if (delayed) {",
                        "                    uint32 canceledNonce = _manager.cancel(address(this), targets[i], calldatas[i]);",
                        "                    if (canceledNonce != nonce) {",
                        "                        revert GovernorMismatchedNonce(proposalId, nonce, canceledNonce);",
                        "                    }",
                        "                }",
                        "            }",
                        "        }",
                        "        return proposalId;",
                        "    }",
                        "    /**",
                        "     * @dev Check if the execution of a call needs to be performed through an AccessManager and what delay should be",
                        "     * applied to this call.",
                        "     *",
                        "     * Returns { manager: address(0), delay: 0 } if:",
                        "     * - target does not have code",
                        "     * - target does not implement IAccessManaged",
                        "     * - calling canCall on the target's manager returns a 0 delay",
                        "     * - calling canCall on the target's manager reverts",
                        "     * Otherwise (calling canCall on the target's manager returns a non 0 delay), return the address of the",
                        "     * AccessManager to use, and the delay for this call.",
                        "     */",
                        "    function _detectExecutionRequirements(address target, bytes4 selector) private view returns (uint32 delay) {",
                        "        (, delay) = AuthorityUtils.canCallWithDelay(address(_manager), address(this), target, selector);",
                        "    }",
                        "    /**",
                        "     * @dev Returns whether the operation at an index is delayed by the manager, and its scheduling nonce once queued.",
                        "     */",
                        "    function _getManagerData(ExecutionPlan storage plan, uint256 index) private view returns (bool, uint32) {",
                        "        (uint256 bucket, uint256 subindex) = _getManagerDataIndices(index);",
                        "        uint32 nonce = plan.managerData[bucket][subindex];",
                        "        unchecked {",
                        "            return nonce > 0 ? (true, nonce - 1) : (false, 0);",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Marks an operation at an index as delayed by the manager, and sets its scheduling nonce.",
                        "     */",
                        "    function _setManagerData(ExecutionPlan storage plan, uint256 index, uint32 nonce) private {",
                        "        (uint256 bucket, uint256 subindex) = _getManagerDataIndices(index);",
                        "        plan.managerData[bucket][subindex] = nonce + 1;",
                        "    }",
                        "    /**",
                        "     * @dev Returns bucket and subindex for reading manager data from the packed array mapping.",
                        "     */",
                        "    function _getManagerDataIndices(uint256 index) private pure returns (uint256 bucket, uint256 subindex) {",
                        "    }",
                        "}",
                        "    /**",
                        "     * @dev See {IGovernor-proposalNeedsQueuing}.",
                        "     */",
                        "    function proposalNeedsQueuing(uint256) public view virtual override returns (bool) {",
                        "        return true;",
                        "    }",
                        "    /**",
                        "     * @dev See {IGovernor-proposalNeedsQueuing}.",
                        "     */",
                        "    function proposalNeedsQueuing(uint256) public view virtual override returns (bool) {",
                        "        return true;",
                        "    }",
                        "    function proposalNeedsQueuing(",
                        "        uint256 proposalId",
                        "    ) public view virtual override(Governor, GovernorTimelockControl) returns (bool) {",
                        "        return super.proposalNeedsQueuing(proposalId);",
                        "    }",
                        "    function proposalNeedsQueuing(",
                        "        uint256 proposalId",
                        "    ) public view virtual override(Governor, GovernorTimelockControl) returns (bool) {",
                        "        return super.proposalNeedsQueuing(proposalId);",
                        "    }",
                        "abstract contract GovernorTimelockAccessMock is",
                        "    GovernorSettings,",
                        "    GovernorTimelockAccess,",
                        "    GovernorVotesQuorumFraction,",
                        "    GovernorCountingSimple",
                        "{",
                        "    function nonGovernanceFunction() external {}",
                        "    function quorum(uint256 blockNumber) public view override(Governor, GovernorVotesQuorumFraction) returns (uint256) {",
                        "        return super.quorum(blockNumber);",
                        "    }",
                        "    function proposalThreshold() public view override(Governor, GovernorSettings) returns (uint256) {",
                        "        return super.proposalThreshold();",
                        "    }",
                        "    function proposalNeedsQueuing(",
                        "        uint256 proposalId",
                        "    ) public view virtual override(Governor, GovernorTimelockAccess) returns (bool) {",
                        "        return super.proposalNeedsQueuing(proposalId);",
                        "    }",
                        "    function propose(",
                        "        address[] memory targets,",
                        "        uint256[] memory values,",
                        "        bytes[] memory calldatas,",
                        "        string memory description",
                        "    ) public override(Governor, GovernorTimelockAccess) returns (uint256) {",
                        "        return super.propose(targets, values, calldatas, description);",
                        "    }",
                        "    function _queueOperations(",
                        "        uint256 proposalId,",
                        "        address[] memory targets,",
                        "        uint256[] memory values,",
                        "        bytes[] memory calldatas,",
                        "        bytes32 descriptionHash",
                        "    ) internal override(Governor, GovernorTimelockAccess) returns (uint48) {",
                        "        return super._queueOperations(proposalId, targets, values, calldatas, descriptionHash);",
                        "    }",
                        "    function _executeOperations(",
                        "        uint256 proposalId,",
                        "        address[] memory targets,",
                        "        uint256[] memory values,",
                        "        bytes[] memory calldatas,",
                        "        bytes32 descriptionHash",
                        "    ) internal override(Governor, GovernorTimelockAccess) {",
                        "        super._executeOperations(proposalId, targets, values, calldatas, descriptionHash);",
                        "    }",
                        "    function _cancel(",
                        "        address[] memory targets,",
                        "        uint256[] memory values,",
                        "        bytes[] memory calldatas,",
                        "        bytes32 descriptionHash",
                        "    ) internal override(Governor, GovernorTimelockAccess) returns (uint256) {",
                        "        return super._cancel(targets, values, calldatas, descriptionHash);",
                        "    }",
                        "}",
                        "    function proposalNeedsQueuing(",
                        "        uint256 proposalId",
                        "    ) public view virtual override(Governor, GovernorTimelockCompound) returns (bool) {",
                        "        return super.proposalNeedsQueuing(proposalId);",
                        "    }",
                        "    function proposalNeedsQueuing(",
                        "        uint256 proposalId",
                        "    ) public view virtual override(Governor, GovernorTimelockControl) returns (bool) {",
                        "        return super.proposalNeedsQueuing(proposalId);",
                        "    }"
                    ],
                    "del": [
                        "    mapping(bytes32 operationId => uint48 schedule) private _schedules;",
                        "        uint48 timepoint = _schedules[id];",
                        "    function schedule(address target, bytes calldata data, uint48 when) public virtual returns (bytes32) {",
                        "        if (!allowed && (setback == 0 || when.isSetAndPast(minWhen - 1))) {",
                        "        bytes32 operationId = _hashOperation(caller, target, data);",
                        "        uint48 prevTimepoint = _schedules[operationId];",
                        "        uint48 timepoint = when == 0 ? minWhen : when;",
                        "        _schedules[operationId] = timepoint;",
                        "        emit OperationScheduled(operationId, timepoint, caller, target, data);",
                        "        return operationId;",
                        "    function relay(address target, bytes calldata data) public payable virtual {",
                        "            _consumeScheduledOp(operationId);",
                        "    function _consumeScheduledOp(bytes32 operationId) internal virtual {",
                        "        uint48 timepoint = _schedules[operationId];",
                        "        emit OperationExecuted(operationId, timepoint);",
                        "     * @dev Cancel a scheduled (delayed) operation.",
                        "    function cancel(address caller, address target, bytes calldata data) public virtual {",
                        "        if (_schedules[operationId] == 0) {",
                        "        uint48 timepoint = _schedules[operationId];",
                        "        delete _schedules[operationId];",
                        "        emit OperationCanceled(operationId, timepoint);",
                        "    event OperationScheduled(bytes32 indexed operationId, uint48 schedule, address caller, address target, bytes data);",
                        "    event OperationExecuted(bytes32 indexed operationId, uint48 schedule);",
                        "    event OperationCanceled(bytes32 indexed operationId, uint48 schedule);",
                        "    function schedule(address target, bytes calldata data, uint48 when) external returns (bytes32);",
                        "    function relay(address target, bytes calldata data) external payable;",
                        "    function cancel(address caller, address target, bytes calldata data) external;",
                        "    function name() public view virtual override returns (string memory) {",
                        "    function version() public view virtual override returns (string memory) {",
                        "    ) public pure virtual override returns (uint256) {",
                        "    function state(uint256 proposalId) public view virtual override returns (ProposalState) {",
                        "    function proposalThreshold() public view virtual override returns (uint256) {",
                        "    function proposalSnapshot(uint256 proposalId) public view virtual override returns (uint256) {",
                        "    function proposalDeadline(uint256 proposalId) public view virtual override returns (uint256) {",
                        "    function proposalProposer(uint256 proposalId) public view virtual override returns (address) {",
                        "    function proposalEta(uint256 proposalId) public view virtual override returns (uint256) {",
                        "    ) public virtual override returns (uint256) {",
                        "    ) public virtual override returns (uint256) {",
                        "    ) public payable virtual override returns (uint256) {",
                        "    ) public virtual override returns (uint256) {",
                        "    function getVotes(address account, uint256 timepoint) public view virtual override returns (uint256) {",
                        "    ) public view virtual override returns (uint256) {",
                        "    function castVote(uint256 proposalId, uint8 support) public virtual override returns (uint256) {",
                        "    ) public virtual override returns (uint256) {",
                        "    ) public virtual override returns (uint256) {",
                        "    ) public virtual override returns (uint256) {",
                        "    ) public virtual override returns (uint256) {"
                    ]
                }
            }
        ],
        "- Upgradeable contracts now use namespaced storage (EIP-7201). ([#4534](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4534))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4534": {
                    "add": [
                        "    ) internal virtual returns (uint256 proposalId) {",
                        "        proposalId = hashProposal(targets, values, calldatas, keccak256(bytes(description)));",
                        "    IERC5805 private immutable _token;",
                        "        _token = IERC5805(address(tokenAddress));",
                        "    }",
                        "    /**",
                        "     * @dev The token that voting power is sourced from.",
                        "     */",
                        "    function token() public view virtual returns (IERC5805) {",
                        "        return _token;",
                        "        try token().clock() returns (uint48 timepoint) {",
                        "        try token().CLOCK_MODE() returns (string memory clockmode) {",
                        "        return token().getPastVotes(account, timepoint);",
                        "        return (token().getPastTotalSupply(timepoint) * quorumNumerator(timepoint)) / quorumDenominator();"
                    ],
                    "del": [
                        "    ) internal virtual returns (uint256) {",
                        "        uint256 proposalId = hashProposal(targets, values, calldatas, keccak256(bytes(description)));",
                        "        return proposalId;",
                        "    IERC5805 public immutable token;",
                        "        token = IERC5805(address(tokenAddress));",
                        "        try token.clock() returns (uint48 timepoint) {",
                        "        try token.CLOCK_MODE() returns (string memory clockmode) {",
                        "        return token.getPastVotes(account, timepoint);",
                        "        return (token.getPastTotalSupply(timepoint) * quorumNumerator(timepoint)) / quorumDenominator();"
                    ]
                }
            }
        ],
        "- `Votes`: Use Trace208 for checkpoints. This enables EIP-6372 clock support for keys but reduces the max supported voting power to uint208. ([#4539](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4539))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4539": {
                    "add": [
                        "    using Checkpoints for Checkpoints.Trace208;",
                        "    Checkpoints.Trace208 private _quorumNumeratorHistory;",
                        "        Checkpoints.Checkpoint208 memory latest = _quorumNumeratorHistory._checkpoints[length - 1];",
                        "        uint48 latestKey = latest._key;",
                        "        uint208 latestValue = latest._value;",
                        "        return _quorumNumeratorHistory.upperLookupRecent(SafeCast.toUint48(timepoint));",
                        "        _quorumNumeratorHistory.push(clock(), SafeCast.toUint208(newQuorumNumerator));",
                        "    using Checkpoints for Checkpoints.Trace208;",
                        "    mapping(address delegatee => Checkpoints.Trace208) private _delegateCheckpoints;",
                        "    Checkpoints.Trace208 private _totalCheckpoints;",
                        "        return _delegateCheckpoints[account].upperLookupRecent(SafeCast.toUint48(timepoint));",
                        "        return _totalCheckpoints.upperLookupRecent(SafeCast.toUint48(timepoint));",
                        "            _push(_totalCheckpoints, _add, SafeCast.toUint208(amount));",
                        "            _push(_totalCheckpoints, _subtract, SafeCast.toUint208(amount));",
                        "                    SafeCast.toUint208(amount)",
                        "                    SafeCast.toUint208(amount)",
                        "    ) internal view virtual returns (Checkpoints.Checkpoint208 memory) {",
                        "        Checkpoints.Trace208 storage store,",
                        "        function(uint208, uint208) view returns (uint208) op,",
                        "        uint208 delta",
                        "    ) private returns (uint208, uint208) {",
                        "        return store.push(clock(), op(store.latest(), delta));",
                        "    function _add(uint208 a, uint208 b) private pure returns (uint208) {",
                        "    function _subtract(uint208 a, uint208 b) private pure returns (uint208) {",
                        " * and supports token supply up to 2^208^ - 1, while COMP is limited to 2^96^ - 1.",
                        "     * @dev Maximum token supply. Defaults to `type(uint208).max` (2^208^ - 1).",
                        "     *",
                        "     * This maximum is enforced in {_update}. It limits the total supply of the token, which is otherwise a uint256,",
                        "     * so that checkpoints can be stored in the Trace208 structure used by {{Votes}}. Increasing this value will not",
                        "     * remove the underlying limitation, and will cause {_update} to fail because of a math overflow in",
                        "     * {_transferVotingUnits}. An override could be used to further restrict the total supply (to a lower value) if",
                        "     * additional logic requires it. When resolving override conflicts on this function, the minimum should be",
                        "     * returned.",
                        "    function _maxSupply() internal view virtual returns (uint256) {",
                        "        return type(uint208).max;",
                        "    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoints.Checkpoint208 memory) {",
                        "    struct Trace208 {",
                        "        Checkpoint208[] _checkpoints;",
                        "    }",
                        "    struct Checkpoint208 {",
                        "        uint48 _key;",
                        "        uint208 _value;",
                        "    }",
                        "    /**",
                        "     * @dev Pushes a (`key`, `value`) pair into a Trace208 so that it is stored as the checkpoint.",
                        "     *",
                        "     * Returns previous value and new value.",
                        "     *",
                        "     * IMPORTANT: Never accept `key` as a user input, since an arbitrary `type(uint48).max` key set will disable the library.",
                        "     */",
                        "    function push(Trace208 storage self, uint48 key, uint208 value) internal returns (uint208, uint208) {",
                        "        return _insert(self._checkpoints, key, value);",
                        "    }",
                        "    /**",
                        "     * @dev Returns the value in the first (oldest) checkpoint with key greater or equal than the search key, or zero if there is none.",
                        "     */",
                        "    function lowerLookup(Trace208 storage self, uint48 key) internal view returns (uint208) {",
                        "        uint256 len = self._checkpoints.length;",
                        "        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);",
                        "        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;",
                        "    }",
                        "    /**",
                        "     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.",
                        "     */",
                        "    function upperLookup(Trace208 storage self, uint48 key) internal view returns (uint208) {",
                        "        uint256 len = self._checkpoints.length;",
                        "        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);",
                        "        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
                        "    }",
                        "    /**",
                        "     * @dev Returns the value in the last (most recent) checkpoint with key lower or equal than the search key, or zero if there is none.",
                        "     *",
                        "     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high keys).",
                        "     */",
                        "    function upperLookupRecent(Trace208 storage self, uint48 key) internal view returns (uint208) {",
                        "        uint256 len = self._checkpoints.length;",
                        "        uint256 low = 0;",
                        "        uint256 high = len;",
                        "        if (len > 5) {",
                        "            uint256 mid = len - Math.sqrt(len);",
                        "            if (key < _unsafeAccess(self._checkpoints, mid)._key) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }",
                        "        }",
                        "        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);",
                        "        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
                        "    }",
                        "    /**",
                        "     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.",
                        "     */",
                        "    function latest(Trace208 storage self) internal view returns (uint208) {",
                        "        uint256 pos = self._checkpoints.length;",
                        "        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
                        "    }",
                        "    /**",
                        "     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value",
                        "     * in the most recent checkpoint.",
                        "     */",
                        "    function latestCheckpoint(Trace208 storage self) internal view returns (bool exists, uint48 _key, uint208 _value) {",
                        "        uint256 pos = self._checkpoints.length;",
                        "        if (pos == 0) {",
                        "            return (false, 0, 0);",
                        "        } else {",
                        "            Checkpoint208 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);",
                        "            return (true, ckpt._key, ckpt._value);",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Returns the number of checkpoint.",
                        "     */",
                        "    function length(Trace208 storage self) internal view returns (uint256) {",
                        "        return self._checkpoints.length;",
                        "    }",
                        "    /**",
                        "     * @dev Returns checkpoint at given position.",
                        "     */",
                        "    function at(Trace208 storage self, uint32 pos) internal view returns (Checkpoint208 memory) {",
                        "        return self._checkpoints[pos];",
                        "    }",
                        "    /**",
                        "     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,",
                        "     * or by updating the last one.",
                        "     */",
                        "    function _insert(Checkpoint208[] storage self, uint48 key, uint208 value) private returns (uint208, uint208) {",
                        "        uint256 pos = self.length;",
                        "        if (pos > 0) {",
                        "            Checkpoint208 memory last = _unsafeAccess(self, pos - 1);",
                        "            if (last._key > key) {",
                        "                revert CheckpointUnorderedInsertion();",
                        "            }",
                        "            if (last._key == key) {",
                        "                _unsafeAccess(self, pos - 1)._value = value;",
                        "            } else {",
                        "                self.push(Checkpoint208({_key: key, _value: value}));",
                        "            }",
                        "            return (last._value, value);",
                        "        } else {",
                        "            self.push(Checkpoint208({_key: key, _value: value}));",
                        "            return (0, value);",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Return the index of the last (most recent) checkpoint with key lower or equal than the search key, or `high` if there is none.",
                        "     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.",
                        "     *",
                        "     * WARNING: `high` should not be greater than the array's length.",
                        "     */",
                        "    function _upperBinaryLookup(",
                        "        Checkpoint208[] storage self,",
                        "        uint48 key,",
                        "        uint256 low,",
                        "        uint256 high",
                        "    ) private view returns (uint256) {",
                        "        while (low < high) {",
                        "            uint256 mid = Math.average(low, high);",
                        "            if (_unsafeAccess(self, mid)._key > key) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }",
                        "        }",
                        "        return high;",
                        "    }",
                        "    /**",
                        "     * @dev Return the index of the first (oldest) checkpoint with key is greater or equal than the search key, or `high` if there is none.",
                        "     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.",
                        "     *",
                        "     * WARNING: `high` should not be greater than the array's length.",
                        "     */",
                        "    function _lowerBinaryLookup(",
                        "        Checkpoint208[] storage self,",
                        "        uint48 key,",
                        "        uint256 low,",
                        "        uint256 high",
                        "    ) private view returns (uint256) {",
                        "        while (low < high) {",
                        "            uint256 mid = Math.average(low, high);",
                        "            if (_unsafeAccess(self, mid)._key < key) {",
                        "                low = mid + 1;",
                        "            } else {",
                        "                high = mid;",
                        "            }",
                        "        }",
                        "        return high;",
                        "    }",
                        "    /**",
                        "     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.",
                        "     */",
                        "    function _unsafeAccess(",
                        "        Checkpoint208[] storage self,",
                        "        uint256 pos",
                        "    ) private pure returns (Checkpoint208 storage result) {",
                        "        assembly {",
                        "            mstore(0, self.slot)",
                        "            result.slot := add(keccak256(0, 0x20), pos)",
                        "        }",
                        "    }",
                        "contract CheckpointsTrace208Test is Test {",
                        "    using Checkpoints for Checkpoints.Trace208;",
                        "    uint8 internal constant _KEY_MAX_GAP = 64;",
                        "    Checkpoints.Trace208 internal _ckpts;",
                        "    function _boundUint48(uint48 x, uint48 min, uint48 max) internal view returns (uint48) {",
                        "        return SafeCast.toUint48(bound(uint256(x), uint256(min), uint256(max)));",
                        "    }",
                        "    function _prepareKeys(uint48[] memory keys, uint48 maxSpread) internal view {",
                        "        uint48 lastKey = 0;",
                        "        for (uint256 i = 0; i < keys.length; ++i) {",
                        "            uint48 key = _boundUint48(keys[i], lastKey, lastKey + maxSpread);",
                        "            keys[i] = key;",
                        "            lastKey = key;",
                        "        }",
                        "    }",
                        "    function _assertLatestCheckpoint(bool exist, uint48 key, uint208 value) internal {",
                        "        (bool _exist, uint48 _key, uint208 _value) = _ckpts.latestCheckpoint();",
                        "        assertEq(_exist, exist);",
                        "        assertEq(_key, key);",
                        "        assertEq(_value, value);",
                        "    }",
                        "    function testPush(uint48[] memory keys, uint208[] memory values, uint48 pastKey) public {",
                        "        vm.assume(values.length > 0 && values.length <= keys.length);",
                        "        _prepareKeys(keys, _KEY_MAX_GAP);",
                        "        assertEq(_ckpts.length(), 0);",
                        "        assertEq(_ckpts.latest(), 0);",
                        "        _assertLatestCheckpoint(false, 0, 0);",
                        "        uint256 duplicates = 0;",
                        "        for (uint256 i = 0; i < keys.length; ++i) {",
                        "            uint48 key = keys[i];",
                        "            uint208 value = values[i % values.length];",
                        "            if (i > 0 && key == keys[i - 1]) ++duplicates;",
                        "            _ckpts.push(key, value);",
                        "            assertEq(_ckpts.length(), i + 1 - duplicates);",
                        "            assertEq(_ckpts.latest(), value);",
                        "            _assertLatestCheckpoint(true, key, value);",
                        "        }",
                        "        if (keys.length > 0) {",
                        "            uint48 lastKey = keys[keys.length - 1];",
                        "            if (lastKey > 0) {",
                        "                pastKey = _boundUint48(pastKey, 0, lastKey - 1);",
                        "                vm.expectRevert();",
                        "                this.push(pastKey, values[keys.length % values.length]);",
                        "            }",
                        "        }",
                        "    }",
                        "    function push(uint48 key, uint208 value) external {",
                        "        _ckpts.push(key, value);",
                        "    }",
                        "    function testLookup(uint48[] memory keys, uint208[] memory values, uint48 lookup) public {",
                        "        vm.assume(values.length > 0 && values.length <= keys.length);",
                        "        _prepareKeys(keys, _KEY_MAX_GAP);",
                        "        uint48 lastKey = keys.length == 0 ? 0 : keys[keys.length - 1];",
                        "        lookup = _boundUint48(lookup, 0, lastKey + _KEY_MAX_GAP);",
                        "        uint208 upper = 0;",
                        "        uint208 lower = 0;",
                        "        uint48 lowerKey = type(uint48).max;",
                        "        for (uint256 i = 0; i < keys.length; ++i) {",
                        "            uint48 key = keys[i];",
                        "            uint208 value = values[i % values.length];",
                        "            _ckpts.push(key, value);",
                        "            if (key <= lookup) {",
                        "                upper = value;",
                        "            }",
                        "            if (key >= lookup && (i == 0 || keys[i - 1] < lookup)) {",
                        "                lowerKey = key;",
                        "            }",
                        "            if (key == lowerKey) {",
                        "                lower = value;",
                        "            }",
                        "        }",
                        "        assertEq(_ckpts.lowerLookup(lookup), lower);",
                        "        assertEq(_ckpts.upperLookup(lookup), upper);",
                        "        assertEq(_ckpts.upperLookupRecent(lookup), upper);",
                        "    }",
                        "}"
                    ],
                    "del": [
                        "    using Checkpoints for Checkpoints.Trace224;",
                        "    Checkpoints.Trace224 private _quorumNumeratorHistory;",
                        "        Checkpoints.Checkpoint224 storage latest = _quorumNumeratorHistory._checkpoints[length - 1];",
                        "        uint32 latestKey = latest._key;",
                        "        uint224 latestValue = latest._value;",
                        "        return _quorumNumeratorHistory.upperLookupRecent(SafeCast.toUint32(timepoint));",
                        "        _quorumNumeratorHistory.push(SafeCast.toUint32(clock()), SafeCast.toUint224(newQuorumNumerator));",
                        "    using Checkpoints for Checkpoints.Trace224;",
                        "    mapping(address delegatee => Checkpoints.Trace224) private _delegateCheckpoints;",
                        "    Checkpoints.Trace224 private _totalCheckpoints;",
                        "        return _delegateCheckpoints[account].upperLookupRecent(SafeCast.toUint32(timepoint));",
                        "        return _totalCheckpoints.upperLookupRecent(SafeCast.toUint32(timepoint));",
                        "            _push(_totalCheckpoints, _add, SafeCast.toUint224(amount));",
                        "            _push(_totalCheckpoints, _subtract, SafeCast.toUint224(amount));",
                        "                    SafeCast.toUint224(amount)",
                        "                    SafeCast.toUint224(amount)",
                        "    ) internal view virtual returns (Checkpoints.Checkpoint224 memory) {",
                        "        Checkpoints.Trace224 storage store,",
                        "        function(uint224, uint224) view returns (uint224) op,",
                        "        uint224 delta",
                        "    ) private returns (uint224, uint224) {",
                        "        return store.push(SafeCast.toUint32(clock()), op(store.latest(), delta));",
                        "    function _add(uint224 a, uint224 b) private pure returns (uint224) {",
                        "    function _subtract(uint224 a, uint224 b) private pure returns (uint224) {",
                        " * and supports token supply up to 2^224^ - 1, while COMP is limited to 2^96^ - 1.",
                        "     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).",
                        "    function _maxSupply() internal view virtual returns (uint224) {",
                        "        return type(uint224).max;",
                        "    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoints.Checkpoint224 memory) {"
                    ]
                }
            }
        ],
        "- `SafeERC20`: Refactor `safeDecreaseAllowance` and `safeIncreaseAllowance` to support USDT-like tokens. ([#4260](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4260))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4260": {
                    "add": [
                        "        forceApprove(token, spender, oldAllowance + value);",
                        "            forceApprove(token, spender, oldAllowance - value);"
                    ],
                    "del": [
                        "        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));",
                        "            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));"
                    ]
                }
            }
        ],
        "- `Math`: Make `ceilDiv` to revert on 0 division even if the numerator is 0 ([#4348](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4348))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4348": {
                    "add": [
                        "abstract contract ERC4626LimitsMock is ERC4626 {",
                        "    uint256 _maxDeposit;",
                        "    uint256 _maxMint;",
                        "    constructor() {",
                        "        _maxDeposit = 100 ether;",
                        "        _maxMint = 100 ether;",
                        "    }",
                        "    function maxDeposit(address) public view override returns (uint256) {",
                        "        return _maxDeposit;",
                        "    }",
                        "    function maxMint(address) public view override returns (uint256) {",
                        "        return _maxMint;",
                        "    }",
                        "}",
                        "        if (b == 0) {",
                        "            return a / b;",
                        "        }"
                    ],
                    "del": []
                }
            }
        ],
        "- `Proxy`: Removed redundant `receive` function. ([#4434](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4434))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4434": {
                    "add": [],
                    "del": [
                        "    /**",
                        "     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data",
                        "     * is empty.",
                        "     */",
                        "    receive() external payable virtual {",
                        "        _fallback();",
                        "    }"
                    ]
                }
            }
        ],
        "- `Arrays`: Optimize `findUpperBound` by removing redundant SLOAD. ([#4442](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4442))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4442": {
                    "add": [
                        "        if (high == 0) {",
                        "            return 0;",
                        "        }"
                    ],
                    "del": [
                        "        if (array.length == 0) {",
                        "            return 0;",
                        "        }"
                    ]
                }
            }
        ],
        "- `GovernorTimelockControl`: Clean up timelock id on execution for gas refund. ([#4118](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4118))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4118": {
                    "add": [
                        "        } else if (_timelock.isOperationDone(queueid)) {",
                        "            return ProposalState.Executed;",
                        "        uint256 proposalId,",
                        "        delete _timelockIds[proposalId];",
                        "        bytes32 timelockId = _timelockIds[proposalId];",
                        "        if (timelockId != 0) {",
                        "            _timelock.cancel(timelockId);"
                    ],
                    "del": [
                        "        } else if (_timelock.isOperationDone(queueid)) {",
                        "            return ProposalState.Executed;",
                        "        uint256 /* proposalId */,",
                        "        if (_timelockIds[proposalId] != 0) {",
                        "            _timelock.cancel(_timelockIds[proposalId]);"
                    ]
                }
            }
        ],
        "- `Governor`, `Initializable`, and `UUPSUpgradeable`: Use internal functions in modifiers to optimize bytecode size. ([#4472](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4472))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4472": {
                    "add": [
                        "        _checkGovernance();",
                        "    /**",
                        "     * @dev Reverts if the `msg.sender` is not the executor. In case the executor is not this contract",
                        "     * itself, the function reverts if `msg.data` is not whitelisted as a result of an {execute}",
                        "     * operation. See {onlyGovernance}.",
                        "     */",
                        "    function _checkGovernance() internal virtual {",
                        "        if (_executor() != _msgSender()) {",
                        "            revert GovernorOnlyExecutor(_msgSender());",
                        "        }",
                        "        if (_executor() != address(this)) {",
                        "            bytes32 msgDataHash = keccak256(_msgData());",
                        "            while (_governanceCall.popFront() != msgDataHash) {}",
                        "        }",
                        "    }",
                        "        _checkInitializing();",
                        "        _;",
                        "    }",
                        "    /**",
                        "     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.",
                        "     */",
                        "    function _checkInitializing() internal view virtual {",
                        "        _checkProxy();",
                        "        _checkNotDelegated();",
                        "    /**",
                        "     * @dev Reverts if the execution is not performed via delegatecall or the execution",
                        "     * context is not of a proxy with an ERC1967-compliant implementation pointing to self.",
                        "     * See {_onlyProxy}.",
                        "     */",
                        "    function _checkProxy() internal view virtual {",
                        "        if (",
                        "        ) {",
                        "            revert UUPSUnauthorizedCallContext();",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Reverts if the execution is performed via delegatecall.",
                        "     * See {notDelegated}.",
                        "     */",
                        "    function _checkNotDelegated() internal view virtual {",
                        "        if (address(this) != __self) {",
                        "            revert UUPSUnauthorizedCallContext();",
                        "        }",
                        "    }"
                    ],
                    "del": [
                        "        if (_executor() != _msgSender()) {",
                        "            revert GovernorOnlyExecutor(_msgSender());",
                        "        }",
                        "        if (_executor() != address(this)) {",
                        "            bytes32 msgDataHash = keccak256(_msgData());",
                        "            while (_governanceCall.popFront() != msgDataHash) {}",
                        "        }",
                        "        _;",
                        "        if (",
                        "        ) {",
                        "            revert UUPSUnauthorizedCallContext();",
                        "        }",
                        "        if (address(this) != __self) {",
                        "            revert UUPSUnauthorizedCallContext();",
                        "        }"
                    ]
                }
            }
        ],
        "- `ERC1155`: Bubble errors triggered in the `onERC1155Received` and `onERC1155BatchReceived` hooks. ([#4314](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4314))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4314": {
                    "add": [
                        "        if (_executor() != _msgSender()) {",
                        "     * Receiving tokens is disabled if the governance executor is other than the governor itself (eg. when using with a timelock).",
                        "        if (_executor() != address(this)) {",
                        "            revert GovernorDisabledDeposit();",
                        "        }",
                        "     * Receiving tokens is disabled if the governance executor is other than the governor itself (eg. when using with a timelock).",
                        "        if (_executor() != address(this)) {",
                        "            revert GovernorDisabledDeposit();",
                        "        }",
                        "     * Receiving tokens is disabled if the governance executor is other than the governor itself (eg. when using with a timelock).",
                        "        if (_executor() != address(this)) {",
                        "            revert GovernorDisabledDeposit();",
                        "        }",
                        "    enum RevertType {",
                        "        None,",
                        "        Empty,",
                        "        String,",
                        "        Custom",
                        "    }",
                        "    RevertType private _recReverts;",
                        "    RevertType private _batReverts;",
                        "    error ERC1155ReceiverMockError();",
                        "    constructor(bytes4 recRetval, RevertType recReverts, bytes4 batRetval, RevertType batReverts) {",
                        "        if (_recReverts == RevertType.Empty) {",
                        "            revert();",
                        "        } else if (_recReverts == RevertType.String) {",
                        "            revert(\"ERC1155ReceiverMock: reverting on receive\");",
                        "        } else if (_recReverts == RevertType.Custom) {",
                        "            revert ERC1155ReceiverMockError();",
                        "        }",
                        "        if (_batReverts == RevertType.Empty) {",
                        "            revert();",
                        "        } else if (_batReverts == RevertType.String) {",
                        "            revert(\"ERC1155ReceiverMock: reverting on batch receive\");",
                        "        } else if (_batReverts == RevertType.Custom) {",
                        "            revert ERC1155ReceiverMockError();",
                        "        }",
                        "            } catch (bytes memory reason) {",
                        "                if (reason.length == 0) {",
                        "                    revert ERC1155InvalidReceiver(to);",
                        "                } else {",
                        "                    assembly {",
                        "                        revert(add(32, reason), mload(reason))",
                        "                    }",
                        "                }",
                        "            } catch (bytes memory reason) {",
                        "                if (reason.length == 0) {",
                        "                    revert ERC1155InvalidReceiver(to);",
                        "                } else {",
                        "                    assembly {",
                        "                        revert(add(32, reason), mload(reason))",
                        "                    }",
                        "                }"
                    ],
                    "del": [
                        "        if (_msgSender() != _executor()) {",
                        "    bool private _recReverts;",
                        "    bool private _batReverts;",
                        "    constructor(bytes4 recRetval, bool recReverts, bytes4 batRetval, bool batReverts) {",
                        "        require(!_recReverts, \"ERC1155ReceiverMock: reverting on receive\");",
                        "        require(!_batReverts, \"ERC1155ReceiverMock: reverting on batch receive\");",
                        "            } catch Error(string memory reason) {",
                        "                revert(reason);",
                        "            } catch {",
                        "                revert ERC1155InvalidReceiver(to);",
                        "            } catch Error(string memory reason) {",
                        "                revert(reason);",
                        "            } catch {",
                        "                revert ERC1155InvalidReceiver(to);"
                    ]
                }
            }
        ],
        "- `AccessControl`: Add a boolean return value to the internal `_grantRole` and `_revokeRole` functions indicating whether the role was granted or revoked. ([#4241](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4241))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4241": {
                    "add": [
                        "     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.",
                        "    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {",
                        "            return true;",
                        "        } else {",
                        "            return false;",
                        "     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.",
                        "    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {",
                        "            return true;",
                        "        } else {",
                        "            return false;",
                        "    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {",
                        "        return super._grantRole(role, account);",
                        "    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {",
                        "        return super._revokeRole(role, account);",
                        "     * @dev Overload {AccessControl-_grantRole} to track enumerable memberships",
                        "    function _grantRole(bytes32 role, address account) internal virtual override returns (bool) {",
                        "        bool granted = super._grantRole(role, account);",
                        "        if (granted) {",
                        "            _roleMembers[role].add(account);",
                        "        }",
                        "        return granted;",
                        "     * @dev Overload {AccessControl-_revokeRole} to track enumerable memberships",
                        "    function _revokeRole(bytes32 role, address account) internal virtual override returns (bool) {",
                        "        bool revoked = super._revokeRole(role, account);",
                        "        if (revoked) {",
                        "            _roleMembers[role].remove(account);",
                        "        }",
                        "        return revoked;"
                    ],
                    "del": [
                        "     * @dev Grants `role` to `account`.",
                        "    function _grantRole(bytes32 role, address account) internal virtual {",
                        "     * @dev Revokes `role` from `account`.",
                        "    function _revokeRole(bytes32 role, address account) internal virtual {",
                        "    function _grantRole(bytes32 role, address account) internal virtual override {",
                        "        super._grantRole(role, account);",
                        "    function _revokeRole(bytes32 role, address account) internal virtual override {",
                        "        super._revokeRole(role, account);",
                        "     * @dev Overload {_grantRole} to track enumerable memberships",
                        "    function _grantRole(bytes32 role, address account) internal virtual override {",
                        "        super._grantRole(role, account);",
                        "        _roleMembers[role].add(account);",
                        "     * @dev Overload {_revokeRole} to track enumerable memberships",
                        "    function _revokeRole(bytes32 role, address account) internal virtual override {",
                        "        super._revokeRole(role, account);",
                        "        _roleMembers[role].remove(account);"
                    ]
                }
            }
        ],
        "- `Ownable`: Prevent using address(0) as the initial owner. ([#4531](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4531))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4531": {
                    "add": [
                        "        if (initialOwner == address(0)) {",
                        "            revert OwnableInvalidOwner(address(0));",
                        "        }"
                    ],
                    "del": [
                        "    /**",
                        "     * @dev The `beneficiary` is not a valid account.",
                        "     */",
                        "    error VestingWalletInvalidBeneficiary(address beneficiary);",
                        "        if (beneficiary == address(0)) {",
                        "            revert VestingWalletInvalidBeneficiary(address(0));",
                        "        }"
                    ]
                }
            }
        ],
        "- `ECDSA`: Use unchecked arithmetic for the `tryRecover` function that receives the `r` and `vs` short-signature fields separately. ([#4301](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4301))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4301": {
                    "add": [
                        "        unchecked {",
                        "            bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);",
                        "            uint8 v = uint8((uint256(vs) >> 255) + 27);",
                        "            return tryRecover(hash, v, r, s);",
                        "        }"
                    ],
                    "del": [
                        "        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);",
                        "        uint8 v = uint8((uint256(vs) >> 255) + 27);",
                        "        return tryRecover(hash, v, r, s);"
                    ]
                }
            }
        ],
        "- `VestingWallet`: Fix revert during 1 second time window when duration is 0. ([#4502](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4502))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4502": {
                    "add": [
                        " *",
                        " * NOTE: When using this contract with any token whose balance is adjusted automatically (i.e. a rebase token), make sure",
                        " * to account the supply/balance adjustment in the vesting schedule to ensure the vested amount is as intended.",
                        "        } else if (timestamp >= end()) {",
                        "    /**",
                        "     * @dev Initializes the contract with a trusted forwarder, which will be able to",
                        "     * invoke functions on this contract on behalf of other accounts.",
                        "     *",
                        "     * NOTE: The trusted forwarder can be replaced by overriding {trustedForwarder}.",
                        "     */",
                        "    constructor(address trustedForwarder_) {",
                        "        _trustedForwarder = trustedForwarder_;",
                        "    /**",
                        "     * @dev Returns the address of the trusted forwarder.",
                        "     */",
                        "    function trustedForwarder() public view virtual returns (address) {",
                        "        return _trustedForwarder;",
                        "    }",
                        "    /**",
                        "     * @dev Indicates whether any particular address is the trusted forwarder.",
                        "     */",
                        "        return forwarder == trustedForwarder();",
                        "    /**",
                        "     * @dev Override for `msg.sender`. Defaults to the original `msg.sender` whenever",
                        "     * a call is not performed by the trusted forwarder or the calldata length is less than",
                        "     * 20 bytes (an address length).",
                        "     */",
                        "    /**",
                        "     * @dev Override for `msg.data`. Defaults to the original `msg.data` whenever",
                        "     * a call is not performed by the trusted forwarder or the calldata length is less than",
                        "     * 20 bytes (an address length).",
                        "     */",
                        " * WARNING: Do not approve this contract to spend tokens. Anyone can use this forwarder",
                        " * to execute calls with an arbitrary calldata to any address. Any form of approval may",
                        " * result in a loss of funds for the approving party.",
                        " *",
                        " * NOTE: Batching requests includes an optional refund for unused `msg.value` that is achieved by",
                        " * performing a call with empty calldata. While this is within the bounds of ERC-2771 compliance,",
                        " * if the refund receiver happens to consider the forwarder a trusted forwarder, it MUST properly",
                        " * handle `msg.data.length == 0`. `ERC2771Context` in OpenZeppelin Contracts versions prior to 4.9.3",
                        " * do not handle this properly.",
                        " *",
                        "    /**",
                        "     * @dev The request target doesn't trust the `forwarder`.",
                        "     */",
                        "    error ERC2771UntrustfulTarget(address target, address forwarder);",
                        "     * A transaction is considered valid when the target trusts this forwarder, the request hasn't expired",
                        "     * (deadline is not met), and the signer matches the `from` parameter of the signed request.",
                        "        (bool isTrustedForwarder, bool active, bool signerMatch, ) = _validate(request);",
                        "        return isTrustedForwarder && active && signerMatch;",
                        "    ) internal view virtual returns (bool isTrustedForwarder, bool active, bool signerMatch, address signer) {",
                        "        (bool isValid, address recovered) = _recoverForwardRequestSigner(request);",
                        "        return (",
                        "            _isTrustedByTarget(request.to),",
                        "            request.deadline >= block.timestamp,",
                        "            isValid && recovered == request.from,",
                        "            recovered",
                        "        );",
                        "     * @dev Returns a tuple with the recovered the signer of an EIP712 forward request message hash",
                        "     * and a boolean indicating if the signature is valid.",
                        "     *",
                        "     * NOTE: The signature is considered valid if {ECDSA-tryRecover} indicates no recover error for it.",
                        "    function _recoverForwardRequestSigner(",
                        "        ForwardRequestData calldata request",
                        "    ) internal view virtual returns (bool, address) {",
                        "        (address recovered, ECDSA.RecoverError err, ) = _hashTypedDataV4(",
                        "            keccak256(",
                        "                abi.encode(",
                        "                    _FORWARD_REQUEST_TYPEHASH,",
                        "                    request.from,",
                        "                    request.to,",
                        "                    request.value,",
                        "                    request.gas,",
                        "                    nonces(request.from),",
                        "                    request.deadline,",
                        "                    keccak256(request.data)",
                        "            )",
                        "        ).tryRecover(request.signature);",
                        "        return (err == ECDSA.RecoverError.NoError, recovered);",
                        "        (bool isTrustedForwarder, bool active, bool signerMatch, address signer) = _validate(request);",
                        "            if (!isTrustedForwarder) {",
                        "                revert ERC2771UntrustfulTarget(request.to, address(this));",
                        "            }",
                        "            if (!active) {",
                        "        if (isTrustedForwarder && signerMatch && active) {",
                        "    /**",
                        "     * @dev Returns whether the target trusts this forwarder.",
                        "     *",
                        "     * This function performs a static call to the target contract calling the",
                        "     * {ERC2771Context-isTrustedForwarder} function.",
                        "     */",
                        "    function _isTrustedByTarget(address target) private view returns (bool) {",
                        "        bytes memory encodedParams = abi.encodeCall(ERC2771Context.isTrustedForwarder, (address(this)));",
                        "        bool success;",
                        "        uint256 returnSize;",
                        "        uint256 returnValue;",
                        "        assembly {",
                        "            success := staticcall(gas(), target, add(encodedParams, 0x20), mload(encodedParams), 0, 0x20)",
                        "            returnSize := returndatasize()",
                        "            returnValue := mload(0)",
                        "        }",
                        "        return success && returnSize >= 0x20 && returnValue > 0;",
                        "    }",
                        "contract CallReceiverMockTrustingForwarder is CallReceiverMock {",
                        "    address private _trustedForwarder;",
                        "    constructor(address trustedForwarder_) {",
                        "        _trustedForwarder = trustedForwarder_;",
                        "    }",
                        "    function isTrustedForwarder(address forwarder) public view virtual returns (bool) {",
                        "        return forwarder == _trustedForwarder;",
                        "    }",
                        "}",
                        "contract UpgradeableBeaconMock is IBeacon {",
                        "    address public implementation;",
                        "    constructor(address impl) {",
                        "        implementation = impl;",
                        "    }",
                        "}",
                        "interface IProxyExposed {",
                        "    function $getBeacon() external view returns (address);",
                        "}",
                        "contract UpgradeableBeaconReentrantMock is IBeacon {",
                        "    error BeaconProxyBeaconSlotAddress(address beacon);",
                        "    function implementation() external view override returns (address) {",
                        "        revert BeaconProxyBeaconSlotAddress(IProxyExposed(msg.sender).$getBeacon());",
                        "    }",
                        "}",
                        "     * @dev Initializes the upgradeable proxy with an initial implementation specified by `implementation`.",
                        "     * If `_data` is nonempty, it's used as data in a delegate call to `implementation`. This will typically be an encoded",
                        "    constructor(address implementation, bytes memory _data) payable {",
                        "        ERC1967Utils.upgradeToAndCall(implementation, _data);",
                        "    function _implementation() internal view virtual override returns (address) {",
                        "     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1.",
                        "     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.",
                        "     * This is the keccak-256 hash of \"eip1967.proxy.beacon\" subtracted by 1.",
                        "        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;",
                        "     * @dev Reverts if `msg.value` is not zero. It can be used to avoid `msg.value` stuck in the contract",
                        "     * if an upgrade doesn't perform an initialization call.",
                        "     * {UpgradeableBeacon} will check that this address is a contract.",
                        "        emit Upgraded(newImplementation);",
                        "     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function",
                        " * NOTE: This proxy does not inherit from {Context} deliberately. The {ProxyAdmin} of this contract won't send a",
                        " * meta-transaction in any way, and any other meta-transaction setup should be made in the implementation contract.",
                        " *",
                        "        ERC1967Utils.changeAdmin(_proxyAdmin());",
                        "    }",
                        "    /**",
                        "     * @dev Returns the admin of this proxy.",
                        "     */",
                        "    function _proxyAdmin() internal virtual returns (address) {",
                        "        return _admin;",
                        "        if (msg.sender == _proxyAdmin()) {",
                        "            if (msg.sig != ITransparentUpgradeableProxy.upgradeToAndCall.selector) {",
                        "            } else {",
                        "                _dispatchUpgradeToAndCall();",
                        "     * be the empty byte string if no function should be called, making it impossible to invoke the `receive` function",
                        "     * @dev Performs an implementation upgrade with a security check for UUPS proxies, and additional setup call.",
                        "     *",
                        "     * As a security check, {proxiableUUID} is invoked in the new implementation, and the return value",
                        "     * is expected to be the implementation slot in ERC1967.",
                        "     * If `target` reverts with a revert reason or custom error, it is bubbled",
                        "     * up by this function (like regular Solidity function calls). However, if",
                        "     * the call reverted with no returned reason, this function reverts with a",
                        "     * {FailedInnerCall} error.",
                        "        return functionCallWithValue(target, data, 0);",
                        "        return verifyCallResultFromTarget(target, success, returndata);",
                        "        return verifyCallResultFromTarget(target, success, returndata);",
                        "        return verifyCallResultFromTarget(target, success, returndata);",
                        "     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target",
                        "     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an",
                        "     * unsuccessful call.",
                        "        bytes memory returndata",
                        "        if (!success) {",
                        "            _revert(returndata);",
                        "        } else {",
                        "            if (returndata.length == 0 && target.code.length == 0) {",
                        "                revert AddressEmptyCode(target);",
                        "     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the",
                        "     * revert reason or with a default {FailedInnerCall} error.",
                        "    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {",
                        "        if (!success) {",
                        "            _revert(returndata);",
                        "            return returndata;",
                        "     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.",
                        "    function _revert(bytes memory returndata) private pure {",
                        "    bytes16 private constant _HEX_DIGITS = \"0123456789abcdef\";",
                        "                    mstore8(ptr, byte(mod(value, 10), _HEX_DIGITS))",
                        "            buffer[i] = _HEX_DIGITS[localValue & 0xf];",
                        "    CallReceiverMockTrustingForwarder internal _receiver;",
                        "        _receiver = new CallReceiverMockTrustingForwarder(address(_erc2771Forwarder));"
                    ],
                    "del": [
                        "        } else if (timestamp > end()) {",
                        "    constructor(address trustedForwarder) {",
                        "        _trustedForwarder = trustedForwarder;",
                        "        return forwarder == _trustedForwarder;",
                        "     * A transaction is considered valid when it hasn't expired (deadline is not met), and the signer",
                        "     * matches the `from` parameter of the signed request.",
                        "        (bool alive, bool signerMatch, ) = _validate(request);",
                        "        return alive && signerMatch;",
                        "    ) internal view virtual returns (bool alive, bool signerMatch, address signer) {",
                        "        signer = _recoverForwardRequestSigner(request);",
                        "        return (request.deadline >= block.timestamp, signer == request.from, signer);",
                        "     * @dev Recovers the signer of an EIP712 message hash for a forward `request` and its corresponding `signature`.",
                        "     * See {ECDSA-recover}.",
                        "    function _recoverForwardRequestSigner(ForwardRequestData calldata request) internal view virtual returns (address) {",
                        "        return",
                        "            _hashTypedDataV4(",
                        "                keccak256(",
                        "                    abi.encode(",
                        "                        _FORWARD_REQUEST_TYPEHASH,",
                        "                        request.from,",
                        "                        request.to,",
                        "                        request.value,",
                        "                        request.gas,",
                        "                        nonces(request.from),",
                        "                        request.deadline,",
                        "                        keccak256(request.data)",
                        "                    )",
                        "            ).recover(request.signature);",
                        "        (bool alive, bool signerMatch, address signer) = _validate(request);",
                        "            if (!alive) {",
                        "        if (signerMatch && alive) {",
                        "/**",
                        " * @dev A mock to expose `Address`'s functions with function pointers.",
                        " */",
                        "contract AddressFnPointerMock {",
                        "    error CustomRevert();",
                        "    function functionCall(address target, bytes memory data) external returns (bytes memory) {",
                        "        return Address.functionCall(target, data, _customRevert);",
                        "    }",
                        "    function functionCallWithValue(address target, bytes memory data, uint256 value) external returns (bytes memory) {",
                        "        return Address.functionCallWithValue(target, data, value, _customRevert);",
                        "    }",
                        "    function functionStaticCall(address target, bytes memory data) external view returns (bytes memory) {",
                        "        return Address.functionStaticCall(target, data, _customRevert);",
                        "    }",
                        "    function functionDelegateCall(address target, bytes memory data) external returns (bytes memory) {",
                        "        return Address.functionDelegateCall(target, data, _customRevert);",
                        "    }",
                        "    function verifyCallResultFromTarget(",
                        "        address target,",
                        "        bool success,",
                        "        bytes memory returndata",
                        "    ) external view returns (bytes memory) {",
                        "        return Address.verifyCallResultFromTarget(target, success, returndata, _customRevert);",
                        "    }",
                        "    function verifyCallResult(bool success, bytes memory returndata) external view returns (bytes memory) {",
                        "        return Address.verifyCallResult(success, returndata, _customRevert);",
                        "    }",
                        "    function verifyCallResultVoid(bool success, bytes memory returndata) external view returns (bytes memory) {",
                        "        return Address.verifyCallResult(success, returndata, _customRevertVoid);",
                        "    }",
                        "    function _customRevert() internal pure {",
                        "        revert CustomRevert();",
                        "    }",
                        "    function _customRevertVoid() internal pure {}",
                        "}",
                        "contract UpgradeableBeaconMock is IBeacon {",
                        "    address public implementation;",
                        "    constructor(address impl) {",
                        "        implementation = impl;",
                        "    }",
                        "}",
                        "     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.",
                        "     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded",
                        "    constructor(address _logic, bytes memory _data) payable {",
                        "        ERC1967Utils.upgradeToAndCall(_logic, _data);",
                        "    function _implementation() internal view virtual override returns (address impl) {",
                        "     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is",
                        "     * validated in the constructor.",
                        "     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is",
                        "     * validated in the constructor.",
                        "     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1) and is validated in the constructor.",
                        "        StorageSlot.getAddressSlot(BEACON_SLOT).value = newBeacon;",
                        "     * @dev Reverts if `msg.value` is not zero.",
                        "        _beforeFallback();",
                        "    /**",
                        "     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`",
                        "     * call, or as part of the Solidity `fallback` or `receive` functions.",
                        "     *",
                        "     * If overridden should call `super._beforeFallback()`.",
                        "     */",
                        "    function _beforeFallback() internal virtual {}",
                        "     * {BeaconProxy} will check that this address is a contract.",
                        "        emit Upgraded(newImplementation);",
                        "     * be the empty byte string if no function should be called, being impossible to invoke the `receive` function",
                        "        ERC1967Utils.changeAdmin(_admin);",
                        "        if (msg.sender == _admin) {",
                        "            if (msg.sig == ITransparentUpgradeableProxy.upgradeToAndCall.selector) {",
                        "                _dispatchUpgradeToAndCall();",
                        "            } else {",
                        "     * be the empty byte string if no function should be called, being impossible to invoke the `receive` function",
                        "     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.",
                        "     * If `target` reverts with a revert reason, it is bubbled up by this",
                        "     * function (like regular Solidity function calls).",
                        "        return functionCallWithValue(target, data, 0, defaultRevert);",
                        "    }",
                        "    /**",
                        "     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with a",
                        "     * `customRevert` function as a fallback when `target` reverts.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `customRevert` must be a reverting function.",
                        "     */",
                        "    function functionCall(",
                        "        address target,",
                        "        bytes memory data,",
                        "        function() internal view customRevert",
                        "    ) internal returns (bytes memory) {",
                        "        return functionCallWithValue(target, data, 0, customRevert);",
                        "        return functionCallWithValue(target, data, value, defaultRevert);",
                        "    }",
                        "    /**",
                        "     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but",
                        "     * with a `customRevert` function as a fallback revert reason when `target` reverts.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `customRevert` must be a reverting function.",
                        "     */",
                        "    function functionCallWithValue(",
                        "        address target,",
                        "        bytes memory data,",
                        "        uint256 value,",
                        "        function() internal view customRevert",
                        "    ) internal returns (bytes memory) {",
                        "        return verifyCallResultFromTarget(target, success, returndata, customRevert);",
                        "        return functionStaticCall(target, data, defaultRevert);",
                        "    }",
                        "    /**",
                        "     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],",
                        "     * but performing a static call.",
                        "     */",
                        "    function functionStaticCall(",
                        "        address target,",
                        "        bytes memory data,",
                        "        function() internal view customRevert",
                        "    ) internal view returns (bytes memory) {",
                        "        return verifyCallResultFromTarget(target, success, returndata, customRevert);",
                        "        return functionDelegateCall(target, data, defaultRevert);",
                        "    }",
                        "    /**",
                        "     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],",
                        "     * but performing a delegate call.",
                        "     */",
                        "    function functionDelegateCall(",
                        "        address target,",
                        "        bytes memory data,",
                        "        function() internal view customRevert",
                        "    ) internal returns (bytes memory) {",
                        "        return verifyCallResultFromTarget(target, success, returndata, customRevert);",
                        "     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling",
                        "     * the revert reason or using the provided `customRevert`) in case of unsuccessful call or if target was not a contract.",
                        "        bytes memory returndata,",
                        "        function() internal view customRevert",
                        "        if (success) {",
                        "            if (returndata.length == 0) {",
                        "                if (target.code.length == 0) {",
                        "                    revert AddressEmptyCode(target);",
                        "                }",
                        "        } else {",
                        "            _revert(returndata, customRevert);",
                        "     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the",
                        "     * revert reason or with a default revert error.",
                        "    function verifyCallResult(bool success, bytes memory returndata) internal view returns (bytes memory) {",
                        "        return verifyCallResult(success, returndata, defaultRevert);",
                        "    }",
                        "    /**",
                        "     * @dev Same as {xref-Address-verifyCallResult-bool-bytes-}[`verifyCallResult`], but with a",
                        "     * `customRevert` function as a fallback when `success` is `false`.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `customRevert` must be a reverting function.",
                        "     */",
                        "    function verifyCallResult(",
                        "        bool success,",
                        "        bytes memory returndata,",
                        "        function() internal view customRevert",
                        "    ) internal view returns (bytes memory) {",
                        "        if (success) {",
                        "            return returndata;",
                        "            _revert(returndata, customRevert);",
                        "     * @dev Default reverting function when no `customRevert` is provided in a function call.",
                        "    function defaultRevert() internal pure {",
                        "        revert FailedInnerCall();",
                        "    }",
                        "    function _revert(bytes memory returndata, function() internal view customRevert) private view {",
                        "            customRevert();",
                        "    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";",
                        "                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))",
                        "            buffer[i] = _SYMBOLS[localValue & 0xf];",
                        "    CallReceiverMock internal _receiver;",
                        "        _receiver = new CallReceiverMock();"
                    ]
                }
            }
        ],
        "- `MerkleProof`: Use custom error to report invalid multiproof instead of reverting with overflow panic. ([#4564](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4564))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4564": {
                    "add": [
                        "        if (leavesLen + proofLen != totalHashes + 1) {",
                        "        if (leavesLen + proofLen != totalHashes + 1) {"
                    ],
                    "del": [
                        "        if (leavesLen + proofLen - 1 != totalHashes) {",
                        "        if (leavesLen + proofLen - 1 != totalHashes) {"
                    ]
                }
            }
        ],
        "- `Governor`: Add validation in ERC1155 and ERC721 receiver hooks to ensure Governor is the executor. ([#4314](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4314))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4314": {
                    "add": [
                        "        if (_executor() != _msgSender()) {",
                        "     * Receiving tokens is disabled if the governance executor is other than the governor itself (eg. when using with a timelock).",
                        "        if (_executor() != address(this)) {",
                        "            revert GovernorDisabledDeposit();",
                        "        }",
                        "     * Receiving tokens is disabled if the governance executor is other than the governor itself (eg. when using with a timelock).",
                        "        if (_executor() != address(this)) {",
                        "            revert GovernorDisabledDeposit();",
                        "        }",
                        "     * Receiving tokens is disabled if the governance executor is other than the governor itself (eg. when using with a timelock).",
                        "        if (_executor() != address(this)) {",
                        "            revert GovernorDisabledDeposit();",
                        "        }",
                        "    enum RevertType {",
                        "        None,",
                        "        Empty,",
                        "        String,",
                        "        Custom",
                        "    }",
                        "    RevertType private _recReverts;",
                        "    RevertType private _batReverts;",
                        "    error ERC1155ReceiverMockError();",
                        "    constructor(bytes4 recRetval, RevertType recReverts, bytes4 batRetval, RevertType batReverts) {",
                        "        if (_recReverts == RevertType.Empty) {",
                        "            revert();",
                        "        } else if (_recReverts == RevertType.String) {",
                        "            revert(\"ERC1155ReceiverMock: reverting on receive\");",
                        "        } else if (_recReverts == RevertType.Custom) {",
                        "            revert ERC1155ReceiverMockError();",
                        "        }",
                        "        if (_batReverts == RevertType.Empty) {",
                        "            revert();",
                        "        } else if (_batReverts == RevertType.String) {",
                        "            revert(\"ERC1155ReceiverMock: reverting on batch receive\");",
                        "        } else if (_batReverts == RevertType.Custom) {",
                        "            revert ERC1155ReceiverMockError();",
                        "        }",
                        "            } catch (bytes memory reason) {",
                        "                if (reason.length == 0) {",
                        "                    revert ERC1155InvalidReceiver(to);",
                        "                } else {",
                        "                    assembly {",
                        "                        revert(add(32, reason), mload(reason))",
                        "                    }",
                        "                }",
                        "            } catch (bytes memory reason) {",
                        "                if (reason.length == 0) {",
                        "                    revert ERC1155InvalidReceiver(to);",
                        "                } else {",
                        "                    assembly {",
                        "                        revert(add(32, reason), mload(reason))",
                        "                    }",
                        "                }"
                    ],
                    "del": [
                        "        if (_msgSender() != _executor()) {",
                        "    bool private _recReverts;",
                        "    bool private _batReverts;",
                        "    constructor(bytes4 recRetval, bool recReverts, bytes4 batRetval, bool batReverts) {",
                        "        require(!_recReverts, \"ERC1155ReceiverMock: reverting on receive\");",
                        "        require(!_batReverts, \"ERC1155ReceiverMock: reverting on batch receive\");",
                        "            } catch Error(string memory reason) {",
                        "                revert(reason);",
                        "            } catch {",
                        "                revert ERC1155InvalidReceiver(to);",
                        "            } catch Error(string memory reason) {",
                        "                revert(reason);",
                        "            } catch {",
                        "                revert ERC1155InvalidReceiver(to);"
                    ]
                }
            }
        ],
        "- `Math`: Optimized stack operations in `mulDiv`. ([#4494](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4494))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4494": {
                    "add": [
                        "            uint256 twos = denominator & (0 - denominator);"
                    ],
                    "del": [
                        "                prod0 := mul(x, y)",
                        "            uint256 twos = denominator & (~denominator + 1);"
                    ]
                }
            }
        ],
        "- `BeaconProxy`: Use an immutable variable to store the address of the beacon. It is no longer possible for a `BeaconProxy` to upgrade by changing to another beacon. ([#4435](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4435))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4435": {
                    "add": [
                        "     * @dev Change the beacon and trigger a setup call.",
                        "     *",
                        "     * CAUTION: Invoking this function has no effect on an instance of {BeaconProxy} since v5, since",
                        "     * it uses an immutable beacon without looking at the value of the ERC-1967 beacon slot for",
                        "     * efficiency.",
                        " *",
                        " * CAUTION: The beacon address can only be set once during construction, and cannot be changed afterwards.",
                        " * You must ensure that you either control the beacon, or trust the beacon to not upgrade the implementation maliciously.",
                        "    address private immutable _beacon;",
                        "        _beacon = beacon;",
                        "        return IBeacon(_getBeacon()).implementation();",
                        "    }",
                        "    /**",
                        "     * @dev Returns the beacon.",
                        "     */",
                        "    function _getBeacon() internal view virtual returns (address) {",
                        "        return _beacon;"
                    ],
                    "del": [
                        "     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does",
                        "     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).",
                        "        return IBeacon(ERC1967Utils.getBeacon()).implementation();"
                    ]
                }
            }
        ],
        "- `ERC1155`: Optimize array allocation. ([#4196](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4196))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4196": {
                    "add": [
                        "        (uint256[] memory ids, uint256[] memory amounts) = _asSingletonArrays(id, amount);",
                        "        (uint256[] memory ids, uint256[] memory amounts) = _asSingletonArrays(id, amount);",
                        "        (uint256[] memory ids, uint256[] memory amounts) = _asSingletonArrays(id, amount);",
                        "    function _asSingletonArrays(",
                        "        uint256 element1,",
                        "        uint256 element2",
                        "    ) private pure returns (uint256[] memory array1, uint256[] memory array2) {",
                        "        assembly {",
                        "            array1 := mload(0x40)",
                        "            mstore(array1, 1)",
                        "            mstore(add(array1, 0x20), element1)",
                        "            array2 := add(array1, 0x40)",
                        "            mstore(array2, 1)",
                        "            mstore(add(array2, 0x20), element2)",
                        "            mstore(0x40, add(array2, 0x40))",
                        "        }"
                    ],
                    "del": [
                        "        uint256[] memory ids = _asSingletonArray(id);",
                        "        uint256[] memory amounts = _asSingletonArray(amount);",
                        "        uint256[] memory ids = _asSingletonArray(id);",
                        "        uint256[] memory amounts = _asSingletonArray(amount);",
                        "        uint256[] memory ids = _asSingletonArray(id);",
                        "        uint256[] memory amounts = _asSingletonArray(amount);",
                        "    function _asSingletonArray(uint256 element) private pure returns (uint256[] memory) {",
                        "        uint256[] memory array = new uint256[](1);",
                        "        array[0] = element;",
                        "        return array;"
                    ]
                }
            }
        ],
        "- `Governor`: Add a mechanism to restrict the address of the proposer using a suffix in the description.\r": [],
        "- `ERC1155`: Optimize array accesses by skipping bounds checking when unnecessary. ([#4300](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4300))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4300": {
                    "add": [
                        "    using Arrays for uint256[];",
                        "    using Arrays for address[];",
                        "            batchBalances[i] = balanceOf(accounts.unsafeMemoryAccess(i), ids.unsafeMemoryAccess(i));",
                        "            uint256 id = ids.unsafeMemoryAccess(i);",
                        "            uint256 amount = amounts.unsafeMemoryAccess(i);",
                        "            uint256 id = ids.unsafeMemoryAccess(0);",
                        "            uint256 amount = amounts.unsafeMemoryAccess(0);",
                        "    /**",
                        "     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.",
                        "     *",
                        "     * WARNING: Only use if you are certain `pos` is lower than the array length.",
                        "     */",
                        "    function unsafeMemoryAccess(uint256[] memory arr, uint256 pos) internal pure returns (uint256 res) {",
                        "        assembly {",
                        "            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.",
                        "     *",
                        "     * WARNING: Only use if you are certain `pos` is lower than the array length.",
                        "     */",
                        "    function unsafeMemoryAccess(address[] memory arr, uint256 pos) internal pure returns (address res) {",
                        "        assembly {",
                        "            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))",
                        "        }",
                        "    }"
                    ],
                    "del": [
                        "            batchBalances[i] = balanceOf(accounts[i], ids[i]);",
                        "            uint256 id = ids[i];",
                        "            uint256 amount = amounts[i];",
                        "            uint256 id = ids[0];",
                        "            uint256 amount = amounts[0];"
                    ]
                }
            }
        ],
        "- `ERC2771Context`: Return the forwarder address whenever the `msg.data` of a call originating from a trusted forwarder is not long enough to contain the request signer address (i.e. `msg.data.length` is less than 20 bytes), as specified by ERC-2771. ([#4481](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4481))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4481": {
                    "add": [
                        "        if (isTrustedForwarder(msg.sender) && msg.data.length >= 20) {"
                    ],
                    "del": [
                        "        if (isTrustedForwarder(msg.sender)) {"
                    ]
                }
            }
        ],
        "- `ERC2771Context`: Prevent revert in `_msgData()` when a call originating from a trusted forwarder is not long enough to contain the request signer address (i.e. `msg.data.length` is less than 20 bytes). Return the full calldata in that case. ([#4484](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4484))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4484": {
                    "add": [
                        "        if (isTrustedForwarder(msg.sender) && msg.data.length >= 20) {",
                        "    event DataShort(bytes data);",
                        "    function msgDataShort() public {",
                        "        emit DataShort(_msgData());",
                        "    }"
                    ],
                    "del": [
                        "        if (isTrustedForwarder(msg.sender)) {"
                    ]
                }
            }
        ]
    },
    "4.9.3": {
        "> This release contains a fix for [GHSA-g4vp-m682-qqmp](https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-g4vp-m682-qqmp).\r": [
            "https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-g4vp-m682-qqmp"
        ],
        "- `ERC2771Context`: Return the forwarder address whenever the `msg.data` of a call originating from a trusted forwarder is not long enough to contain the request signer address (i.e. `msg.data.length` is less than 20 bytes), as specified by ERC-2771. ([#4481](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4481))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4481": {
                    "add": [
                        "        if (isTrustedForwarder(msg.sender) && msg.data.length >= 20) {"
                    ],
                    "del": [
                        "        if (isTrustedForwarder(msg.sender)) {"
                    ]
                }
            }
        ],
        "- `ERC2771Context`: Prevent revert in `_msgData()` when a call originating from a trusted forwarder is not long enough to contain the request signer address (i.e. `msg.data.length` is less than 20 bytes). Return the full calldata in that case. ([#4484](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4484))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4484": {
                    "add": [
                        "        if (isTrustedForwarder(msg.sender) && msg.data.length >= 20) {",
                        "    event DataShort(bytes data);",
                        "    function msgDataShort() public {",
                        "        emit DataShort(_msgData());",
                        "    }"
                    ],
                    "del": [
                        "        if (isTrustedForwarder(msg.sender)) {"
                    ]
                }
            }
        ]
    },
    "4.9.2": {
        "> This release contains a fix for [GHSA-wprv-93r4-jj2p](https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-wprv-93r4-jj2p).\r": [
            "https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-wprv-93r4-jj2p"
        ],
        "- `MerkleProof`: Fix a bug in `processMultiProof` and `processMultiProofCalldata` that allows proving arbitrary leaves if the tree contains a node with value 0 at depth 1.\r": []
    },
    "4.9.1": {
        "> This release contains a fix for [GHSA-5h3x-9wvq-w4m2](https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-5h3x-9wvq-w4m2).\r": [
            "https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-5h3x-9wvq-w4m2"
        ],
        "- `Governor`: Add a mechanism to restrict the address of the proposer using a suffix in the description.": []
    },
    "4.9.0": {
        "- `ERC721Wrapper`: add a new extension of the `ERC721` token which wraps an underlying token. Deposit and withdraw guarantee that the ownership of each token is backed by a corresponding underlying token with the same identifier. ([#3863](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3863))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3863": {
                    "add": [
                        "/**",
                        " * @dev Extension of the ERC721 token contract to support token wrapping.",
                        " *",
                        " * Users can deposit and withdraw an \"underlying token\" and receive a \"wrapped token\" with a matching tokenId. This is useful",
                        " * in conjunction with other modules. For example, combining this wrapping mechanism with {ERC721Votes} will allow the",
                        " * wrapping of an existing \"basic\" ERC721 into a governance token.",
                        " *",
                        " * _Available since v4.9.0_",
                        " */",
                        "abstract contract ERC721Wrapper is ERC721, ERC721Holder {",
                        "    IERC721 private immutable _underlying;",
                        "    bytes12 public constant WRAPPER_ACCEPT_MAGIC = bytes12(keccak256(\"WRAPPER_ACCEPT_MAGIC\"));",
                        "    constructor(IERC721 underlyingToken) {",
                        "        _underlying = underlyingToken;",
                        "    }",
                        "    /**",
                        "     * @dev Allow a user to deposit underlying tokens and mint the corresponding tokenIds.",
                        "     */",
                        "    function depositFor(address account, uint256[] memory tokenIds) public virtual returns (bool) {",
                        "        bytes memory data = abi.encodePacked(WRAPPER_ACCEPT_MAGIC, account);",
                        "        uint256 length = tokenIds.length;",
                        "        for (uint256 i = 0; i < length; ++i) {",
                        "            underlying().safeTransferFrom(_msgSender(), address(this), tokenIds[i], data);",
                        "        }",
                        "        return true;",
                        "    }",
                        "    /**",
                        "     * @dev Allow a user to burn wrapped tokens and withdraw the corresponding tokenIds of the underlying tokens.",
                        "     */",
                        "    function withdrawTo(address account, uint256[] memory tokenIds) public virtual returns (bool) {",
                        "        uint256 length = tokenIds.length;",
                        "        for (uint256 i = 0; i < length; ++i) {",
                        "            uint256 tokenId = tokenIds[i];",
                        "            require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721Wrapper: caller is not token owner or approved\");",
                        "            _burn(tokenId);",
                        "            underlying().safeTransferFrom(address(this), account, tokenId);",
                        "        }",
                        "        return true;",
                        "    }",
                        "    /**",
                        "     * @dev Overrides {IERC721Receiver-onERC721Received} to allow minting on direct ERC721 transfers to",
                        "     * this contract.",
                        "     *",
                        "     * In case there's data attached, it validates that the sender is aware of this contract's existence and behavior",
                        "     * by checking a magic value (`WRAPPER_ACCEPT_MAGIC`) in the first 12 bytes. If it also matches, the rest 20",
                        "     * bytes are used as an address to send the tokens to.",
                        "     *",
                        "     * WARNING: Doesn't work with unsafe transfers (eg. {IERC721-transferFrom}). Use {ERC721Wrapper-_recover}",
                        "     * for recovering in that scenario.",
                        "     */",
                        "    function onERC721Received(",
                        "        address,",
                        "        address from,",
                        "        uint256 tokenId,",
                        "        bytes memory data",
                        "    ) public override returns (bytes4) {",
                        "        require(address(underlying()) == _msgSender(), \"ERC721Wrapper: caller is not underlying\");",
                        "        if (data.length > 0) {",
                        "            require(data.length == 32 && WRAPPER_ACCEPT_MAGIC == bytes12(data), \"ERC721Wrapper: Invalid data format\");",
                        "            from = address(bytes20(bytes32(data) << 96));",
                        "        }",
                        "        _safeMint(from, tokenId);",
                        "        return IERC721Receiver.onERC721Received.selector;",
                        "    }",
                        "    /**",
                        "     * @dev Mint a wrapped token to cover any underlyingToken that would have been transferred by mistake. Internal",
                        "     * function that can be exposed with access control if desired.",
                        "     */",
                        "    function _recover(address account, uint256 tokenId) internal virtual returns (uint256) {",
                        "        require(underlying().ownerOf(tokenId) == address(this), \"ERC721Wrapper: wrapper is not token owner\");",
                        "        _safeMint(account, tokenId);",
                        "        return tokenId;",
                        "    }",
                        "    /**",
                        "     * @dev Returns the underlying token.",
                        "     */",
                        "    function underlying() public view virtual returns (IERC721) {",
                        "        return _underlying;",
                        "    }",
                        "}"
                    ],
                    "del": []
                }
            }
        ],
        "- `Governor`: Enable timestamp operation for blockchains without a stable block time. This is achieved by connecting a Governor's internal clock to match a voting token's EIP-6372 interface. ([#3934](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3934))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3934": {
                    "add": [
                        "        uint64 voteStart;",
                        "        address proposer;",
                        "        bytes4 __gap_unused0;",
                        "        uint64 voteEnd;",
                        "        bytes24 __gap_unused1;",
                        "                type(IERC6372).interfaceId ^",
                        "            interfaceId == (type(IGovernor).interfaceId ^ type(IERC6372).interfaceId ^ this.cancel.selector) ||",
                        "        uint256 currentTimepoint = clock();",
                        "        if (snapshot >= currentTimepoint) {",
                        "        if (deadline >= currentTimepoint) {",
                        "    /**",
                        "     * @dev Part of the Governor Bravo's interface: _\"The number of votes required in order for a voter to become a proposer\"_.",
                        "     */",
                        "    function proposalThreshold() public view virtual returns (uint256) {",
                        "        return 0;",
                        "    }",
                        "        return _proposals[proposalId].voteStart;",
                        "        return _proposals[proposalId].voteEnd;",
                        "     * @dev Address of the proposer",
                        "    function _proposalProposer(uint256 proposalId) internal view virtual returns (address) {",
                        "        return _proposals[proposalId].proposer;",
                        "     * @dev Get the voting weight of `account` at a specific `timepoint`, for a vote as described by `params`.",
                        "    function _getVotes(address account, uint256 timepoint, bytes memory params) internal view virtual returns (uint256);",
                        "        uint256 currentTimepoint = clock();",
                        "            getVotes(proposer, currentTimepoint - 1) >= proposalThreshold(),",
                        "        require(_proposals[proposalId].proposer == address(0), \"Governor: proposal already exists\");",
                        "        uint256 snapshot = currentTimepoint + votingDelay();",
                        "        uint256 deadline = snapshot + votingPeriod();",
                        "        _proposals[proposalId] = ProposalCore({",
                        "            proposer: proposer,",
                        "            voteStart: snapshot.toUint64(),",
                        "            voteEnd: deadline.toUint64(),",
                        "            executed: false,",
                        "            canceled: false,",
                        "            __gap_unused0: 0,",
                        "            __gap_unused1: 0",
                        "        });",
                        "    function getVotes(address account, uint256 timepoint) public view virtual override returns (uint256) {",
                        "        return _getVotes(account, timepoint, _defaultParams());",
                        "        uint256 timepoint,",
                        "        return _getVotes(account, timepoint, params);",
                        "        uint256 weight = _getVotes(account, proposal.voteStart, params);",
                        "abstract contract IGovernor is IERC165, IERC6372 {",
                        "        uint256 voteStart,",
                        "        uint256 voteEnd,",
                        "    /**",
                        "     * @notice module:core",
                        "     * @dev See {IERC6372}",
                        "     */",
                        "    function clock() public view virtual override returns (uint48);",
                        "    /**",
                        "     * @notice module:core",
                        "     * @dev See EIP-6372.",
                        "     */",
                        "    function CLOCK_MODE() public view virtual override returns (string memory);",
                        "    function COUNTING_MODE() public view virtual returns (string memory);",
                        "     * @dev Timepoint used to retrieve user's votes and quorum. If using block number (as per Compound's Comp), the",
                        "     * snapshot is performed at the end of this block. Hence, voting for this proposal starts at the beginning of the",
                        "     * following block.",
                        "     * @dev Timepoint at which votes close. If using block number, votes close at the end of this block, so it is",
                        "     * possible to cast a vote during this block.",
                        "     * @dev Delay, between the proposal is created and the vote starts. The unit this duration is expressed in depends",
                        "     * on the clock (see EIP-6372) this contract uses.",
                        "     *",
                        "     * This can be increased to leave time for users to buy voting power, or delegate it, before the voting of a",
                        "     * proposal starts.",
                        "     * @dev Delay, between the vote start and vote ends. The unit this duration is expressed in depends on the clock",
                        "     * (see EIP-6372) this contract uses.",
                        "     * NOTE: The `timepoint` parameter corresponds to the snapshot used for counting vote. This allows to scale the",
                        "     * quorum depending on values such as the totalSupply of a token at this timepoint (see {ERC20Votes}).",
                        "    function quorum(uint256 timepoint) public view virtual returns (uint256);",
                        "     * @dev Voting power of an `account` at a specific `timepoint`.",
                        "    function getVotes(address account, uint256 timepoint) public view virtual returns (uint256);",
                        "     * @dev Voting power of an `account` at a specific `timepoint` given additional encoded parameters.",
                        "        uint256 timepoint,",
                        "     * @dev Create a new proposal. Vote start after a delay specified by {IGovernor-votingDelay} and lasts for a",
                        "     * duration specified by {IGovernor-votingPeriod}.",
                        "        address proposer = _proposalDetails[proposalId].proposer;",
                        "            _msgSender() == proposer || getVotes(proposer, clock() - 1) < proposalThreshold(),",
                        "        return quorum(clock() - 1);",
                        "    mapping(uint256 => uint64) private _extendedDeadlines;",
                        "        return Math.max(super.proposalDeadline(proposalId), _extendedDeadlines[proposalId]);",
                        "        if (_extendedDeadlines[proposalId] == 0 && _quorumReached(proposalId)) {",
                        "            uint64 extendedDeadline = clock() + lateQuorumVoteExtension();",
                        "            if (extendedDeadline > proposalDeadline(proposalId)) {",
                        "                emit ProposalExtended(proposalId, extendedDeadline);",
                        "            _extendedDeadlines[proposalId] = extendedDeadline;",
                        "    mapping(uint256 => uint64) private _proposalTimelocks;",
                        "        return _proposalTimelocks[proposalId];",
                        "        _proposalTimelocks[proposalId] = eta.toUint64();",
                        "            delete _proposalTimelocks[proposalId];",
                        "    IERC5805 public immutable token;",
                        "        token = IERC5805(address(tokenAddress));",
                        "    }",
                        "    /**",
                        "     * @dev Clock (as specified in EIP-6372) is set to match the token's clock. Fallback to block numbers if the token",
                        "     * does not implement EIP-6372.",
                        "     */",
                        "    function clock() public view virtual override returns (uint48) {",
                        "        try token.clock() returns (uint48 timepoint) {",
                        "            return timepoint;",
                        "        } catch {",
                        "            return SafeCast.toUint48(block.number);",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Machine-readable description of the clock as specified in EIP-6372.",
                        "     */",
                        "    function CLOCK_MODE() public view virtual override returns (string memory) {",
                        "        try token.CLOCK_MODE() returns (string memory clockmode) {",
                        "            return clockmode;",
                        "        } catch {",
                        "            return \"mode=blocknumber&from=default\";",
                        "        }",
                        "        uint256 timepoint,",
                        "        return token.getPastVotes(account, timepoint);",
                        "     * @dev Clock (as specified in EIP-6372) is set to match the token's clock. Fallback to block numbers if the token",
                        "     * does not implement EIP-6372.",
                        "     */",
                        "    function clock() public view virtual override returns (uint48) {",
                        "        try token.clock() returns (uint48 timepoint) {",
                        "            return timepoint;",
                        "        } catch {",
                        "            return SafeCast.toUint48(block.number);",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Machine-readable description of the clock as specified in EIP-6372.",
                        "     */",
                        "    function CLOCK_MODE() public view virtual override returns (string memory) {",
                        "        try token.CLOCK_MODE() returns (string memory clockmode) {",
                        "            return clockmode;",
                        "        } catch {",
                        "            return \"mode=blocknumber&from=default\";",
                        "        }",
                        "    }",
                        "    /**",
                        "     * Read the voting weight from the token's built-in snapshot mechanism (see {Governor-_getVotes}).",
                        "        uint256 timepoint,",
                        "        return token.getPriorVotes(account, timepoint);",
                        "    using SafeCast for *;",
                        "    using Checkpoints for Checkpoints.Trace224;",
                        "    Checkpoints.Trace224 private _quorumNumeratorHistory;",
                        "     * @dev Returns the quorum numerator at a specific timepoint. See {quorumDenominator}.",
                        "    function quorumNumerator(uint256 timepoint) public view virtual returns (uint256) {",
                        "        Checkpoints.Checkpoint224 memory latest = _quorumNumeratorHistory._checkpoints[length - 1];",
                        "        if (latest._key <= timepoint) {",
                        "        return _quorumNumeratorHistory.upperLookupRecent(timepoint.toUint32());",
                        "     * @dev Returns the quorum for a timepoint, in terms of number of votes: `supply * numerator / denominator`.",
                        "    function quorum(uint256 timepoint) public view virtual override returns (uint256) {",
                        "        return (token.getPastTotalSupply(timepoint) * quorumNumerator(timepoint)) / quorumDenominator();",
                        "                Checkpoints.Checkpoint224({_key: 0, _value: oldQuorumNumerator.toUint224()})",
                        "        _quorumNumeratorHistory.push(clock().toUint32(), newQuorumNumerator.toUint224());",
                        "     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is",
                        "     * configured to use block numbers, this will return the value the end of the corresponding block.",
                        "    function getPastVotes(address account, uint256 timepoint) external view returns (uint256);",
                        "     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is",
                        "     * configured to use block numbers, this will return the value the end of the corresponding block.",
                        "    function getPastTotalSupply(uint256 timepoint) external view returns (uint256);",
                        "abstract contract Votes is Context, EIP712, IERC5805 {",
                        "    using Checkpoints for Checkpoints.Trace224;",
                        "    mapping(address => Checkpoints.Trace224) private _delegateCheckpoints;",
                        "    Checkpoints.Trace224 private _totalCheckpoints;",
                        "    /**",
                        "     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based",
                        "     * checkpoints (and voting), in which case {CLOCK_MODE} should be overridden as well to match.",
                        "     */",
                        "    function clock() public view virtual override returns (uint48) {",
                        "        return SafeCast.toUint48(block.number);",
                        "    }",
                        "    /**",
                        "     * @dev Machine-readable description of the clock as specified in EIP-6372.",
                        "     */",
                        "    function CLOCK_MODE() public view virtual override returns (string memory) {",
                        "        require(clock() == block.number);",
                        "        return \"mode=blocknumber&from=default\";",
                        "    }",
                        "     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is",
                        "     * configured to use block numbers, this will return the value the end of the corresponding block.",
                        "     * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.",
                        "    function getPastVotes(address account, uint256 timepoint) public view virtual override returns (uint256) {",
                        "        require(timepoint < clock(), \"Votes: future lookup\");",
                        "        return _delegateCheckpoints[account].upperLookupRecent(SafeCast.toUint32(timepoint));",
                        "     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is",
                        "     * configured to use block numbers, this will return the value the end of the corresponding block.",
                        "     * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.",
                        "    function getPastTotalSupply(uint256 timepoint) public view virtual override returns (uint256) {",
                        "        require(timepoint < clock(), \"Votes: future lookup\");",
                        "        return _totalCheckpoints.upperLookupRecent(SafeCast.toUint32(timepoint));",
                        "            _push(_totalCheckpoints, _add, SafeCast.toUint224(amount));",
                        "            _push(_totalCheckpoints, _subtract, SafeCast.toUint224(amount));",
                        "                (uint256 oldValue, uint256 newValue) = _push(",
                        "                    _delegateCheckpoints[from],",
                        "                    _subtract,",
                        "                    SafeCast.toUint224(amount)",
                        "                );",
                        "                (uint256 oldValue, uint256 newValue) = _push(",
                        "                    _delegateCheckpoints[to],",
                        "                    _add,",
                        "                    SafeCast.toUint224(amount)",
                        "                );",
                        "    function _push(",
                        "        Checkpoints.Trace224 storage store,",
                        "        function(uint224, uint224) view returns (uint224) op,",
                        "        uint224 delta",
                        "    ) private returns (uint224, uint224) {",
                        "        return store.push(SafeCast.toUint32(clock()), op(store.latest(), delta));",
                        "    }",
                        "    function _add(uint224 a, uint224 b) private pure returns (uint224) {",
                        "    function _subtract(uint224 a, uint224 b) private pure returns (uint224) {",
                        "interface IERC5805 is IERC6372, IVotes {}",
                        "interface IERC6372 {",
                        "    /**",
                        "     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).",
                        "     */",
                        "    function clock() external view returns (uint48);",
                        "    /**",
                        "     * @dev Description of the clock",
                        "     */",
                        "    function CLOCK_MODE() external view returns (string memory);",
                        "}",
                        "abstract contract VotesTimestampMock is VotesMock {",
                        "    function clock() public view override returns (uint48) {",
                        "        return uint48(block.timestamp);",
                        "    }",
                        "    function CLOCK_MODE() public view virtual override returns (string memory) {",
                        "        return \"mode=timestamp\";",
                        "    }",
                        "}",
                        "/**",
                        " * @dev Copied from the master branch at commit 86de1e8b6c3fa6b4efa4a5435869d2521be0f5f5",
                        " */",
                        "abstract contract ERC20VotesLegacyMock is IVotes, ERC20Permit {",
                        "    struct Checkpoint {",
                        "        uint32 fromBlock;",
                        "        uint224 votes;",
                        "    }",
                        "    bytes32 private constant _DELEGATION_TYPEHASH =",
                        "        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");",
                        "    mapping(address => address) private _delegates;",
                        "    mapping(address => Checkpoint[]) private _checkpoints;",
                        "    Checkpoint[] private _totalSupplyCheckpoints;",
                        "    /**",
                        "     * @dev Get the `pos`-th checkpoint for `account`.",
                        "     */",
                        "    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {",
                        "        return _checkpoints[account][pos];",
                        "    }",
                        "    /**",
                        "     * @dev Get number of checkpoints for `account`.",
                        "     */",
                        "    function numCheckpoints(address account) public view virtual returns (uint32) {",
                        "        return SafeCast.toUint32(_checkpoints[account].length);",
                        "    }",
                        "    /**",
                        "     * @dev Get the address `account` is currently delegating to.",
                        "     */",
                        "    function delegates(address account) public view virtual override returns (address) {",
                        "        return _delegates[account];",
                        "    }",
                        "    /**",
                        "     * @dev Gets the current votes balance for `account`",
                        "     */",
                        "    function getVotes(address account) public view virtual override returns (uint256) {",
                        "        uint256 pos = _checkpoints[account].length;",
                        "        unchecked {",
                        "            return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `blockNumber` must have been already mined",
                        "     */",
                        "    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");",
                        "        return _checkpointsLookup(_checkpoints[account], blockNumber);",
                        "    }",
                        "    /**",
                        "     * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.",
                        "     * It is NOT the sum of all the delegated votes!",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `blockNumber` must have been already mined",
                        "     */",
                        "    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");",
                        "        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);",
                        "    }",
                        "    /**",
                        "     * @dev Lookup a value in a list of (sorted) checkpoints.",
                        "     */",
                        "    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {",
                        "        //",
                        "        uint256 length = ckpts.length;",
                        "        uint256 low = 0;",
                        "        uint256 high = length;",
                        "        if (length > 5) {",
                        "            uint256 mid = length - Math.sqrt(length);",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > blockNumber) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }",
                        "        }",
                        "        while (low < high) {",
                        "            uint256 mid = Math.average(low, high);",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > blockNumber) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }",
                        "        }",
                        "        unchecked {",
                        "            return high == 0 ? 0 : _unsafeAccess(ckpts, high - 1).votes;",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Delegate votes from the sender to `delegatee`.",
                        "     */",
                        "    function delegate(address delegatee) public virtual override {",
                        "        _delegate(_msgSender(), delegatee);",
                        "    }",
                        "    /**",
                        "     * @dev Delegates votes from signer to `delegatee`",
                        "     */",
                        "    function delegateBySig(",
                        "        address delegatee,",
                        "        uint256 nonce,",
                        "        uint256 expiry,",
                        "        uint8 v,",
                        "        bytes32 r,",
                        "        bytes32 s",
                        "    ) public virtual override {",
                        "        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");",
                        "        address signer = ECDSA.recover(",
                        "            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),",
                        "            v,",
                        "            r,",
                        "            s",
                        "        );",
                        "        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");",
                        "        _delegate(signer, delegatee);",
                        "    }",
                        "    /**",
                        "     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).",
                        "     */",
                        "    function _maxSupply() internal view virtual returns (uint224) {",
                        "        return type(uint224).max;",
                        "    }",
                        "    /**",
                        "     * @dev Snapshots the totalSupply after it has been increased.",
                        "     */",
                        "    function _mint(address account, uint256 amount) internal virtual override {",
                        "        super._mint(account, amount);",
                        "        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");",
                        "        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);",
                        "    }",
                        "    /**",
                        "     * @dev Snapshots the totalSupply after it has been decreased.",
                        "     */",
                        "    function _burn(address account, uint256 amount) internal virtual override {",
                        "        super._burn(account, amount);",
                        "        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);",
                        "    }",
                        "    /**",
                        "     * @dev Move voting power when tokens are transferred.",
                        "     *",
                        "     * Emits a {IVotes-DelegateVotesChanged} event.",
                        "     */",
                        "    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual override {",
                        "        super._afterTokenTransfer(from, to, amount);",
                        "        _moveVotingPower(delegates(from), delegates(to), amount);",
                        "    }",
                        "    /**",
                        "     * @dev Change delegation for `delegator` to `delegatee`.",
                        "     *",
                        "     * Emits events {IVotes-DelegateChanged} and {IVotes-DelegateVotesChanged}.",
                        "     */",
                        "    function _delegate(address delegator, address delegatee) internal virtual {",
                        "        address currentDelegate = delegates(delegator);",
                        "        uint256 delegatorBalance = balanceOf(delegator);",
                        "        _delegates[delegator] = delegatee;",
                        "        emit DelegateChanged(delegator, currentDelegate, delegatee);",
                        "        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);",
                        "    }",
                        "    function _moveVotingPower(address src, address dst, uint256 amount) private {",
                        "        if (src != dst && amount > 0) {",
                        "            if (src != address(0)) {",
                        "                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);",
                        "                emit DelegateVotesChanged(src, oldWeight, newWeight);",
                        "            }",
                        "            if (dst != address(0)) {",
                        "                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);",
                        "                emit DelegateVotesChanged(dst, oldWeight, newWeight);",
                        "            }",
                        "        }",
                        "    }",
                        "    function _writeCheckpoint(",
                        "        Checkpoint[] storage ckpts,",
                        "        function(uint256, uint256) view returns (uint256) op,",
                        "        uint256 delta",
                        "    ) private returns (uint256 oldWeight, uint256 newWeight) {",
                        "        uint256 pos = ckpts.length;",
                        "        unchecked {",
                        "            Checkpoint memory oldCkpt = pos == 0 ? Checkpoint(0, 0) : _unsafeAccess(ckpts, pos - 1);",
                        "            oldWeight = oldCkpt.votes;",
                        "            newWeight = op(oldWeight, delta);",
                        "            if (pos > 0 && oldCkpt.fromBlock == block.number) {",
                        "                _unsafeAccess(ckpts, pos - 1).votes = SafeCast.toUint224(newWeight);",
                        "            } else {",
                        "                ckpts.push(",
                        "                    Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)})",
                        "                );",
                        "            }",
                        "        }",
                        "    }",
                        "    function _add(uint256 a, uint256 b) private pure returns (uint256) {",
                        "        return a + b;",
                        "    }",
                        "    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {",
                        "        return a - b;",
                        "    }",
                        "    /**",
                        "     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.",
                        "     */",
                        "    function _unsafeAccess(Checkpoint[] storage ckpts, uint256 pos) private pure returns (Checkpoint storage result) {",
                        "        assembly {",
                        "            mstore(0, ckpts.slot)",
                        "            result.slot := add(keccak256(0, 0x20), pos)",
                        "        }",
                        "    }",
                        "}",
                        "abstract contract ERC20VotesTimestampMock is ERC20Votes {",
                        "    function clock() public view virtual override returns (uint48) {",
                        "        return SafeCast.toUint48(block.timestamp);",
                        "    }",
                        "    function CLOCK_MODE() public view virtual override returns (string memory) {",
                        "        return \"mode=timestamp\";",
                        "    }",
                        "}",
                        "abstract contract ERC20VotesCompTimestampMock is ERC20VotesComp {",
                        "    function clock() public view virtual override returns (uint48) {",
                        "        return SafeCast.toUint48(block.timestamp);",
                        "    }",
                        "    function CLOCK_MODE() public view virtual override returns (string memory) {",
                        "        return \"mode=timestamp\";",
                        "    }",
                        "}",
                        "abstract contract ERC721VotesTimestampMock is ERC721Votes {",
                        "    function clock() public view virtual override returns (uint48) {",
                        "        return SafeCast.toUint48(block.timestamp);",
                        "    }",
                        "    function CLOCK_MODE() public view virtual override returns (string memory) {",
                        "        return \"mode=timestamp\";",
                        "    }",
                        "}",
                        "abstract contract ERC20Votes is ERC20Permit, IERC5805 {",
                        "    /**",
                        "     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).",
                        "     */",
                        "    function clock() public view virtual override returns (uint48) {",
                        "        return SafeCast.toUint48(block.number);",
                        "    }",
                        "    /**",
                        "     * @dev Description of the clock",
                        "     */",
                        "    function CLOCK_MODE() public view virtual override returns (string memory) {",
                        "        require(clock() == block.number);",
                        "        return \"mode=blocknumber&from=default\";",
                        "    }",
                        "     * @dev Retrieve the number of votes for `account` at the end of `timepoint`.",
                        "     * - `timepoint` must be in the past",
                        "    function getPastVotes(address account, uint256 timepoint) public view virtual override returns (uint256) {",
                        "        require(timepoint < clock(), \"ERC20Votes: future lookup\");",
                        "        return _checkpointsLookup(_checkpoints[account], timepoint);",
                        "     * @dev Retrieve the `totalSupply` at the end of `timepoint`. Note, this value is the sum of all balances.",
                        "     * - `timepoint` must be in the past",
                        "    function getPastTotalSupply(uint256 timepoint) public view virtual override returns (uint256) {",
                        "        require(timepoint < clock(), \"ERC20Votes: future lookup\");",
                        "        return _checkpointsLookup(_totalSupplyCheckpoints, timepoint);",
                        "    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 timepoint) private view returns (uint256) {",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > timepoint) {",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > timepoint) {",
                        "            if (pos > 0 && oldCkpt.fromBlock == clock()) {",
                        "                ckpts.push(Checkpoint({fromBlock: SafeCast.toUint32(clock()), votes: SafeCast.toUint224(newWeight)}));",
                        "    /**",
                        "     * @dev Returns the value in the most recent checkpoint with key lower or equal than the search key.",
                        "     *",
                        "     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high keys).",
                        "     */",
                        "    function upperLookupRecent(Trace224 storage self, uint32 key) internal view returns (uint224) {",
                        "        uint256 len = self._checkpoints.length;",
                        "        uint256 low = 0;",
                        "        uint256 high = len;",
                        "        if (len > 5) {",
                        "            uint256 mid = len - Math.sqrt(len);",
                        "            if (key < _unsafeAccess(self._checkpoints, mid)._key) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }",
                        "        }",
                        "        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);",
                        "        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
                        "    }",
                        "    /**",
                        "     * @dev Returns the value in the most recent checkpoint with key lower or equal than the search key.",
                        "     *",
                        "     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high keys).",
                        "     */",
                        "    function upperLookupRecent(Trace160 storage self, uint96 key) internal view returns (uint160) {",
                        "        uint256 len = self._checkpoints.length;",
                        "        uint256 low = 0;",
                        "        uint256 high = len;",
                        "        if (len > 5) {",
                        "            uint256 mid = len - Math.sqrt(len);",
                        "            if (key < _unsafeAccess(self._checkpoints, mid)._key) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }",
                        "        }",
                        "        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);",
                        "        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
                        "    }"
                    ],
                    "del": [
                        "    using Timers for Timers.BlockNumber;",
                        "        Timers.BlockNumber voteStart;",
                        "        Timers.BlockNumber voteEnd;",
                        "        address proposer;",
                        "            interfaceId == (type(IGovernor).interfaceId ^ this.cancel.selector) ||",
                        "            interfaceId == type(IGovernor).interfaceId ||",
                        "        if (snapshot >= block.number) {",
                        "        if (deadline >= block.number) {",
                        "        return _proposals[proposalId].voteStart.getDeadline();",
                        "        return _proposals[proposalId].voteEnd.getDeadline();",
                        "     * @dev Part of the Governor Bravo's interface: _\"The number of votes required in order for a voter to become a proposer\"_.",
                        "    function proposalThreshold() public view virtual returns (uint256) {",
                        "        return 0;",
                        "     * @dev Get the voting weight of `account` at a specific `blockNumber`, for a vote as described by `params`.",
                        "    function _getVotes(",
                        "        address account,",
                        "        uint256 blockNumber,",
                        "        bytes memory params",
                        "    ) internal view virtual returns (uint256);",
                        "            getVotes(proposer, block.number - 1) >= proposalThreshold(),",
                        "        ProposalCore storage proposal = _proposals[proposalId];",
                        "        require(proposal.voteStart.isUnset(), \"Governor: proposal already exists\");",
                        "        uint64 snapshot = block.number.toUint64() + votingDelay().toUint64();",
                        "        uint64 deadline = snapshot + votingPeriod().toUint64();",
                        "        proposal.voteStart.setDeadline(snapshot);",
                        "        proposal.voteEnd.setDeadline(deadline);",
                        "        proposal.proposer = proposer;",
                        "    function getVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        return _getVotes(account, blockNumber, _defaultParams());",
                        "        uint256 blockNumber,",
                        "        return _getVotes(account, blockNumber, params);",
                        "        uint256 weight = _getVotes(account, proposal.voteStart.getDeadline(), params);",
                        "abstract contract IGovernor is IERC165 {",
                        "        uint256 startBlock,",
                        "        uint256 endBlock,",
                        "    function COUNTING_MODE() public pure virtual returns (string memory);",
                        "     * @dev Block number used to retrieve user's votes and quorum. As per Compound's Comp and OpenZeppelin's",
                        "     * ERC20Votes, the snapshot is performed at the end of this block. Hence, voting for this proposal starts at the",
                        "     * beginning of the following block.",
                        "     * @dev Block number at which votes close. Votes close at the end of this block, so it is possible to cast a vote",
                        "     * during this block.",
                        "     * @dev Delay, in number of block, between the proposal is created and the vote starts. This can be increased to",
                        "     * leave time for users to buy voting power, or delegate it, before the voting of a proposal starts.",
                        "     * @dev Delay, in number of blocks, between the vote start and vote ends.",
                        "     * Note: The `blockNumber` parameter corresponds to the snapshot used for counting vote. This allows to scale the",
                        "     * quorum depending on values such as the totalSupply of a token at this block (see {ERC20Votes}).",
                        "    function quorum(uint256 blockNumber) public view virtual returns (uint256);",
                        "     * @dev Voting power of an `account` at a specific `blockNumber`.",
                        "    function getVotes(address account, uint256 blockNumber) public view virtual returns (uint256);",
                        "     * @dev Voting power of an `account` at a specific `blockNumber` given additional encoded parameters.",
                        "        uint256 blockNumber,",
                        "     * @dev Create a new proposal. Vote start {IGovernor-votingDelay} blocks after the proposal is created and ends",
                        "     * {IGovernor-votingPeriod} blocks after the voting starts.",
                        "        ProposalDetails storage details = _proposalDetails[proposalId];",
                        "            _msgSender() == details.proposer || getVotes(details.proposer, block.number - 1) < proposalThreshold(),",
                        "        return quorum(block.number - 1);",
                        "    using Timers for Timers.BlockNumber;",
                        "    mapping(uint256 => Timers.BlockNumber) private _extendedDeadlines;",
                        "        return Math.max(super.proposalDeadline(proposalId), _extendedDeadlines[proposalId].getDeadline());",
                        "        Timers.BlockNumber storage extendedDeadline = _extendedDeadlines[proposalId];",
                        "        if (extendedDeadline.isUnset() && _quorumReached(proposalId)) {",
                        "            uint64 extendedDeadlineValue = block.number.toUint64() + lateQuorumVoteExtension();",
                        "            if (extendedDeadlineValue > proposalDeadline(proposalId)) {",
                        "                emit ProposalExtended(proposalId, extendedDeadlineValue);",
                        "            extendedDeadline.setDeadline(extendedDeadlineValue);",
                        "    using Timers for Timers.Timestamp;",
                        "    struct ProposalTimelock {",
                        "        Timers.Timestamp timer;",
                        "    }",
                        "    mapping(uint256 => ProposalTimelock) private _proposalTimelocks;",
                        "        return _proposalTimelocks[proposalId].timer.getDeadline();",
                        "        _proposalTimelocks[proposalId].timer.setDeadline(eta.toUint64());",
                        "            _proposalTimelocks[proposalId].timer.reset();",
                        "    IVotes public immutable token;",
                        "        token = tokenAddress;",
                        "        uint256 blockNumber,",
                        "        return token.getPastVotes(account, blockNumber);",
                        "     * Read the voting weight from the token's built in snapshot mechanism (see {Governor-_getVotes}).",
                        "        uint256 blockNumber,",
                        "        return token.getPriorVotes(account, blockNumber);",
                        "    using Checkpoints for Checkpoints.History;",
                        "    Checkpoints.History private _quorumNumeratorHistory;",
                        "     * @dev Returns the quorum numerator at a specific block number. See {quorumDenominator}.",
                        "    function quorumNumerator(uint256 blockNumber) public view virtual returns (uint256) {",
                        "        Checkpoints.Checkpoint memory latest = _quorumNumeratorHistory._checkpoints[length - 1];",
                        "        if (latest._blockNumber <= blockNumber) {",
                        "        return _quorumNumeratorHistory.getAtBlock(blockNumber);",
                        "     * @dev Returns the quorum for a block number, in terms of number of votes: `supply * numerator / denominator`.",
                        "    function quorum(uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        return (token.getPastTotalSupply(blockNumber) * quorumNumerator(blockNumber)) / quorumDenominator();",
                        "                Checkpoints.Checkpoint({_blockNumber: 0, _value: SafeCast.toUint224(oldQuorumNumerator)})",
                        "        _quorumNumeratorHistory.push(newQuorumNumerator);",
                        "     * @dev Returns the amount of votes that `account` had at the end of a past block (`blockNumber`).",
                        "    function getPastVotes(address account, uint256 blockNumber) external view returns (uint256);",
                        "     * @dev Returns the total supply of votes available at the end of a past block (`blockNumber`).",
                        "    function getPastTotalSupply(uint256 blockNumber) external view returns (uint256);",
                        "abstract contract Votes is IVotes, Context, EIP712 {",
                        "    using Checkpoints for Checkpoints.History;",
                        "    mapping(address => Checkpoints.History) private _delegateCheckpoints;",
                        "    Checkpoints.History private _totalCheckpoints;",
                        "     * @dev Returns the amount of votes that `account` had at the end of a past block (`blockNumber`).",
                        "     * - `blockNumber` must have been already mined",
                        "    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        return _delegateCheckpoints[account].getAtProbablyRecentBlock(blockNumber);",
                        "     * @dev Returns the total supply of votes available at the end of a past block (`blockNumber`).",
                        "     * - `blockNumber` must have been already mined",
                        "    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        require(blockNumber < block.number, \"Votes: block not yet mined\");",
                        "        return _totalCheckpoints.getAtProbablyRecentBlock(blockNumber);",
                        "            _totalCheckpoints.push(_add, amount);",
                        "            _totalCheckpoints.push(_subtract, amount);",
                        "                (uint256 oldValue, uint256 newValue) = _delegateCheckpoints[from].push(_subtract, amount);",
                        "                (uint256 oldValue, uint256 newValue) = _delegateCheckpoints[to].push(_add, amount);",
                        "    function _add(uint256 a, uint256 b) private pure returns (uint256) {",
                        "    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {",
                        "abstract contract ERC20Votes is IVotes, ERC20Permit {",
                        "     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.",
                        "     * - `blockNumber` must have been already mined",
                        "    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");",
                        "        return _checkpointsLookup(_checkpoints[account], blockNumber);",
                        "     * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.",
                        "     * - `blockNumber` must have been already mined",
                        "    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");",
                        "        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);",
                        "    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > blockNumber) {",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > blockNumber) {",
                        "            if (pos > 0 && oldCkpt.fromBlock == block.number) {",
                        "                ckpts.push(",
                        "                    Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)})",
                        "                );"
                    ]
                }
            }
        ],
        "- `Votes`, `ERC20Votes`, `ERC721Votes`: support timestamp checkpointing using EIP-6372. ([#3934](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3934))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3934": {
                    "add": [
                        "        uint64 voteStart;",
                        "        address proposer;",
                        "        bytes4 __gap_unused0;",
                        "        uint64 voteEnd;",
                        "        bytes24 __gap_unused1;",
                        "                type(IERC6372).interfaceId ^",
                        "            interfaceId == (type(IGovernor).interfaceId ^ type(IERC6372).interfaceId ^ this.cancel.selector) ||",
                        "        uint256 currentTimepoint = clock();",
                        "        if (snapshot >= currentTimepoint) {",
                        "        if (deadline >= currentTimepoint) {",
                        "    /**",
                        "     * @dev Part of the Governor Bravo's interface: _\"The number of votes required in order for a voter to become a proposer\"_.",
                        "     */",
                        "    function proposalThreshold() public view virtual returns (uint256) {",
                        "        return 0;",
                        "    }",
                        "        return _proposals[proposalId].voteStart;",
                        "        return _proposals[proposalId].voteEnd;",
                        "     * @dev Address of the proposer",
                        "    function _proposalProposer(uint256 proposalId) internal view virtual returns (address) {",
                        "        return _proposals[proposalId].proposer;",
                        "     * @dev Get the voting weight of `account` at a specific `timepoint`, for a vote as described by `params`.",
                        "    function _getVotes(address account, uint256 timepoint, bytes memory params) internal view virtual returns (uint256);",
                        "        uint256 currentTimepoint = clock();",
                        "            getVotes(proposer, currentTimepoint - 1) >= proposalThreshold(),",
                        "        require(_proposals[proposalId].proposer == address(0), \"Governor: proposal already exists\");",
                        "        uint256 snapshot = currentTimepoint + votingDelay();",
                        "        uint256 deadline = snapshot + votingPeriod();",
                        "        _proposals[proposalId] = ProposalCore({",
                        "            proposer: proposer,",
                        "            voteStart: snapshot.toUint64(),",
                        "            voteEnd: deadline.toUint64(),",
                        "            executed: false,",
                        "            canceled: false,",
                        "            __gap_unused0: 0,",
                        "            __gap_unused1: 0",
                        "        });",
                        "    function getVotes(address account, uint256 timepoint) public view virtual override returns (uint256) {",
                        "        return _getVotes(account, timepoint, _defaultParams());",
                        "        uint256 timepoint,",
                        "        return _getVotes(account, timepoint, params);",
                        "        uint256 weight = _getVotes(account, proposal.voteStart, params);",
                        "abstract contract IGovernor is IERC165, IERC6372 {",
                        "        uint256 voteStart,",
                        "        uint256 voteEnd,",
                        "    /**",
                        "     * @notice module:core",
                        "     * @dev See {IERC6372}",
                        "     */",
                        "    function clock() public view virtual override returns (uint48);",
                        "    /**",
                        "     * @notice module:core",
                        "     * @dev See EIP-6372.",
                        "     */",
                        "    function CLOCK_MODE() public view virtual override returns (string memory);",
                        "    function COUNTING_MODE() public view virtual returns (string memory);",
                        "     * @dev Timepoint used to retrieve user's votes and quorum. If using block number (as per Compound's Comp), the",
                        "     * snapshot is performed at the end of this block. Hence, voting for this proposal starts at the beginning of the",
                        "     * following block.",
                        "     * @dev Timepoint at which votes close. If using block number, votes close at the end of this block, so it is",
                        "     * possible to cast a vote during this block.",
                        "     * @dev Delay, between the proposal is created and the vote starts. The unit this duration is expressed in depends",
                        "     * on the clock (see EIP-6372) this contract uses.",
                        "     *",
                        "     * This can be increased to leave time for users to buy voting power, or delegate it, before the voting of a",
                        "     * proposal starts.",
                        "     * @dev Delay, between the vote start and vote ends. The unit this duration is expressed in depends on the clock",
                        "     * (see EIP-6372) this contract uses.",
                        "     * NOTE: The `timepoint` parameter corresponds to the snapshot used for counting vote. This allows to scale the",
                        "     * quorum depending on values such as the totalSupply of a token at this timepoint (see {ERC20Votes}).",
                        "    function quorum(uint256 timepoint) public view virtual returns (uint256);",
                        "     * @dev Voting power of an `account` at a specific `timepoint`.",
                        "    function getVotes(address account, uint256 timepoint) public view virtual returns (uint256);",
                        "     * @dev Voting power of an `account` at a specific `timepoint` given additional encoded parameters.",
                        "        uint256 timepoint,",
                        "     * @dev Create a new proposal. Vote start after a delay specified by {IGovernor-votingDelay} and lasts for a",
                        "     * duration specified by {IGovernor-votingPeriod}.",
                        "        address proposer = _proposalDetails[proposalId].proposer;",
                        "            _msgSender() == proposer || getVotes(proposer, clock() - 1) < proposalThreshold(),",
                        "        return quorum(clock() - 1);",
                        "    mapping(uint256 => uint64) private _extendedDeadlines;",
                        "        return Math.max(super.proposalDeadline(proposalId), _extendedDeadlines[proposalId]);",
                        "        if (_extendedDeadlines[proposalId] == 0 && _quorumReached(proposalId)) {",
                        "            uint64 extendedDeadline = clock() + lateQuorumVoteExtension();",
                        "            if (extendedDeadline > proposalDeadline(proposalId)) {",
                        "                emit ProposalExtended(proposalId, extendedDeadline);",
                        "            _extendedDeadlines[proposalId] = extendedDeadline;",
                        "    mapping(uint256 => uint64) private _proposalTimelocks;",
                        "        return _proposalTimelocks[proposalId];",
                        "        _proposalTimelocks[proposalId] = eta.toUint64();",
                        "            delete _proposalTimelocks[proposalId];",
                        "    IERC5805 public immutable token;",
                        "        token = IERC5805(address(tokenAddress));",
                        "    }",
                        "    /**",
                        "     * @dev Clock (as specified in EIP-6372) is set to match the token's clock. Fallback to block numbers if the token",
                        "     * does not implement EIP-6372.",
                        "     */",
                        "    function clock() public view virtual override returns (uint48) {",
                        "        try token.clock() returns (uint48 timepoint) {",
                        "            return timepoint;",
                        "        } catch {",
                        "            return SafeCast.toUint48(block.number);",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Machine-readable description of the clock as specified in EIP-6372.",
                        "     */",
                        "    function CLOCK_MODE() public view virtual override returns (string memory) {",
                        "        try token.CLOCK_MODE() returns (string memory clockmode) {",
                        "            return clockmode;",
                        "        } catch {",
                        "            return \"mode=blocknumber&from=default\";",
                        "        }",
                        "        uint256 timepoint,",
                        "        return token.getPastVotes(account, timepoint);",
                        "     * @dev Clock (as specified in EIP-6372) is set to match the token's clock. Fallback to block numbers if the token",
                        "     * does not implement EIP-6372.",
                        "     */",
                        "    function clock() public view virtual override returns (uint48) {",
                        "        try token.clock() returns (uint48 timepoint) {",
                        "            return timepoint;",
                        "        } catch {",
                        "            return SafeCast.toUint48(block.number);",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Machine-readable description of the clock as specified in EIP-6372.",
                        "     */",
                        "    function CLOCK_MODE() public view virtual override returns (string memory) {",
                        "        try token.CLOCK_MODE() returns (string memory clockmode) {",
                        "            return clockmode;",
                        "        } catch {",
                        "            return \"mode=blocknumber&from=default\";",
                        "        }",
                        "    }",
                        "    /**",
                        "     * Read the voting weight from the token's built-in snapshot mechanism (see {Governor-_getVotes}).",
                        "        uint256 timepoint,",
                        "        return token.getPriorVotes(account, timepoint);",
                        "    using SafeCast for *;",
                        "    using Checkpoints for Checkpoints.Trace224;",
                        "    Checkpoints.Trace224 private _quorumNumeratorHistory;",
                        "     * @dev Returns the quorum numerator at a specific timepoint. See {quorumDenominator}.",
                        "    function quorumNumerator(uint256 timepoint) public view virtual returns (uint256) {",
                        "        Checkpoints.Checkpoint224 memory latest = _quorumNumeratorHistory._checkpoints[length - 1];",
                        "        if (latest._key <= timepoint) {",
                        "        return _quorumNumeratorHistory.upperLookupRecent(timepoint.toUint32());",
                        "     * @dev Returns the quorum for a timepoint, in terms of number of votes: `supply * numerator / denominator`.",
                        "    function quorum(uint256 timepoint) public view virtual override returns (uint256) {",
                        "        return (token.getPastTotalSupply(timepoint) * quorumNumerator(timepoint)) / quorumDenominator();",
                        "                Checkpoints.Checkpoint224({_key: 0, _value: oldQuorumNumerator.toUint224()})",
                        "        _quorumNumeratorHistory.push(clock().toUint32(), newQuorumNumerator.toUint224());",
                        "     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is",
                        "     * configured to use block numbers, this will return the value the end of the corresponding block.",
                        "    function getPastVotes(address account, uint256 timepoint) external view returns (uint256);",
                        "     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is",
                        "     * configured to use block numbers, this will return the value the end of the corresponding block.",
                        "    function getPastTotalSupply(uint256 timepoint) external view returns (uint256);",
                        "abstract contract Votes is Context, EIP712, IERC5805 {",
                        "    using Checkpoints for Checkpoints.Trace224;",
                        "    mapping(address => Checkpoints.Trace224) private _delegateCheckpoints;",
                        "    Checkpoints.Trace224 private _totalCheckpoints;",
                        "    /**",
                        "     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based",
                        "     * checkpoints (and voting), in which case {CLOCK_MODE} should be overridden as well to match.",
                        "     */",
                        "    function clock() public view virtual override returns (uint48) {",
                        "        return SafeCast.toUint48(block.number);",
                        "    }",
                        "    /**",
                        "     * @dev Machine-readable description of the clock as specified in EIP-6372.",
                        "     */",
                        "    function CLOCK_MODE() public view virtual override returns (string memory) {",
                        "        require(clock() == block.number);",
                        "        return \"mode=blocknumber&from=default\";",
                        "    }",
                        "     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is",
                        "     * configured to use block numbers, this will return the value the end of the corresponding block.",
                        "     * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.",
                        "    function getPastVotes(address account, uint256 timepoint) public view virtual override returns (uint256) {",
                        "        require(timepoint < clock(), \"Votes: future lookup\");",
                        "        return _delegateCheckpoints[account].upperLookupRecent(SafeCast.toUint32(timepoint));",
                        "     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is",
                        "     * configured to use block numbers, this will return the value the end of the corresponding block.",
                        "     * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.",
                        "    function getPastTotalSupply(uint256 timepoint) public view virtual override returns (uint256) {",
                        "        require(timepoint < clock(), \"Votes: future lookup\");",
                        "        return _totalCheckpoints.upperLookupRecent(SafeCast.toUint32(timepoint));",
                        "            _push(_totalCheckpoints, _add, SafeCast.toUint224(amount));",
                        "            _push(_totalCheckpoints, _subtract, SafeCast.toUint224(amount));",
                        "                (uint256 oldValue, uint256 newValue) = _push(",
                        "                    _delegateCheckpoints[from],",
                        "                    _subtract,",
                        "                    SafeCast.toUint224(amount)",
                        "                );",
                        "                (uint256 oldValue, uint256 newValue) = _push(",
                        "                    _delegateCheckpoints[to],",
                        "                    _add,",
                        "                    SafeCast.toUint224(amount)",
                        "                );",
                        "    function _push(",
                        "        Checkpoints.Trace224 storage store,",
                        "        function(uint224, uint224) view returns (uint224) op,",
                        "        uint224 delta",
                        "    ) private returns (uint224, uint224) {",
                        "        return store.push(SafeCast.toUint32(clock()), op(store.latest(), delta));",
                        "    }",
                        "    function _add(uint224 a, uint224 b) private pure returns (uint224) {",
                        "    function _subtract(uint224 a, uint224 b) private pure returns (uint224) {",
                        "interface IERC5805 is IERC6372, IVotes {}",
                        "interface IERC6372 {",
                        "    /**",
                        "     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).",
                        "     */",
                        "    function clock() external view returns (uint48);",
                        "    /**",
                        "     * @dev Description of the clock",
                        "     */",
                        "    function CLOCK_MODE() external view returns (string memory);",
                        "}",
                        "abstract contract VotesTimestampMock is VotesMock {",
                        "    function clock() public view override returns (uint48) {",
                        "        return uint48(block.timestamp);",
                        "    }",
                        "    function CLOCK_MODE() public view virtual override returns (string memory) {",
                        "        return \"mode=timestamp\";",
                        "    }",
                        "}",
                        "/**",
                        " * @dev Copied from the master branch at commit 86de1e8b6c3fa6b4efa4a5435869d2521be0f5f5",
                        " */",
                        "abstract contract ERC20VotesLegacyMock is IVotes, ERC20Permit {",
                        "    struct Checkpoint {",
                        "        uint32 fromBlock;",
                        "        uint224 votes;",
                        "    }",
                        "    bytes32 private constant _DELEGATION_TYPEHASH =",
                        "        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");",
                        "    mapping(address => address) private _delegates;",
                        "    mapping(address => Checkpoint[]) private _checkpoints;",
                        "    Checkpoint[] private _totalSupplyCheckpoints;",
                        "    /**",
                        "     * @dev Get the `pos`-th checkpoint for `account`.",
                        "     */",
                        "    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {",
                        "        return _checkpoints[account][pos];",
                        "    }",
                        "    /**",
                        "     * @dev Get number of checkpoints for `account`.",
                        "     */",
                        "    function numCheckpoints(address account) public view virtual returns (uint32) {",
                        "        return SafeCast.toUint32(_checkpoints[account].length);",
                        "    }",
                        "    /**",
                        "     * @dev Get the address `account` is currently delegating to.",
                        "     */",
                        "    function delegates(address account) public view virtual override returns (address) {",
                        "        return _delegates[account];",
                        "    }",
                        "    /**",
                        "     * @dev Gets the current votes balance for `account`",
                        "     */",
                        "    function getVotes(address account) public view virtual override returns (uint256) {",
                        "        uint256 pos = _checkpoints[account].length;",
                        "        unchecked {",
                        "            return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `blockNumber` must have been already mined",
                        "     */",
                        "    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");",
                        "        return _checkpointsLookup(_checkpoints[account], blockNumber);",
                        "    }",
                        "    /**",
                        "     * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.",
                        "     * It is NOT the sum of all the delegated votes!",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `blockNumber` must have been already mined",
                        "     */",
                        "    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");",
                        "        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);",
                        "    }",
                        "    /**",
                        "     * @dev Lookup a value in a list of (sorted) checkpoints.",
                        "     */",
                        "    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {",
                        "        //",
                        "        uint256 length = ckpts.length;",
                        "        uint256 low = 0;",
                        "        uint256 high = length;",
                        "        if (length > 5) {",
                        "            uint256 mid = length - Math.sqrt(length);",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > blockNumber) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }",
                        "        }",
                        "        while (low < high) {",
                        "            uint256 mid = Math.average(low, high);",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > blockNumber) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }",
                        "        }",
                        "        unchecked {",
                        "            return high == 0 ? 0 : _unsafeAccess(ckpts, high - 1).votes;",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Delegate votes from the sender to `delegatee`.",
                        "     */",
                        "    function delegate(address delegatee) public virtual override {",
                        "        _delegate(_msgSender(), delegatee);",
                        "    }",
                        "    /**",
                        "     * @dev Delegates votes from signer to `delegatee`",
                        "     */",
                        "    function delegateBySig(",
                        "        address delegatee,",
                        "        uint256 nonce,",
                        "        uint256 expiry,",
                        "        uint8 v,",
                        "        bytes32 r,",
                        "        bytes32 s",
                        "    ) public virtual override {",
                        "        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");",
                        "        address signer = ECDSA.recover(",
                        "            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),",
                        "            v,",
                        "            r,",
                        "            s",
                        "        );",
                        "        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");",
                        "        _delegate(signer, delegatee);",
                        "    }",
                        "    /**",
                        "     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).",
                        "     */",
                        "    function _maxSupply() internal view virtual returns (uint224) {",
                        "        return type(uint224).max;",
                        "    }",
                        "    /**",
                        "     * @dev Snapshots the totalSupply after it has been increased.",
                        "     */",
                        "    function _mint(address account, uint256 amount) internal virtual override {",
                        "        super._mint(account, amount);",
                        "        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");",
                        "        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);",
                        "    }",
                        "    /**",
                        "     * @dev Snapshots the totalSupply after it has been decreased.",
                        "     */",
                        "    function _burn(address account, uint256 amount) internal virtual override {",
                        "        super._burn(account, amount);",
                        "        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);",
                        "    }",
                        "    /**",
                        "     * @dev Move voting power when tokens are transferred.",
                        "     *",
                        "     * Emits a {IVotes-DelegateVotesChanged} event.",
                        "     */",
                        "    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual override {",
                        "        super._afterTokenTransfer(from, to, amount);",
                        "        _moveVotingPower(delegates(from), delegates(to), amount);",
                        "    }",
                        "    /**",
                        "     * @dev Change delegation for `delegator` to `delegatee`.",
                        "     *",
                        "     * Emits events {IVotes-DelegateChanged} and {IVotes-DelegateVotesChanged}.",
                        "     */",
                        "    function _delegate(address delegator, address delegatee) internal virtual {",
                        "        address currentDelegate = delegates(delegator);",
                        "        uint256 delegatorBalance = balanceOf(delegator);",
                        "        _delegates[delegator] = delegatee;",
                        "        emit DelegateChanged(delegator, currentDelegate, delegatee);",
                        "        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);",
                        "    }",
                        "    function _moveVotingPower(address src, address dst, uint256 amount) private {",
                        "        if (src != dst && amount > 0) {",
                        "            if (src != address(0)) {",
                        "                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);",
                        "                emit DelegateVotesChanged(src, oldWeight, newWeight);",
                        "            }",
                        "            if (dst != address(0)) {",
                        "                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);",
                        "                emit DelegateVotesChanged(dst, oldWeight, newWeight);",
                        "            }",
                        "        }",
                        "    }",
                        "    function _writeCheckpoint(",
                        "        Checkpoint[] storage ckpts,",
                        "        function(uint256, uint256) view returns (uint256) op,",
                        "        uint256 delta",
                        "    ) private returns (uint256 oldWeight, uint256 newWeight) {",
                        "        uint256 pos = ckpts.length;",
                        "        unchecked {",
                        "            Checkpoint memory oldCkpt = pos == 0 ? Checkpoint(0, 0) : _unsafeAccess(ckpts, pos - 1);",
                        "            oldWeight = oldCkpt.votes;",
                        "            newWeight = op(oldWeight, delta);",
                        "            if (pos > 0 && oldCkpt.fromBlock == block.number) {",
                        "                _unsafeAccess(ckpts, pos - 1).votes = SafeCast.toUint224(newWeight);",
                        "            } else {",
                        "                ckpts.push(",
                        "                    Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)})",
                        "                );",
                        "            }",
                        "        }",
                        "    }",
                        "    function _add(uint256 a, uint256 b) private pure returns (uint256) {",
                        "        return a + b;",
                        "    }",
                        "    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {",
                        "        return a - b;",
                        "    }",
                        "    /**",
                        "     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.",
                        "     */",
                        "    function _unsafeAccess(Checkpoint[] storage ckpts, uint256 pos) private pure returns (Checkpoint storage result) {",
                        "        assembly {",
                        "            mstore(0, ckpts.slot)",
                        "            result.slot := add(keccak256(0, 0x20), pos)",
                        "        }",
                        "    }",
                        "}",
                        "abstract contract ERC20VotesTimestampMock is ERC20Votes {",
                        "    function clock() public view virtual override returns (uint48) {",
                        "        return SafeCast.toUint48(block.timestamp);",
                        "    }",
                        "    function CLOCK_MODE() public view virtual override returns (string memory) {",
                        "        return \"mode=timestamp\";",
                        "    }",
                        "}",
                        "abstract contract ERC20VotesCompTimestampMock is ERC20VotesComp {",
                        "    function clock() public view virtual override returns (uint48) {",
                        "        return SafeCast.toUint48(block.timestamp);",
                        "    }",
                        "    function CLOCK_MODE() public view virtual override returns (string memory) {",
                        "        return \"mode=timestamp\";",
                        "    }",
                        "}",
                        "abstract contract ERC721VotesTimestampMock is ERC721Votes {",
                        "    function clock() public view virtual override returns (uint48) {",
                        "        return SafeCast.toUint48(block.timestamp);",
                        "    }",
                        "    function CLOCK_MODE() public view virtual override returns (string memory) {",
                        "        return \"mode=timestamp\";",
                        "    }",
                        "}",
                        "abstract contract ERC20Votes is ERC20Permit, IERC5805 {",
                        "    /**",
                        "     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).",
                        "     */",
                        "    function clock() public view virtual override returns (uint48) {",
                        "        return SafeCast.toUint48(block.number);",
                        "    }",
                        "    /**",
                        "     * @dev Description of the clock",
                        "     */",
                        "    function CLOCK_MODE() public view virtual override returns (string memory) {",
                        "        require(clock() == block.number);",
                        "        return \"mode=blocknumber&from=default\";",
                        "    }",
                        "     * @dev Retrieve the number of votes for `account` at the end of `timepoint`.",
                        "     * - `timepoint` must be in the past",
                        "    function getPastVotes(address account, uint256 timepoint) public view virtual override returns (uint256) {",
                        "        require(timepoint < clock(), \"ERC20Votes: future lookup\");",
                        "        return _checkpointsLookup(_checkpoints[account], timepoint);",
                        "     * @dev Retrieve the `totalSupply` at the end of `timepoint`. Note, this value is the sum of all balances.",
                        "     * - `timepoint` must be in the past",
                        "    function getPastTotalSupply(uint256 timepoint) public view virtual override returns (uint256) {",
                        "        require(timepoint < clock(), \"ERC20Votes: future lookup\");",
                        "        return _checkpointsLookup(_totalSupplyCheckpoints, timepoint);",
                        "    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 timepoint) private view returns (uint256) {",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > timepoint) {",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > timepoint) {",
                        "            if (pos > 0 && oldCkpt.fromBlock == clock()) {",
                        "                ckpts.push(Checkpoint({fromBlock: SafeCast.toUint32(clock()), votes: SafeCast.toUint224(newWeight)}));",
                        "    /**",
                        "     * @dev Returns the value in the most recent checkpoint with key lower or equal than the search key.",
                        "     *",
                        "     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high keys).",
                        "     */",
                        "    function upperLookupRecent(Trace224 storage self, uint32 key) internal view returns (uint224) {",
                        "        uint256 len = self._checkpoints.length;",
                        "        uint256 low = 0;",
                        "        uint256 high = len;",
                        "        if (len > 5) {",
                        "            uint256 mid = len - Math.sqrt(len);",
                        "            if (key < _unsafeAccess(self._checkpoints, mid)._key) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }",
                        "        }",
                        "        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);",
                        "        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
                        "    }",
                        "    /**",
                        "     * @dev Returns the value in the most recent checkpoint with key lower or equal than the search key.",
                        "     *",
                        "     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high keys).",
                        "     */",
                        "    function upperLookupRecent(Trace160 storage self, uint96 key) internal view returns (uint160) {",
                        "        uint256 len = self._checkpoints.length;",
                        "        uint256 low = 0;",
                        "        uint256 high = len;",
                        "        if (len > 5) {",
                        "            uint256 mid = len - Math.sqrt(len);",
                        "            if (key < _unsafeAccess(self._checkpoints, mid)._key) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }",
                        "        }",
                        "        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);",
                        "        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
                        "    }"
                    ],
                    "del": [
                        "    using Timers for Timers.BlockNumber;",
                        "        Timers.BlockNumber voteStart;",
                        "        Timers.BlockNumber voteEnd;",
                        "        address proposer;",
                        "            interfaceId == (type(IGovernor).interfaceId ^ this.cancel.selector) ||",
                        "            interfaceId == type(IGovernor).interfaceId ||",
                        "        if (snapshot >= block.number) {",
                        "        if (deadline >= block.number) {",
                        "        return _proposals[proposalId].voteStart.getDeadline();",
                        "        return _proposals[proposalId].voteEnd.getDeadline();",
                        "     * @dev Part of the Governor Bravo's interface: _\"The number of votes required in order for a voter to become a proposer\"_.",
                        "    function proposalThreshold() public view virtual returns (uint256) {",
                        "        return 0;",
                        "     * @dev Get the voting weight of `account` at a specific `blockNumber`, for a vote as described by `params`.",
                        "    function _getVotes(",
                        "        address account,",
                        "        uint256 blockNumber,",
                        "        bytes memory params",
                        "    ) internal view virtual returns (uint256);",
                        "            getVotes(proposer, block.number - 1) >= proposalThreshold(),",
                        "        ProposalCore storage proposal = _proposals[proposalId];",
                        "        require(proposal.voteStart.isUnset(), \"Governor: proposal already exists\");",
                        "        uint64 snapshot = block.number.toUint64() + votingDelay().toUint64();",
                        "        uint64 deadline = snapshot + votingPeriod().toUint64();",
                        "        proposal.voteStart.setDeadline(snapshot);",
                        "        proposal.voteEnd.setDeadline(deadline);",
                        "        proposal.proposer = proposer;",
                        "    function getVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        return _getVotes(account, blockNumber, _defaultParams());",
                        "        uint256 blockNumber,",
                        "        return _getVotes(account, blockNumber, params);",
                        "        uint256 weight = _getVotes(account, proposal.voteStart.getDeadline(), params);",
                        "abstract contract IGovernor is IERC165 {",
                        "        uint256 startBlock,",
                        "        uint256 endBlock,",
                        "    function COUNTING_MODE() public pure virtual returns (string memory);",
                        "     * @dev Block number used to retrieve user's votes and quorum. As per Compound's Comp and OpenZeppelin's",
                        "     * ERC20Votes, the snapshot is performed at the end of this block. Hence, voting for this proposal starts at the",
                        "     * beginning of the following block.",
                        "     * @dev Block number at which votes close. Votes close at the end of this block, so it is possible to cast a vote",
                        "     * during this block.",
                        "     * @dev Delay, in number of block, between the proposal is created and the vote starts. This can be increased to",
                        "     * leave time for users to buy voting power, or delegate it, before the voting of a proposal starts.",
                        "     * @dev Delay, in number of blocks, between the vote start and vote ends.",
                        "     * Note: The `blockNumber` parameter corresponds to the snapshot used for counting vote. This allows to scale the",
                        "     * quorum depending on values such as the totalSupply of a token at this block (see {ERC20Votes}).",
                        "    function quorum(uint256 blockNumber) public view virtual returns (uint256);",
                        "     * @dev Voting power of an `account` at a specific `blockNumber`.",
                        "    function getVotes(address account, uint256 blockNumber) public view virtual returns (uint256);",
                        "     * @dev Voting power of an `account` at a specific `blockNumber` given additional encoded parameters.",
                        "        uint256 blockNumber,",
                        "     * @dev Create a new proposal. Vote start {IGovernor-votingDelay} blocks after the proposal is created and ends",
                        "     * {IGovernor-votingPeriod} blocks after the voting starts.",
                        "        ProposalDetails storage details = _proposalDetails[proposalId];",
                        "            _msgSender() == details.proposer || getVotes(details.proposer, block.number - 1) < proposalThreshold(),",
                        "        return quorum(block.number - 1);",
                        "    using Timers for Timers.BlockNumber;",
                        "    mapping(uint256 => Timers.BlockNumber) private _extendedDeadlines;",
                        "        return Math.max(super.proposalDeadline(proposalId), _extendedDeadlines[proposalId].getDeadline());",
                        "        Timers.BlockNumber storage extendedDeadline = _extendedDeadlines[proposalId];",
                        "        if (extendedDeadline.isUnset() && _quorumReached(proposalId)) {",
                        "            uint64 extendedDeadlineValue = block.number.toUint64() + lateQuorumVoteExtension();",
                        "            if (extendedDeadlineValue > proposalDeadline(proposalId)) {",
                        "                emit ProposalExtended(proposalId, extendedDeadlineValue);",
                        "            extendedDeadline.setDeadline(extendedDeadlineValue);",
                        "    using Timers for Timers.Timestamp;",
                        "    struct ProposalTimelock {",
                        "        Timers.Timestamp timer;",
                        "    }",
                        "    mapping(uint256 => ProposalTimelock) private _proposalTimelocks;",
                        "        return _proposalTimelocks[proposalId].timer.getDeadline();",
                        "        _proposalTimelocks[proposalId].timer.setDeadline(eta.toUint64());",
                        "            _proposalTimelocks[proposalId].timer.reset();",
                        "    IVotes public immutable token;",
                        "        token = tokenAddress;",
                        "        uint256 blockNumber,",
                        "        return token.getPastVotes(account, blockNumber);",
                        "     * Read the voting weight from the token's built in snapshot mechanism (see {Governor-_getVotes}).",
                        "        uint256 blockNumber,",
                        "        return token.getPriorVotes(account, blockNumber);",
                        "    using Checkpoints for Checkpoints.History;",
                        "    Checkpoints.History private _quorumNumeratorHistory;",
                        "     * @dev Returns the quorum numerator at a specific block number. See {quorumDenominator}.",
                        "    function quorumNumerator(uint256 blockNumber) public view virtual returns (uint256) {",
                        "        Checkpoints.Checkpoint memory latest = _quorumNumeratorHistory._checkpoints[length - 1];",
                        "        if (latest._blockNumber <= blockNumber) {",
                        "        return _quorumNumeratorHistory.getAtBlock(blockNumber);",
                        "     * @dev Returns the quorum for a block number, in terms of number of votes: `supply * numerator / denominator`.",
                        "    function quorum(uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        return (token.getPastTotalSupply(blockNumber) * quorumNumerator(blockNumber)) / quorumDenominator();",
                        "                Checkpoints.Checkpoint({_blockNumber: 0, _value: SafeCast.toUint224(oldQuorumNumerator)})",
                        "        _quorumNumeratorHistory.push(newQuorumNumerator);",
                        "     * @dev Returns the amount of votes that `account` had at the end of a past block (`blockNumber`).",
                        "    function getPastVotes(address account, uint256 blockNumber) external view returns (uint256);",
                        "     * @dev Returns the total supply of votes available at the end of a past block (`blockNumber`).",
                        "    function getPastTotalSupply(uint256 blockNumber) external view returns (uint256);",
                        "abstract contract Votes is IVotes, Context, EIP712 {",
                        "    using Checkpoints for Checkpoints.History;",
                        "    mapping(address => Checkpoints.History) private _delegateCheckpoints;",
                        "    Checkpoints.History private _totalCheckpoints;",
                        "     * @dev Returns the amount of votes that `account` had at the end of a past block (`blockNumber`).",
                        "     * - `blockNumber` must have been already mined",
                        "    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        return _delegateCheckpoints[account].getAtProbablyRecentBlock(blockNumber);",
                        "     * @dev Returns the total supply of votes available at the end of a past block (`blockNumber`).",
                        "     * - `blockNumber` must have been already mined",
                        "    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        require(blockNumber < block.number, \"Votes: block not yet mined\");",
                        "        return _totalCheckpoints.getAtProbablyRecentBlock(blockNumber);",
                        "            _totalCheckpoints.push(_add, amount);",
                        "            _totalCheckpoints.push(_subtract, amount);",
                        "                (uint256 oldValue, uint256 newValue) = _delegateCheckpoints[from].push(_subtract, amount);",
                        "                (uint256 oldValue, uint256 newValue) = _delegateCheckpoints[to].push(_add, amount);",
                        "    function _add(uint256 a, uint256 b) private pure returns (uint256) {",
                        "    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {",
                        "abstract contract ERC20Votes is IVotes, ERC20Permit {",
                        "     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.",
                        "     * - `blockNumber` must have been already mined",
                        "    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");",
                        "        return _checkpointsLookup(_checkpoints[account], blockNumber);",
                        "     * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.",
                        "     * - `blockNumber` must have been already mined",
                        "    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");",
                        "        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);",
                        "    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > blockNumber) {",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > blockNumber) {",
                        "            if (pos > 0 && oldCkpt.fromBlock == block.number) {",
                        "                ckpts.push(",
                        "                    Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)})",
                        "                );"
                    ]
                }
            }
        ],
        "- `ERC4626`: Add mitigation to the inflation attack through virtual shares and assets. ([#3979](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3979))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3979": {
                    "add": [
                        "abstract contract ERC4626OffsetMock is ERC4626 {",
                        "    uint8 private immutable _offset;",
                        "    constructor(uint8 offset_) {",
                        "        _offset = offset_;",
                        "    }",
                        "    function _decimalsOffset() internal view virtual override returns (uint8) {",
                        "        return _offset;",
                        "    }",
                        "}",
                        " * [CAUTION]",
                        " * ====",
                        " * In empty (or nearly empty) ERC-4626 vaults, deposits are at high risk of being stolen through frontrunning",
                        " * with a \"donation\" to the vault that inflates the price of a share. This is variously known as a donation or inflation",
                        " * similarly be affected by slippage. Users can protect against this attack as well as unexpected slippage in general by",
                        " * Since v4.9, this implementation uses virtual assets and shares to mitigate that risk. The `_decimalsOffset()`",
                        " * corresponds to an offset in the decimal representation between the underlying asset's decimals and the vault",
                        " * decimals. This offset also determines the rate of virtual shares to virtual assets in the vault, which itself",
                        " * determines the initial exchange rate. While not fully preventing the attack, analysis shows that the default offset",
                        " * (0) makes it non-profitable, as a result of the value being captured by the virtual shares (out of the attacker's",
                        " * donation) matching the attacker's expected gains. With a larger offset, the attack becomes orders of magnitude more",
                        " * expensive than it is profitable. More details about the underlying math can be found",
                        " * xref:erc4626.adoc#inflation-attack[here].",
                        " *",
                        " * The drawback of this approach is that the virtual shares do capture (a very small) part of the value being accrued",
                        " * to the vault. Also, if the vault experiences losses, the users try to exit the vault, the virtual shares and assets",
                        " * will cause the first user to exit to experience reduced losses in detriment to the last users that will experience",
                        " * bigger losses. Developers willing to revert back to the pre-v4.9 behavior just need to override the",
                        " * `_convertToShares` and `_convertToAssets` functions.",
                        " *",
                        " * To learn more, check out our xref:ROOT:erc4626.adoc[ERC-4626 guide].",
                        " * ====",
                        " *",
                        "    uint8 private immutable _underlyingDecimals;",
                        "        _underlyingDecimals = success ? assetDecimals : 18;",
                        "        return _underlyingDecimals + _decimalsOffset();",
                        "        return type(uint256).max;",
                        "        return assets.mulDiv(totalSupply() + 10 ** _decimalsOffset(), totalAssets() + 1, rounding);",
                        "        return shares.mulDiv(totalAssets() + 1, totalSupply() + 10 ** _decimalsOffset(), rounding);",
                        "    function _decimalsOffset() internal view virtual returns (uint8) {",
                        "        return 0;",
                        "    function _asRounding(uint8 r) private pure returns (Math.Rounding) {"
                    ],
                    "del": [
                        "abstract contract ERC4626DecimalsMock is ERC4626 {",
                        "    using Math for uint256;",
                        "    uint8 private immutable _decimals;",
                        "    constructor(uint8 decimals_) {",
                        "        _decimals = decimals_;",
                        "    }",
                        "    function decimals() public view virtual override returns (uint8) {",
                        "        return _decimals;",
                        "    }",
                        "    function _initialConvertToShares(",
                        "        uint256 assets,",
                        "        Math.Rounding rounding",
                        "    ) internal view virtual override returns (uint256 shares) {",
                        "        return assets.mulDiv(10 ** decimals(), 10 ** super.decimals(), rounding);",
                        "    }",
                        "    function _initialConvertToAssets(",
                        "        uint256 shares,",
                        "        Math.Rounding rounding",
                        "    ) internal view virtual override returns (uint256 assets) {",
                        "        return shares.mulDiv(10 ** super.decimals(), 10 ** decimals(), rounding);",
                        "    }",
                        "}",
                        " * CAUTION: When the vault is empty or nearly empty, deposits are at high risk of being stolen through frontrunning with",
                        " * a \"donation\" to the vault that inflates the price of a share. This is variously known as a donation or inflation",
                        " * similarly be affected by slippage. Users can protect against this attack as well unexpected slippage in general by",
                        "    uint8 private immutable _decimals;",
                        "        _decimals = success ? assetDecimals : super.decimals();",
                        "        return _decimals;",
                        "        return _isVaultHealthy() ? type(uint256).max : 0;",
                        "        uint256 supply = totalSupply();",
                        "        return",
                        "            (assets == 0 || supply == 0)",
                        "                ? _initialConvertToShares(assets, rounding)",
                        "                : assets.mulDiv(supply, totalAssets(), rounding);",
                        "    }",
                        "    /**",
                        "     * @dev Internal conversion function (from assets to shares) to apply when the vault is empty.",
                        "     *",
                        "     * NOTE: Make sure to keep this function consistent with {_initialConvertToAssets} when overriding it.",
                        "     */",
                        "    function _initialConvertToShares(",
                        "        uint256 assets,",
                        "        Math.Rounding /*rounding*/",
                        "    ) internal view virtual returns (uint256 shares) {",
                        "        return assets;",
                        "        uint256 supply = totalSupply();",
                        "        return",
                        "            (supply == 0) ? _initialConvertToAssets(shares, rounding) : shares.mulDiv(totalAssets(), supply, rounding);",
                        "    }",
                        "    /**",
                        "     * @dev Internal conversion function (from shares to assets) to apply when the vault is empty.",
                        "     *",
                        "     * NOTE: Make sure to keep this function consistent with {_initialConvertToShares} when overriding it.",
                        "     */",
                        "    function _initialConvertToAssets(",
                        "        uint256 shares,",
                        "        Math.Rounding /*rounding*/",
                        "    ) internal view virtual returns (uint256) {",
                        "        return shares;",
                        "    /**",
                        "     * @dev Checks if vault is \"healthy\" in the sense of having assets backing the circulating shares.",
                        "     */",
                        "    function _isVaultHealthy() private view returns (bool) {",
                        "        return totalAssets() > 0 || totalSupply() == 0;",
                        "    function test_RT_mint_withdraw(ERC4626Test.Init memory init, uint256 shares) public override {",
                        "        int256 initAssets = 0;",
                        "        for (uint256 i = 0; i < init.share.length; i++) {",
                        "            vm.assume(init.share[i] <= uint256(type(int256).max - initAssets));",
                        "            initAssets += SafeCast.toInt256(init.share[i]);",
                        "        }",
                        "        vm.assume(init.yield > -initAssets);",
                        "        super.test_RT_mint_withdraw(init, shares);",
                        "    }",
                        "    function _asRounding(uint8 r) private returns (Math.Rounding) {"
                    ]
                }
            }
        ],
        "- `ERC20Wrapper`: Make the `underlying` variable private and add a public accessor. ([#4029](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4029))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4029": {
                    "add": [
                        "    IERC20 private immutable _underlying;",
                        "        _underlying = underlyingToken;",
                        "        try IERC20Metadata(address(_underlying)).decimals() returns (uint8 value) {",
                        "    /**",
                        "     * @dev Returns the address of the underlying ERC-20 token that is being wrapped.",
                        "     */",
                        "    function underlying() public view returns (IERC20) {",
                        "        return _underlying;",
                        "    }",
                        "        SafeERC20.safeTransferFrom(_underlying, _msgSender(), address(this), amount);",
                        "        SafeERC20.safeTransfer(_underlying, account, amount);",
                        "        uint256 value = _underlying.balanceOf(address(this)) - totalSupply();"
                    ],
                    "del": [
                        "    IERC20 public immutable underlying;",
                        "        underlying = underlyingToken;",
                        "        try IERC20Metadata(address(underlying)).decimals() returns (uint8 value) {",
                        "        SafeERC20.safeTransferFrom(underlying, _msgSender(), address(this), amount);",
                        "        SafeERC20.safeTransfer(underlying, account, amount);",
                        "        uint256 value = underlying.balanceOf(address(this)) - totalSupply();"
                    ]
                }
            }
        ],
        "- `EIP712`: add EIP-5267 support for better domain discovery. ([#3969](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3969))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3969": {
                    "add": [
                        "interface IERC5267 {",
                        "    /**",
                        "     * @dev MAY be emitted to signal that the domain could have changed.",
                        "     */",
                        "    event EIP712DomainChanged();",
                        "    /**",
                        "     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712",
                        "     * signature.",
                        "     */",
                        "    function eip712Domain()",
                        "        external",
                        "        view",
                        "        returns (",
                        "            bytes1 fields,",
                        "            string memory name,",
                        "            string memory version,",
                        "            uint256 chainId,",
                        "            address verifyingContract,",
                        "            bytes32 salt,",
                        "            uint256[] memory extensions",
                        "        );",
                        "}",
                        " * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain",
                        " * separator of the implementation contract. This will cause the `_domainSeparatorV4` function to always rebuild the",
                        " * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.",
                        " *",
                        " *",
                        " * @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment",
                        "abstract contract EIP712 is IERC5267 {",
                        "    using ShortStrings for *;",
                        "    bytes32 private constant _TYPE_HASH =",
                        "        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");",
                        "    bytes32 private immutable _cachedDomainSeparator;",
                        "    uint256 private immutable _cachedChainId;",
                        "    address private immutable _cachedThis;",
                        "    ShortString private immutable _name;",
                        "    ShortString private immutable _version;",
                        "    string private _nameFallback;",
                        "    string private _versionFallback;",
                        "    bytes32 private immutable _hashedName;",
                        "    bytes32 private immutable _hashedVersion;",
                        "        _name = name.toShortStringWithFallback(_nameFallback);",
                        "        _version = version.toShortStringWithFallback(_versionFallback);",
                        "        _hashedName = keccak256(bytes(name));",
                        "        _hashedVersion = keccak256(bytes(version));",
                        "        _cachedChainId = block.chainid;",
                        "        _cachedDomainSeparator = _buildDomainSeparator();",
                        "        _cachedThis = address(this);",
                        "        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {",
                        "            return _cachedDomainSeparator;",
                        "            return _buildDomainSeparator();",
                        "    function _buildDomainSeparator() private view returns (bytes32) {",
                        "        return keccak256(abi.encode(_TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));",
                        "    /**",
                        "     * @dev See {EIP-5267}.",
                        "     */",
                        "    function eip712Domain()",
                        "        public",
                        "        view",
                        "        virtual",
                        "        override",
                        "        returns (",
                        "            bytes1 fields,",
                        "            string memory name,",
                        "            string memory version,",
                        "            uint256 chainId,",
                        "            address verifyingContract,",
                        "            bytes32 salt,",
                        "            uint256[] memory extensions",
                        "        )",
                        "    {",
                        "        return (",
                        "            _name.toStringWithFallback(_nameFallback),",
                        "            _version.toStringWithFallback(_versionFallback),",
                        "            block.chainid,",
                        "            address(this),",
                        "            bytes32(0),",
                        "            new uint256[](0)",
                        "        );",
                        "    }"
                    ],
                    "del": [
                        "abstract contract EIP712 {",
                        "    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;",
                        "    uint256 private immutable _CACHED_CHAIN_ID;",
                        "    address private immutable _CACHED_THIS;",
                        "    bytes32 private immutable _HASHED_NAME;",
                        "    bytes32 private immutable _HASHED_VERSION;",
                        "    bytes32 private immutable _TYPE_HASH;",
                        "        bytes32 hashedName = keccak256(bytes(name));",
                        "        bytes32 hashedVersion = keccak256(bytes(version));",
                        "        bytes32 typeHash = keccak256(",
                        "            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"",
                        "        );",
                        "        _HASHED_NAME = hashedName;",
                        "        _HASHED_VERSION = hashedVersion;",
                        "        _CACHED_CHAIN_ID = block.chainid;",
                        "        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);",
                        "        _CACHED_THIS = address(this);",
                        "        _TYPE_HASH = typeHash;",
                        "        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {",
                        "            return _CACHED_DOMAIN_SEPARATOR;",
                        "            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);",
                        "    function _buildDomainSeparator(",
                        "        bytes32 typeHash,",
                        "        bytes32 nameHash,",
                        "        bytes32 versionHash",
                        "    ) private view returns (bytes32) {",
                        "        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));"
                    ]
                }
            }
        ],
        "- `AccessControlDefaultAdminRules`: Add an extension of `AccessControl` with additional security rules for the `DEFAULT_ADMIN_ROLE`. ([#4009](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4009))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4009": {
                    "add": [
                        " * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}",
                        " * to enforce additional security measures for this role.",
                        "/**",
                        " * @dev Extension of {AccessControl} that allows specifying special rules to manage",
                        " * the `DEFAULT_ADMIN_ROLE` holder, which is a sensitive role with special permissions",
                        " * over other roles that may potentially have privileged rights in the system.",
                        " *",
                        " * If a specific role doesn't have an admin role assigned, the holder of the",
                        " * `DEFAULT_ADMIN_ROLE` will have the ability to grant it and revoke it.",
                        " *",
                        " * This contract implements the following risk mitigations on top of {AccessControl}:",
                        " *",
                        " * * Only one account holds the `DEFAULT_ADMIN_ROLE` since deployment until it's potentially renounced.",
                        " * * Enforce a 2-step process to transfer the `DEFAULT_ADMIN_ROLE` to another account.",
                        " * * Enforce a configurable delay between the two steps, with the ability to cancel in between.",
                        " *   - Even after the timer has passed to avoid locking it forever.",
                        " * * It is not possible to use another role to manage the `DEFAULT_ADMIN_ROLE`.",
                        " *",
                        " * Example usage:",
                        " *",
                        " * ```solidity",
                        " * contract MyToken is AccessControlDefaultAdminRules {",
                        " *   constructor() AccessControlDefaultAdminRules(",
                        " *     3 days,",
                        " *    ) {}",
                        " *}",
                        " * ```",
                        " *",
                        " * NOTE: The `delay` can only be set in the constructor and is fixed thereafter.",
                        " *",
                        " * _Available since v4.9._",
                        " */",
                        "abstract contract AccessControlDefaultAdminRules is IAccessControlDefaultAdminRules, IERC5313, AccessControl {",
                        "    uint48 private immutable _defaultAdminDelay;",
                        "    address private _currentDefaultAdmin;",
                        "    address private _pendingDefaultAdmin;",
                        "    uint48 private _defaultAdminTransferDelayedUntil;",
                        "    /**",
                        "     * @dev Sets the initial values for {defaultAdminDelay} in seconds and {defaultAdmin}.",
                        "     *",
                        "     * The `defaultAdminDelay` value is immutable. It can only be set at the constructor.",
                        "     */",
                        "    constructor(uint48 defaultAdminDelay_, address initialDefaultAdmin) {",
                        "        _defaultAdminDelay = defaultAdminDelay_;",
                        "        _grantRole(DEFAULT_ADMIN_ROLE, initialDefaultAdmin);",
                        "    }",
                        "    /**",
                        "     * @dev See {IERC5313-owner}.",
                        "     */",
                        "    function owner() public view virtual returns (address) {",
                        "        return defaultAdmin();",
                        "    }",
                        "    /**",
                        "     * @inheritdoc IAccessControlDefaultAdminRules",
                        "     */",
                        "    function defaultAdminDelay() public view virtual returns (uint48) {",
                        "        return _defaultAdminDelay;",
                        "    }",
                        "    /**",
                        "     * @inheritdoc IAccessControlDefaultAdminRules",
                        "     */",
                        "    function defaultAdmin() public view virtual returns (address) {",
                        "        return _currentDefaultAdmin;",
                        "    }",
                        "    /**",
                        "     * @inheritdoc IAccessControlDefaultAdminRules",
                        "     */",
                        "    function pendingDefaultAdmin() public view virtual returns (address) {",
                        "        return _pendingDefaultAdmin;",
                        "    }",
                        "    /**",
                        "     * @inheritdoc IAccessControlDefaultAdminRules",
                        "     */",
                        "    function defaultAdminTransferDelayedUntil() public view virtual returns (uint48) {",
                        "        return _defaultAdminTransferDelayedUntil;",
                        "    }",
                        "    /**",
                        "     * @dev See {IERC165-supportsInterface}.",
                        "     */",
                        "    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {",
                        "        return interfaceId == type(IAccessControlDefaultAdminRules).interfaceId || super.supportsInterface(interfaceId);",
                        "    }",
                        "    /**",
                        "     * @inheritdoc IAccessControlDefaultAdminRules",
                        "     */",
                        "    function beginDefaultAdminTransfer(address newAdmin) public virtual onlyRole(DEFAULT_ADMIN_ROLE) {",
                        "        _beginDefaultAdminTransfer(newAdmin);",
                        "    }",
                        "    /**",
                        "     * @inheritdoc IAccessControlDefaultAdminRules",
                        "     */",
                        "    function acceptDefaultAdminTransfer() public virtual {",
                        "        require(_msgSender() == pendingDefaultAdmin(), \"AccessControl: pending admin must accept\");",
                        "        _acceptDefaultAdminTransfer();",
                        "    }",
                        "    /**",
                        "     * @inheritdoc IAccessControlDefaultAdminRules",
                        "     */",
                        "    function cancelDefaultAdminTransfer() public virtual onlyRole(DEFAULT_ADMIN_ROLE) {",
                        "        _resetDefaultAdminTransfer();",
                        "    }",
                        "    /**",
                        "     * @dev Revokes `role` from the calling account.",
                        "     *",
                        "     * For `DEFAULT_ADMIN_ROLE`, only allows renouncing in two steps, so it's required",
                        "     * that the {defaultAdminTransferDelayedUntil} has passed and the pending default admin is the zero address.",
                        "     * After its execution, it will not be possible to call `onlyRole(DEFAULT_ADMIN_ROLE)`",
                        "     * functions.",
                        "     *",
                        "     * For other roles, see {AccessControl-renounceRole}.",
                        "     *",
                        "     * NOTE: Renouncing `DEFAULT_ADMIN_ROLE` will leave the contract without a defaultAdmin,",
                        "     * thereby disabling any functionality that is only available to the default admin, and the",
                        "     * possibility of reassigning a non-administrated role.",
                        "     */",
                        "    function renounceRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {",
                        "        if (role == DEFAULT_ADMIN_ROLE) {",
                        "            require(",
                        "                pendingDefaultAdmin() == address(0) && _hasDefaultAdminTransferDelayPassed(),",
                        "                \"AccessControl: only can renounce in two delayed steps\"",
                        "            );",
                        "        }",
                        "        super.renounceRole(role, account);",
                        "    }",
                        "    /**",
                        "     * @dev See {AccessControl-grantRole}. Reverts for `DEFAULT_ADMIN_ROLE`.",
                        "     */",
                        "    function grantRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {",
                        "        require(role != DEFAULT_ADMIN_ROLE, \"AccessControl: can't directly grant default admin role\");",
                        "        super.grantRole(role, account);",
                        "    }",
                        "    /**",
                        "     * @dev See {AccessControl-revokeRole}. Reverts for `DEFAULT_ADMIN_ROLE`.",
                        "     */",
                        "    function revokeRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {",
                        "        require(role != DEFAULT_ADMIN_ROLE, \"AccessControl: can't directly revoke default admin role\");",
                        "        super.revokeRole(role, account);",
                        "    }",
                        "    /**",
                        "     * @dev See {AccessControl-_setRoleAdmin}. Reverts for `DEFAULT_ADMIN_ROLE`.",
                        "     */",
                        "    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual override {",
                        "        require(role != DEFAULT_ADMIN_ROLE, \"AccessControl: can't violate default admin rules\");",
                        "        super._setRoleAdmin(role, adminRole);",
                        "    }",
                        "    /**",
                        "     * @dev Grants `role` to `account`.",
                        "     *",
                        "     * For `DEFAULT_ADMIN_ROLE`, it only allows granting if there isn't already a role's holder",
                        "     * or if the role has been previously renounced.",
                        "     *",
                        "     * For other roles, see {AccessControl-renounceRole}.",
                        "     *",
                        "     * NOTE: Exposing this function through another mechanism may make the",
                        "     * `DEFAULT_ADMIN_ROLE` assignable again. Make sure to guarantee this is",
                        "     * the expected behavior in your implementation.",
                        "     */",
                        "    function _grantRole(bytes32 role, address account) internal virtual override {",
                        "        if (role == DEFAULT_ADMIN_ROLE) {",
                        "            require(defaultAdmin() == address(0), \"AccessControl: default admin already granted\");",
                        "            _currentDefaultAdmin = account;",
                        "        }",
                        "        super._grantRole(role, account);",
                        "    }",
                        "    /**",
                        "     * @dev See {acceptDefaultAdminTransfer}.",
                        "     *",
                        "     * Internal function without access restriction.",
                        "     */",
                        "    function _acceptDefaultAdminTransfer() internal virtual {",
                        "        require(_hasDefaultAdminTransferDelayPassed(), \"AccessControl: transfer delay not passed\");",
                        "        _revokeRole(DEFAULT_ADMIN_ROLE, defaultAdmin());",
                        "        _grantRole(DEFAULT_ADMIN_ROLE, pendingDefaultAdmin());",
                        "        _resetDefaultAdminTransfer();",
                        "    }",
                        "    /**",
                        "     * @dev See {beginDefaultAdminTransfer}.",
                        "     *",
                        "     * Internal function without access restriction.",
                        "     */",
                        "    function _beginDefaultAdminTransfer(address newAdmin) internal virtual {",
                        "        _defaultAdminTransferDelayedUntil = SafeCast.toUint48(block.timestamp) + defaultAdminDelay();",
                        "        _pendingDefaultAdmin = newAdmin;",
                        "        emit DefaultAdminRoleChangeStarted(pendingDefaultAdmin(), defaultAdminTransferDelayedUntil());",
                        "    }",
                        "    /**",
                        "     * @dev See {AccessControl-_revokeRole}.",
                        "     */",
                        "    function _revokeRole(bytes32 role, address account) internal virtual override {",
                        "        if (role == DEFAULT_ADMIN_ROLE) {",
                        "            delete _currentDefaultAdmin;",
                        "        }",
                        "        super._revokeRole(role, account);",
                        "    }",
                        "    /**",
                        "     * @dev Resets the pending default admin and delayed until.",
                        "     */",
                        "    function _resetDefaultAdminTransfer() private {",
                        "        delete _pendingDefaultAdmin;",
                        "        delete _defaultAdminTransferDelayedUntil;",
                        "    }",
                        "    /**",
                        "     * @dev Checks if a {defaultAdminTransferDelayedUntil} has been set and passed.",
                        "     */",
                        "    function _hasDefaultAdminTransferDelayPassed() private view returns (bool) {",
                        "        uint48 delayedUntil = defaultAdminTransferDelayedUntil();",
                        "        return delayedUntil > 0 && delayedUntil < block.timestamp;",
                        "    }",
                        "}",
                        "/**",
                        " * @dev External interface of AccessControlDefaultAdminRules declared to support ERC165 detection.",
                        " *",
                        " * _Available since v4.9._",
                        " */",
                        "interface IAccessControlDefaultAdminRules is IAccessControl {",
                        "    /**",
                        "     * @dev Emitted when a `DEFAULT_ADMIN_ROLE` transfer is started, setting `newDefaultAdmin`",
                        "     * as the next default admin, which will have rights to claim the `DEFAULT_ADMIN_ROLE`",
                        "     * after `defaultAdminTransferDelayedUntil` has passed.",
                        "     */",
                        "    event DefaultAdminRoleChangeStarted(address indexed newDefaultAdmin, uint48 defaultAdminTransferDelayedUntil);",
                        "    /**",
                        "     * @dev Returns the delay between each `DEFAULT_ADMIN_ROLE` transfer.",
                        "     */",
                        "    function defaultAdminDelay() external view returns (uint48);",
                        "    /**",
                        "     * @dev Returns the address of the current `DEFAULT_ADMIN_ROLE` holder.",
                        "     */",
                        "    function defaultAdmin() external view returns (address);",
                        "    /**",
                        "     * @dev Returns the address of the pending `DEFAULT_ADMIN_ROLE` holder.",
                        "     */",
                        "    function pendingDefaultAdmin() external view returns (address);",
                        "    /**",
                        "     * @dev Returns the timestamp after which the pending default admin can claim the `DEFAULT_ADMIN_ROLE`.",
                        "     */",
                        "    function defaultAdminTransferDelayedUntil() external view returns (uint48);",
                        "    /**",
                        "     * @dev Starts a `DEFAULT_ADMIN_ROLE` transfer by setting a pending default admin",
                        "     * and a timer to pass.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - Only can be called by the current `DEFAULT_ADMIN_ROLE` holder.",
                        "     *",
                        "     * Emits a {DefaultAdminRoleChangeStarted}.",
                        "     */",
                        "    function beginDefaultAdminTransfer(address newAdmin) external;",
                        "    /**",
                        "     * @dev Completes a `DEFAULT_ADMIN_ROLE` transfer.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - Caller should be the pending default admin.",
                        "     * - `DEFAULT_ADMIN_ROLE` should be granted to the caller.",
                        "     * - `DEFAULT_ADMIN_ROLE` should be revoked from the previous holder.",
                        "     */",
                        "    function acceptDefaultAdminTransfer() external;",
                        "    /**",
                        "     * @dev Cancels a `DEFAULT_ADMIN_ROLE` transfer.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - Can be called even after the timer has passed.",
                        "     * - Can only be called by the current `DEFAULT_ADMIN_ROLE` holder.",
                        "     */",
                        "    function cancelDefaultAdminTransfer() external;",
                        "}",
                        "     * `onlyOwner` functions. Can only be called by the current owner.",
                        "     * thereby disabling any functionality that is only available to the owner."
                    ],
                    "del": [
                        " * accounts that have been granted it.",
                        "     * `onlyOwner` functions anymore. Can only be called by the current owner.",
                        "     * thereby removing any functionality that is only available to the owner."
                    ]
                }
            }
        ],
        "- `SignatureChecker`: Add `isValidERC1271SignatureNow` for checking a signature directly against a smart contract using ERC-1271. ([#3932](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3932))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3932": {
                    "add": [
                        "        return",
                        "            (error == ECDSA.RecoverError.NoError && recovered == signer) ||",
                        "            isValidERC1271SignatureNow(signer, hash, signature);",
                        "    }",
                        "    /**",
                        "     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated",
                        "     * against the signer smart contract using ERC1271.",
                        "     *",
                        "     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus",
                        "     * change through time. It could return true at block N and false at block N+1 (or the opposite).",
                        "     */",
                        "    function isValidERC1271SignatureNow(",
                        "        address signer,",
                        "        bytes32 hash,",
                        "        bytes memory signature",
                        "    ) internal view returns (bool) {"
                    ],
                    "del": [
                        "        if (error == ECDSA.RecoverError.NoError && recovered == signer) {",
                        "            return true;",
                        "        }"
                    ]
                }
            }
        ],
        "- `ERC1967Upgrade`: removed contract-wide `oz-upgrades-unsafe-allow delegatecall` annotation, replaced by granular annotation in `UUPSUpgradeable`. ([#3971](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3971))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3971": {
                    "add": [
                        "     *",
                        "     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall",
                        "     *",
                        "     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall"
                    ],
                    "del": [
                        " *",
                        " * @custom:oz-upgrades-unsafe-allow delegatecall"
                    ]
                }
            }
        ],
        "- `ERC20Wrapper`: self wrapping and deposit by the wrapper itself are now explicitly forbidden. ([#4100](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4100))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4100": {
                    "add": [
                        "contract ERC20PermitHarness is ERC20Permit {",
                        "contract ERC20WrapperHarness is ERC20Wrapper {",
                        "    constructor(IERC20 _underlying, string memory _name, string memory _symbol) ERC20(_name, _symbol) ERC20Wrapper(_underlying) {}",
                        "    function underlyingTotalSupply() public view returns (uint256) {",
                        "        return underlying().totalSupply();",
                        "    }",
                        "    function underlyingBalanceOf(address account) public view returns (uint256) {",
                        "        return underlying().balanceOf(account);",
                        "    }",
                        "    function underlyingAllowanceToThis(address account) public view returns (uint256) {",
                        "        return underlying().allowance(account, address(this));",
                        "    }",
                        "    function recover(address account) public returns (uint256) {",
                        "        return _recover(account);",
                        "    }",
                        "}",
                        "        require(underlyingToken != this, \"ERC20Wrapper: cannot self wrap\");",
                        "        address sender = _msgSender();",
                        "        require(sender != address(this), \"ERC20Wrapper: wrapper can't deposit\");",
                        "        SafeERC20.safeTransferFrom(_underlying, sender, address(this), amount);"
                    ],
                    "del": [
                        "contract ERC20PermitHarness is ERC20, ERC20Permit {",
                        "        SafeERC20.safeTransferFrom(_underlying, _msgSender(), address(this), amount);"
                    ]
                }
            }
        ],
        "- `ECDSA`: optimize bytes32 computation by using assembly instead of `abi.encodePacked`. ([#3853](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3853))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3853": {
                    "add": [
                        "    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {",
                        "        assembly {",
                        "            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")",
                        "            mstore(0x1c, hash)",
                        "            message := keccak256(0x00, 0x3c)",
                        "        }",
                        "    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {",
                        "        assembly {",
                        "            let ptr := mload(0x40)",
                        "            mstore(ptr, \"\\x19\\x01\")",
                        "            mstore(add(ptr, 0x02), domainSeparator)",
                        "            mstore(add(ptr, 0x22), structHash)",
                        "            data := keccak256(ptr, 0x42)",
                        "        }"
                    ],
                    "del": [
                        "    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {",
                        "        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));",
                        "    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {",
                        "        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));"
                    ]
                }
            }
        ],
        "- `ERC721URIStorage`: Emit ERC-4906 `MetadataUpdate` in `_setTokenURI`. ([#4012](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4012))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4012": {
                    "add": [
                        "interface IERC4906 is IERC165, IERC721 {",
                        "    event MetadataUpdate(uint256 _tokenId);",
                        "    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);",
                        "}",
                        "abstract contract ERC721URIStorage is IERC4906, ERC721 {",
                        "     * Emits {MetadataUpdate}.",
                        "     *",
                        "        emit MetadataUpdate(tokenId);"
                    ],
                    "del": [
                        "abstract contract ERC721URIStorage is ERC721 {"
                    ]
                }
            }
        ],
        "- `SignatureChecker`: Allow return data length greater than 32 from EIP-1271 signers. ([#4038](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4038))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4038": {
                    "add": [
                        "            result.length >= 32 &&"
                    ],
                    "del": [
                        "            result.length == 32 &&"
                    ]
                }
            }
        ],
        "- `UUPSUpgradeable`: added granular `oz-upgrades-unsafe-allow-reachable` annotation to improve upgrade safety checks on latest version of the Upgrades Plugins (starting with `@openzeppelin/upgrades-core@1.21.0`). ([#3971](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3971))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3971": {
                    "add": [
                        "     *",
                        "     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall",
                        "     *",
                        "     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall"
                    ],
                    "del": [
                        " *",
                        " * @custom:oz-upgrades-unsafe-allow delegatecall"
                    ]
                }
            }
        ],
        "- `Math`: optimize `log256` rounding check. ([#3745](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3745))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3745": {
                    "add": [
                        "            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);"
                    ],
                    "del": [
                        "            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);"
                    ]
                }
            }
        ],
        "- `ERC20Votes`: optimize by using unchecked arithmetic. ([#3748](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3748))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3748": {
                    "add": [
                        "        unchecked {",
                        "            return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;",
                        "        }",
                        "     * It is NOT the sum of all the delegated votes!",
                        "        unchecked {",
                        "            return high == 0 ? 0 : _unsafeAccess(ckpts, high - 1).votes;",
                        "        }",
                        "        unchecked {",
                        "            Checkpoint memory oldCkpt = pos == 0 ? Checkpoint(0, 0) : _unsafeAccess(ckpts, pos - 1);",
                        "            oldWeight = oldCkpt.votes;",
                        "            newWeight = op(oldWeight, delta);",
                        "            if (pos > 0 && oldCkpt.fromBlock == block.number) {",
                        "                _unsafeAccess(ckpts, pos - 1).votes = SafeCast.toUint224(newWeight);",
                        "            } else {",
                        "                ckpts.push(",
                        "                    Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)})",
                        "                );",
                        "            }"
                    ],
                    "del": [
                        "        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;",
                        "     * It is but NOT the sum of all the delegated votes!",
                        "        return high == 0 ? 0 : _unsafeAccess(ckpts, high - 1).votes;",
                        "        Checkpoint memory oldCkpt = pos == 0 ? Checkpoint(0, 0) : _unsafeAccess(ckpts, pos - 1);",
                        "        oldWeight = oldCkpt.votes;",
                        "        newWeight = op(oldWeight, delta);",
                        "        if (pos > 0 && oldCkpt.fromBlock == block.number) {",
                        "            _unsafeAccess(ckpts, pos - 1).votes = SafeCast.toUint224(newWeight);",
                        "        } else {",
                        "            ckpts.push(Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)}));"
                    ]
                }
            }
        ],
        "- `Multicall`: annotate `multicall` function as upgrade safe to not raise a flag for its delegatecall. ([#3961](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3961))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3961": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- `ERC20Pausable`, `ERC721Pausable`, `ERC1155Pausable`: Add note regarding missing public pausing functionality ([#4007](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4007))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4007": {
                    "add": [
                        " * IMPORTANT: This contract does not include public pause and unpause functions. In",
                        " * addition to inheriting this contract, you must define both functions, invoking the",
                        " * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate",
                        " * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will",
                        " * make the contract unpausable.",
                        " *",
                        " *",
                        " * IMPORTANT: This contract does not include public pause and unpause functions. In",
                        " * addition to inheriting this contract, you must define both functions, invoking the",
                        " * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate",
                        " * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will",
                        " * make the contract unpausable.",
                        " *",
                        " * IMPORTANT: This contract does not include public pause and unpause functions. In",
                        " * addition to inheriting this contract, you must define both functions, invoking the",
                        " * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate",
                        " * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will",
                        " * make the contract unpausable."
                    ],
                    "del": []
                }
            }
        ],
        "- `EIP712`: Addition of ERC5267 support requires support for user defined value types, which was released in Solidity version 0.8.8. This requires a pragma change from `^0.8.0` to `^0.8.8`.": [],
        "- `EIP712`: Optimization of the cache for the upgradeable version affects the way `name` and `version` are set. This is no longer done through an initializer, and is instead part of the implementation's constructor. As a consequence, all proxies using the same implementation will necessarily share the same `name` and `version`. Additionally, an implementation upgrade risks changing the EIP712 domain unless the same `name` and `version` are used when deploying the new implementation contract.": [],
        "- `ERC777`: The `ERC777` token standard is no longer supported by OpenZeppelin. Our implementation is now deprecated and will be removed in the next major release. The corresponding standard interfaces remain available. ([#4066](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4066))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4066": {
                    "add": [
                        " *",
                        " * CAUTION: This file is deprecated as of v4.9 and will be removed in the next major release.",
                        " *",
                        " * CAUTION: This file is deprecated as of v4.9 and will be removed in the next major release."
                    ],
                    "del": []
                }
            }
        ],
        "- `ERC1820Implementer`: The `ERC1820` pseudo-introspection mechanism is no longer supported by OpenZeppelin. Our implementation is now deprecated and will be removed in the next major release. The corresponding standard interfaces remain available. ([#4066](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4066))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4066": {
                    "add": [
                        " *",
                        " * CAUTION: This file is deprecated as of v4.9 and will be removed in the next major release.",
                        " *",
                        " * CAUTION: This file is deprecated as of v4.9 and will be removed in the next major release."
                    ],
                    "del": []
                }
            }
        ]
    },
    "4.9.0-rc.1": {
        "- `AccessControlDefaultAdminRules`: Clean up pending admin schedule on renounce. ([#4243](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4243))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4243": {
                    "add": [],
                    "del": []
                }
            }
        ]
    },
    "4.9.0-rc.0": {
        "- `ERC721Wrapper`: add a new extension of the `ERC721` token which wraps an underlying token. Deposit and withdraw guarantee that the ownership of each token is backed by a corresponding underlying token with the same identifier. ([#3863](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3863))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3863": {
                    "add": [
                        "/**",
                        " * @dev Extension of the ERC721 token contract to support token wrapping.",
                        " *",
                        " * Users can deposit and withdraw an \"underlying token\" and receive a \"wrapped token\" with a matching tokenId. This is useful",
                        " * in conjunction with other modules. For example, combining this wrapping mechanism with {ERC721Votes} will allow the",
                        " * wrapping of an existing \"basic\" ERC721 into a governance token.",
                        " *",
                        " * _Available since v4.9.0_",
                        " */",
                        "abstract contract ERC721Wrapper is ERC721, ERC721Holder {",
                        "    IERC721 private immutable _underlying;",
                        "    bytes12 public constant WRAPPER_ACCEPT_MAGIC = bytes12(keccak256(\"WRAPPER_ACCEPT_MAGIC\"));",
                        "    constructor(IERC721 underlyingToken) {",
                        "        _underlying = underlyingToken;",
                        "    }",
                        "    /**",
                        "     * @dev Allow a user to deposit underlying tokens and mint the corresponding tokenIds.",
                        "     */",
                        "    function depositFor(address account, uint256[] memory tokenIds) public virtual returns (bool) {",
                        "        bytes memory data = abi.encodePacked(WRAPPER_ACCEPT_MAGIC, account);",
                        "        uint256 length = tokenIds.length;",
                        "        for (uint256 i = 0; i < length; ++i) {",
                        "            underlying().safeTransferFrom(_msgSender(), address(this), tokenIds[i], data);",
                        "        }",
                        "        return true;",
                        "    }",
                        "    /**",
                        "     * @dev Allow a user to burn wrapped tokens and withdraw the corresponding tokenIds of the underlying tokens.",
                        "     */",
                        "    function withdrawTo(address account, uint256[] memory tokenIds) public virtual returns (bool) {",
                        "        uint256 length = tokenIds.length;",
                        "        for (uint256 i = 0; i < length; ++i) {",
                        "            uint256 tokenId = tokenIds[i];",
                        "            require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721Wrapper: caller is not token owner or approved\");",
                        "            _burn(tokenId);",
                        "            underlying().safeTransferFrom(address(this), account, tokenId);",
                        "        }",
                        "        return true;",
                        "    }",
                        "    /**",
                        "     * @dev Overrides {IERC721Receiver-onERC721Received} to allow minting on direct ERC721 transfers to",
                        "     * this contract.",
                        "     *",
                        "     * In case there's data attached, it validates that the sender is aware of this contract's existence and behavior",
                        "     * by checking a magic value (`WRAPPER_ACCEPT_MAGIC`) in the first 12 bytes. If it also matches, the rest 20",
                        "     * bytes are used as an address to send the tokens to.",
                        "     *",
                        "     * WARNING: Doesn't work with unsafe transfers (eg. {IERC721-transferFrom}). Use {ERC721Wrapper-_recover}",
                        "     * for recovering in that scenario.",
                        "     */",
                        "    function onERC721Received(",
                        "        address,",
                        "        address from,",
                        "        uint256 tokenId,",
                        "        bytes memory data",
                        "    ) public override returns (bytes4) {",
                        "        require(address(underlying()) == _msgSender(), \"ERC721Wrapper: caller is not underlying\");",
                        "        if (data.length > 0) {",
                        "            require(data.length == 32 && WRAPPER_ACCEPT_MAGIC == bytes12(data), \"ERC721Wrapper: Invalid data format\");",
                        "            from = address(bytes20(bytes32(data) << 96));",
                        "        }",
                        "        _safeMint(from, tokenId);",
                        "        return IERC721Receiver.onERC721Received.selector;",
                        "    }",
                        "    /**",
                        "     * @dev Mint a wrapped token to cover any underlyingToken that would have been transferred by mistake. Internal",
                        "     * function that can be exposed with access control if desired.",
                        "     */",
                        "    function _recover(address account, uint256 tokenId) internal virtual returns (uint256) {",
                        "        require(underlying().ownerOf(tokenId) == address(this), \"ERC721Wrapper: wrapper is not token owner\");",
                        "        _safeMint(account, tokenId);",
                        "        return tokenId;",
                        "    }",
                        "    /**",
                        "     * @dev Returns the underlying token.",
                        "     */",
                        "    function underlying() public view virtual returns (IERC721) {",
                        "        return _underlying;",
                        "    }",
                        "}"
                    ],
                    "del": []
                }
            }
        ],
        "- `Governor`: Enable timestamp operation for blockchains without a stable block time. This is achieved by connecting a Governor's internal clock to match a voting token's EIP-6372 interface. ([#3934](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3934))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3934": {
                    "add": [
                        "        uint64 voteStart;",
                        "        address proposer;",
                        "        bytes4 __gap_unused0;",
                        "        uint64 voteEnd;",
                        "        bytes24 __gap_unused1;",
                        "                type(IERC6372).interfaceId ^",
                        "            interfaceId == (type(IGovernor).interfaceId ^ type(IERC6372).interfaceId ^ this.cancel.selector) ||",
                        "        uint256 currentTimepoint = clock();",
                        "        if (snapshot >= currentTimepoint) {",
                        "        if (deadline >= currentTimepoint) {",
                        "    /**",
                        "     * @dev Part of the Governor Bravo's interface: _\"The number of votes required in order for a voter to become a proposer\"_.",
                        "     */",
                        "    function proposalThreshold() public view virtual returns (uint256) {",
                        "        return 0;",
                        "    }",
                        "        return _proposals[proposalId].voteStart;",
                        "        return _proposals[proposalId].voteEnd;",
                        "     * @dev Address of the proposer",
                        "    function _proposalProposer(uint256 proposalId) internal view virtual returns (address) {",
                        "        return _proposals[proposalId].proposer;",
                        "     * @dev Get the voting weight of `account` at a specific `timepoint`, for a vote as described by `params`.",
                        "    function _getVotes(address account, uint256 timepoint, bytes memory params) internal view virtual returns (uint256);",
                        "        uint256 currentTimepoint = clock();",
                        "            getVotes(proposer, currentTimepoint - 1) >= proposalThreshold(),",
                        "        require(_proposals[proposalId].proposer == address(0), \"Governor: proposal already exists\");",
                        "        uint256 snapshot = currentTimepoint + votingDelay();",
                        "        uint256 deadline = snapshot + votingPeriod();",
                        "        _proposals[proposalId] = ProposalCore({",
                        "            proposer: proposer,",
                        "            voteStart: snapshot.toUint64(),",
                        "            voteEnd: deadline.toUint64(),",
                        "            executed: false,",
                        "            canceled: false,",
                        "            __gap_unused0: 0,",
                        "            __gap_unused1: 0",
                        "        });",
                        "    function getVotes(address account, uint256 timepoint) public view virtual override returns (uint256) {",
                        "        return _getVotes(account, timepoint, _defaultParams());",
                        "        uint256 timepoint,",
                        "        return _getVotes(account, timepoint, params);",
                        "        uint256 weight = _getVotes(account, proposal.voteStart, params);",
                        "abstract contract IGovernor is IERC165, IERC6372 {",
                        "        uint256 voteStart,",
                        "        uint256 voteEnd,",
                        "    /**",
                        "     * @notice module:core",
                        "     * @dev See {IERC6372}",
                        "     */",
                        "    function clock() public view virtual override returns (uint48);",
                        "    /**",
                        "     * @notice module:core",
                        "     * @dev See EIP-6372.",
                        "     */",
                        "    function CLOCK_MODE() public view virtual override returns (string memory);",
                        "    function COUNTING_MODE() public view virtual returns (string memory);",
                        "     * @dev Timepoint used to retrieve user's votes and quorum. If using block number (as per Compound's Comp), the",
                        "     * snapshot is performed at the end of this block. Hence, voting for this proposal starts at the beginning of the",
                        "     * following block.",
                        "     * @dev Timepoint at which votes close. If using block number, votes close at the end of this block, so it is",
                        "     * possible to cast a vote during this block.",
                        "     * @dev Delay, between the proposal is created and the vote starts. The unit this duration is expressed in depends",
                        "     * on the clock (see EIP-6372) this contract uses.",
                        "     *",
                        "     * This can be increased to leave time for users to buy voting power, or delegate it, before the voting of a",
                        "     * proposal starts.",
                        "     * @dev Delay, between the vote start and vote ends. The unit this duration is expressed in depends on the clock",
                        "     * (see EIP-6372) this contract uses.",
                        "     * NOTE: The `timepoint` parameter corresponds to the snapshot used for counting vote. This allows to scale the",
                        "     * quorum depending on values such as the totalSupply of a token at this timepoint (see {ERC20Votes}).",
                        "    function quorum(uint256 timepoint) public view virtual returns (uint256);",
                        "     * @dev Voting power of an `account` at a specific `timepoint`.",
                        "    function getVotes(address account, uint256 timepoint) public view virtual returns (uint256);",
                        "     * @dev Voting power of an `account` at a specific `timepoint` given additional encoded parameters.",
                        "        uint256 timepoint,",
                        "     * @dev Create a new proposal. Vote start after a delay specified by {IGovernor-votingDelay} and lasts for a",
                        "     * duration specified by {IGovernor-votingPeriod}.",
                        "        address proposer = _proposalDetails[proposalId].proposer;",
                        "            _msgSender() == proposer || getVotes(proposer, clock() - 1) < proposalThreshold(),",
                        "        return quorum(clock() - 1);",
                        "    mapping(uint256 => uint64) private _extendedDeadlines;",
                        "        return Math.max(super.proposalDeadline(proposalId), _extendedDeadlines[proposalId]);",
                        "        if (_extendedDeadlines[proposalId] == 0 && _quorumReached(proposalId)) {",
                        "            uint64 extendedDeadline = clock() + lateQuorumVoteExtension();",
                        "            if (extendedDeadline > proposalDeadline(proposalId)) {",
                        "                emit ProposalExtended(proposalId, extendedDeadline);",
                        "            _extendedDeadlines[proposalId] = extendedDeadline;",
                        "    mapping(uint256 => uint64) private _proposalTimelocks;",
                        "        return _proposalTimelocks[proposalId];",
                        "        _proposalTimelocks[proposalId] = eta.toUint64();",
                        "            delete _proposalTimelocks[proposalId];",
                        "    IERC5805 public immutable token;",
                        "        token = IERC5805(address(tokenAddress));",
                        "    }",
                        "    /**",
                        "     * @dev Clock (as specified in EIP-6372) is set to match the token's clock. Fallback to block numbers if the token",
                        "     * does not implement EIP-6372.",
                        "     */",
                        "    function clock() public view virtual override returns (uint48) {",
                        "        try token.clock() returns (uint48 timepoint) {",
                        "            return timepoint;",
                        "        } catch {",
                        "            return SafeCast.toUint48(block.number);",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Machine-readable description of the clock as specified in EIP-6372.",
                        "     */",
                        "    function CLOCK_MODE() public view virtual override returns (string memory) {",
                        "        try token.CLOCK_MODE() returns (string memory clockmode) {",
                        "            return clockmode;",
                        "        } catch {",
                        "            return \"mode=blocknumber&from=default\";",
                        "        }",
                        "        uint256 timepoint,",
                        "        return token.getPastVotes(account, timepoint);",
                        "     * @dev Clock (as specified in EIP-6372) is set to match the token's clock. Fallback to block numbers if the token",
                        "     * does not implement EIP-6372.",
                        "     */",
                        "    function clock() public view virtual override returns (uint48) {",
                        "        try token.clock() returns (uint48 timepoint) {",
                        "            return timepoint;",
                        "        } catch {",
                        "            return SafeCast.toUint48(block.number);",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Machine-readable description of the clock as specified in EIP-6372.",
                        "     */",
                        "    function CLOCK_MODE() public view virtual override returns (string memory) {",
                        "        try token.CLOCK_MODE() returns (string memory clockmode) {",
                        "            return clockmode;",
                        "        } catch {",
                        "            return \"mode=blocknumber&from=default\";",
                        "        }",
                        "    }",
                        "    /**",
                        "     * Read the voting weight from the token's built-in snapshot mechanism (see {Governor-_getVotes}).",
                        "        uint256 timepoint,",
                        "        return token.getPriorVotes(account, timepoint);",
                        "    using SafeCast for *;",
                        "    using Checkpoints for Checkpoints.Trace224;",
                        "    Checkpoints.Trace224 private _quorumNumeratorHistory;",
                        "     * @dev Returns the quorum numerator at a specific timepoint. See {quorumDenominator}.",
                        "    function quorumNumerator(uint256 timepoint) public view virtual returns (uint256) {",
                        "        Checkpoints.Checkpoint224 memory latest = _quorumNumeratorHistory._checkpoints[length - 1];",
                        "        if (latest._key <= timepoint) {",
                        "        return _quorumNumeratorHistory.upperLookupRecent(timepoint.toUint32());",
                        "     * @dev Returns the quorum for a timepoint, in terms of number of votes: `supply * numerator / denominator`.",
                        "    function quorum(uint256 timepoint) public view virtual override returns (uint256) {",
                        "        return (token.getPastTotalSupply(timepoint) * quorumNumerator(timepoint)) / quorumDenominator();",
                        "                Checkpoints.Checkpoint224({_key: 0, _value: oldQuorumNumerator.toUint224()})",
                        "        _quorumNumeratorHistory.push(clock().toUint32(), newQuorumNumerator.toUint224());",
                        "     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is",
                        "     * configured to use block numbers, this will return the value the end of the corresponding block.",
                        "    function getPastVotes(address account, uint256 timepoint) external view returns (uint256);",
                        "     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is",
                        "     * configured to use block numbers, this will return the value the end of the corresponding block.",
                        "    function getPastTotalSupply(uint256 timepoint) external view returns (uint256);",
                        "abstract contract Votes is Context, EIP712, IERC5805 {",
                        "    using Checkpoints for Checkpoints.Trace224;",
                        "    mapping(address => Checkpoints.Trace224) private _delegateCheckpoints;",
                        "    Checkpoints.Trace224 private _totalCheckpoints;",
                        "    /**",
                        "     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based",
                        "     * checkpoints (and voting), in which case {CLOCK_MODE} should be overridden as well to match.",
                        "     */",
                        "    function clock() public view virtual override returns (uint48) {",
                        "        return SafeCast.toUint48(block.number);",
                        "    }",
                        "    /**",
                        "     * @dev Machine-readable description of the clock as specified in EIP-6372.",
                        "     */",
                        "    function CLOCK_MODE() public view virtual override returns (string memory) {",
                        "        require(clock() == block.number);",
                        "        return \"mode=blocknumber&from=default\";",
                        "    }",
                        "     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is",
                        "     * configured to use block numbers, this will return the value the end of the corresponding block.",
                        "     * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.",
                        "    function getPastVotes(address account, uint256 timepoint) public view virtual override returns (uint256) {",
                        "        require(timepoint < clock(), \"Votes: future lookup\");",
                        "        return _delegateCheckpoints[account].upperLookupRecent(SafeCast.toUint32(timepoint));",
                        "     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is",
                        "     * configured to use block numbers, this will return the value the end of the corresponding block.",
                        "     * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.",
                        "    function getPastTotalSupply(uint256 timepoint) public view virtual override returns (uint256) {",
                        "        require(timepoint < clock(), \"Votes: future lookup\");",
                        "        return _totalCheckpoints.upperLookupRecent(SafeCast.toUint32(timepoint));",
                        "            _push(_totalCheckpoints, _add, SafeCast.toUint224(amount));",
                        "            _push(_totalCheckpoints, _subtract, SafeCast.toUint224(amount));",
                        "                (uint256 oldValue, uint256 newValue) = _push(",
                        "                    _delegateCheckpoints[from],",
                        "                    _subtract,",
                        "                    SafeCast.toUint224(amount)",
                        "                );",
                        "                (uint256 oldValue, uint256 newValue) = _push(",
                        "                    _delegateCheckpoints[to],",
                        "                    _add,",
                        "                    SafeCast.toUint224(amount)",
                        "                );",
                        "    function _push(",
                        "        Checkpoints.Trace224 storage store,",
                        "        function(uint224, uint224) view returns (uint224) op,",
                        "        uint224 delta",
                        "    ) private returns (uint224, uint224) {",
                        "        return store.push(SafeCast.toUint32(clock()), op(store.latest(), delta));",
                        "    }",
                        "    function _add(uint224 a, uint224 b) private pure returns (uint224) {",
                        "    function _subtract(uint224 a, uint224 b) private pure returns (uint224) {",
                        "interface IERC5805 is IERC6372, IVotes {}",
                        "interface IERC6372 {",
                        "    /**",
                        "     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).",
                        "     */",
                        "    function clock() external view returns (uint48);",
                        "    /**",
                        "     * @dev Description of the clock",
                        "     */",
                        "    function CLOCK_MODE() external view returns (string memory);",
                        "}",
                        "abstract contract VotesTimestampMock is VotesMock {",
                        "    function clock() public view override returns (uint48) {",
                        "        return uint48(block.timestamp);",
                        "    }",
                        "    function CLOCK_MODE() public view virtual override returns (string memory) {",
                        "        return \"mode=timestamp\";",
                        "    }",
                        "}",
                        "/**",
                        " * @dev Copied from the master branch at commit 86de1e8b6c3fa6b4efa4a5435869d2521be0f5f5",
                        " */",
                        "abstract contract ERC20VotesLegacyMock is IVotes, ERC20Permit {",
                        "    struct Checkpoint {",
                        "        uint32 fromBlock;",
                        "        uint224 votes;",
                        "    }",
                        "    bytes32 private constant _DELEGATION_TYPEHASH =",
                        "        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");",
                        "    mapping(address => address) private _delegates;",
                        "    mapping(address => Checkpoint[]) private _checkpoints;",
                        "    Checkpoint[] private _totalSupplyCheckpoints;",
                        "    /**",
                        "     * @dev Get the `pos`-th checkpoint for `account`.",
                        "     */",
                        "    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {",
                        "        return _checkpoints[account][pos];",
                        "    }",
                        "    /**",
                        "     * @dev Get number of checkpoints for `account`.",
                        "     */",
                        "    function numCheckpoints(address account) public view virtual returns (uint32) {",
                        "        return SafeCast.toUint32(_checkpoints[account].length);",
                        "    }",
                        "    /**",
                        "     * @dev Get the address `account` is currently delegating to.",
                        "     */",
                        "    function delegates(address account) public view virtual override returns (address) {",
                        "        return _delegates[account];",
                        "    }",
                        "    /**",
                        "     * @dev Gets the current votes balance for `account`",
                        "     */",
                        "    function getVotes(address account) public view virtual override returns (uint256) {",
                        "        uint256 pos = _checkpoints[account].length;",
                        "        unchecked {",
                        "            return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `blockNumber` must have been already mined",
                        "     */",
                        "    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");",
                        "        return _checkpointsLookup(_checkpoints[account], blockNumber);",
                        "    }",
                        "    /**",
                        "     * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.",
                        "     * It is NOT the sum of all the delegated votes!",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `blockNumber` must have been already mined",
                        "     */",
                        "    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");",
                        "        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);",
                        "    }",
                        "    /**",
                        "     * @dev Lookup a value in a list of (sorted) checkpoints.",
                        "     */",
                        "    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {",
                        "        //",
                        "        uint256 length = ckpts.length;",
                        "        uint256 low = 0;",
                        "        uint256 high = length;",
                        "        if (length > 5) {",
                        "            uint256 mid = length - Math.sqrt(length);",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > blockNumber) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }",
                        "        }",
                        "        while (low < high) {",
                        "            uint256 mid = Math.average(low, high);",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > blockNumber) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }",
                        "        }",
                        "        unchecked {",
                        "            return high == 0 ? 0 : _unsafeAccess(ckpts, high - 1).votes;",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Delegate votes from the sender to `delegatee`.",
                        "     */",
                        "    function delegate(address delegatee) public virtual override {",
                        "        _delegate(_msgSender(), delegatee);",
                        "    }",
                        "    /**",
                        "     * @dev Delegates votes from signer to `delegatee`",
                        "     */",
                        "    function delegateBySig(",
                        "        address delegatee,",
                        "        uint256 nonce,",
                        "        uint256 expiry,",
                        "        uint8 v,",
                        "        bytes32 r,",
                        "        bytes32 s",
                        "    ) public virtual override {",
                        "        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");",
                        "        address signer = ECDSA.recover(",
                        "            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),",
                        "            v,",
                        "            r,",
                        "            s",
                        "        );",
                        "        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");",
                        "        _delegate(signer, delegatee);",
                        "    }",
                        "    /**",
                        "     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).",
                        "     */",
                        "    function _maxSupply() internal view virtual returns (uint224) {",
                        "        return type(uint224).max;",
                        "    }",
                        "    /**",
                        "     * @dev Snapshots the totalSupply after it has been increased.",
                        "     */",
                        "    function _mint(address account, uint256 amount) internal virtual override {",
                        "        super._mint(account, amount);",
                        "        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");",
                        "        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);",
                        "    }",
                        "    /**",
                        "     * @dev Snapshots the totalSupply after it has been decreased.",
                        "     */",
                        "    function _burn(address account, uint256 amount) internal virtual override {",
                        "        super._burn(account, amount);",
                        "        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);",
                        "    }",
                        "    /**",
                        "     * @dev Move voting power when tokens are transferred.",
                        "     *",
                        "     * Emits a {IVotes-DelegateVotesChanged} event.",
                        "     */",
                        "    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual override {",
                        "        super._afterTokenTransfer(from, to, amount);",
                        "        _moveVotingPower(delegates(from), delegates(to), amount);",
                        "    }",
                        "    /**",
                        "     * @dev Change delegation for `delegator` to `delegatee`.",
                        "     *",
                        "     * Emits events {IVotes-DelegateChanged} and {IVotes-DelegateVotesChanged}.",
                        "     */",
                        "    function _delegate(address delegator, address delegatee) internal virtual {",
                        "        address currentDelegate = delegates(delegator);",
                        "        uint256 delegatorBalance = balanceOf(delegator);",
                        "        _delegates[delegator] = delegatee;",
                        "        emit DelegateChanged(delegator, currentDelegate, delegatee);",
                        "        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);",
                        "    }",
                        "    function _moveVotingPower(address src, address dst, uint256 amount) private {",
                        "        if (src != dst && amount > 0) {",
                        "            if (src != address(0)) {",
                        "                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);",
                        "                emit DelegateVotesChanged(src, oldWeight, newWeight);",
                        "            }",
                        "            if (dst != address(0)) {",
                        "                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);",
                        "                emit DelegateVotesChanged(dst, oldWeight, newWeight);",
                        "            }",
                        "        }",
                        "    }",
                        "    function _writeCheckpoint(",
                        "        Checkpoint[] storage ckpts,",
                        "        function(uint256, uint256) view returns (uint256) op,",
                        "        uint256 delta",
                        "    ) private returns (uint256 oldWeight, uint256 newWeight) {",
                        "        uint256 pos = ckpts.length;",
                        "        unchecked {",
                        "            Checkpoint memory oldCkpt = pos == 0 ? Checkpoint(0, 0) : _unsafeAccess(ckpts, pos - 1);",
                        "            oldWeight = oldCkpt.votes;",
                        "            newWeight = op(oldWeight, delta);",
                        "            if (pos > 0 && oldCkpt.fromBlock == block.number) {",
                        "                _unsafeAccess(ckpts, pos - 1).votes = SafeCast.toUint224(newWeight);",
                        "            } else {",
                        "                ckpts.push(",
                        "                    Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)})",
                        "                );",
                        "            }",
                        "        }",
                        "    }",
                        "    function _add(uint256 a, uint256 b) private pure returns (uint256) {",
                        "        return a + b;",
                        "    }",
                        "    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {",
                        "        return a - b;",
                        "    }",
                        "    /**",
                        "     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.",
                        "     */",
                        "    function _unsafeAccess(Checkpoint[] storage ckpts, uint256 pos) private pure returns (Checkpoint storage result) {",
                        "        assembly {",
                        "            mstore(0, ckpts.slot)",
                        "            result.slot := add(keccak256(0, 0x20), pos)",
                        "        }",
                        "    }",
                        "}",
                        "abstract contract ERC20VotesTimestampMock is ERC20Votes {",
                        "    function clock() public view virtual override returns (uint48) {",
                        "        return SafeCast.toUint48(block.timestamp);",
                        "    }",
                        "    function CLOCK_MODE() public view virtual override returns (string memory) {",
                        "        return \"mode=timestamp\";",
                        "    }",
                        "}",
                        "abstract contract ERC20VotesCompTimestampMock is ERC20VotesComp {",
                        "    function clock() public view virtual override returns (uint48) {",
                        "        return SafeCast.toUint48(block.timestamp);",
                        "    }",
                        "    function CLOCK_MODE() public view virtual override returns (string memory) {",
                        "        return \"mode=timestamp\";",
                        "    }",
                        "}",
                        "abstract contract ERC721VotesTimestampMock is ERC721Votes {",
                        "    function clock() public view virtual override returns (uint48) {",
                        "        return SafeCast.toUint48(block.timestamp);",
                        "    }",
                        "    function CLOCK_MODE() public view virtual override returns (string memory) {",
                        "        return \"mode=timestamp\";",
                        "    }",
                        "}",
                        "abstract contract ERC20Votes is ERC20Permit, IERC5805 {",
                        "    /**",
                        "     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).",
                        "     */",
                        "    function clock() public view virtual override returns (uint48) {",
                        "        return SafeCast.toUint48(block.number);",
                        "    }",
                        "    /**",
                        "     * @dev Description of the clock",
                        "     */",
                        "    function CLOCK_MODE() public view virtual override returns (string memory) {",
                        "        require(clock() == block.number);",
                        "        return \"mode=blocknumber&from=default\";",
                        "    }",
                        "     * @dev Retrieve the number of votes for `account` at the end of `timepoint`.",
                        "     * - `timepoint` must be in the past",
                        "    function getPastVotes(address account, uint256 timepoint) public view virtual override returns (uint256) {",
                        "        require(timepoint < clock(), \"ERC20Votes: future lookup\");",
                        "        return _checkpointsLookup(_checkpoints[account], timepoint);",
                        "     * @dev Retrieve the `totalSupply` at the end of `timepoint`. Note, this value is the sum of all balances.",
                        "     * - `timepoint` must be in the past",
                        "    function getPastTotalSupply(uint256 timepoint) public view virtual override returns (uint256) {",
                        "        require(timepoint < clock(), \"ERC20Votes: future lookup\");",
                        "        return _checkpointsLookup(_totalSupplyCheckpoints, timepoint);",
                        "    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 timepoint) private view returns (uint256) {",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > timepoint) {",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > timepoint) {",
                        "            if (pos > 0 && oldCkpt.fromBlock == clock()) {",
                        "                ckpts.push(Checkpoint({fromBlock: SafeCast.toUint32(clock()), votes: SafeCast.toUint224(newWeight)}));",
                        "    /**",
                        "     * @dev Returns the value in the most recent checkpoint with key lower or equal than the search key.",
                        "     *",
                        "     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high keys).",
                        "     */",
                        "    function upperLookupRecent(Trace224 storage self, uint32 key) internal view returns (uint224) {",
                        "        uint256 len = self._checkpoints.length;",
                        "        uint256 low = 0;",
                        "        uint256 high = len;",
                        "        if (len > 5) {",
                        "            uint256 mid = len - Math.sqrt(len);",
                        "            if (key < _unsafeAccess(self._checkpoints, mid)._key) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }",
                        "        }",
                        "        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);",
                        "        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
                        "    }",
                        "    /**",
                        "     * @dev Returns the value in the most recent checkpoint with key lower or equal than the search key.",
                        "     *",
                        "     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high keys).",
                        "     */",
                        "    function upperLookupRecent(Trace160 storage self, uint96 key) internal view returns (uint160) {",
                        "        uint256 len = self._checkpoints.length;",
                        "        uint256 low = 0;",
                        "        uint256 high = len;",
                        "        if (len > 5) {",
                        "            uint256 mid = len - Math.sqrt(len);",
                        "            if (key < _unsafeAccess(self._checkpoints, mid)._key) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }",
                        "        }",
                        "        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);",
                        "        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
                        "    }"
                    ],
                    "del": [
                        "    using Timers for Timers.BlockNumber;",
                        "        Timers.BlockNumber voteStart;",
                        "        Timers.BlockNumber voteEnd;",
                        "        address proposer;",
                        "            interfaceId == (type(IGovernor).interfaceId ^ this.cancel.selector) ||",
                        "            interfaceId == type(IGovernor).interfaceId ||",
                        "        if (snapshot >= block.number) {",
                        "        if (deadline >= block.number) {",
                        "        return _proposals[proposalId].voteStart.getDeadline();",
                        "        return _proposals[proposalId].voteEnd.getDeadline();",
                        "     * @dev Part of the Governor Bravo's interface: _\"The number of votes required in order for a voter to become a proposer\"_.",
                        "    function proposalThreshold() public view virtual returns (uint256) {",
                        "        return 0;",
                        "     * @dev Get the voting weight of `account` at a specific `blockNumber`, for a vote as described by `params`.",
                        "    function _getVotes(",
                        "        address account,",
                        "        uint256 blockNumber,",
                        "        bytes memory params",
                        "    ) internal view virtual returns (uint256);",
                        "            getVotes(proposer, block.number - 1) >= proposalThreshold(),",
                        "        ProposalCore storage proposal = _proposals[proposalId];",
                        "        require(proposal.voteStart.isUnset(), \"Governor: proposal already exists\");",
                        "        uint64 snapshot = block.number.toUint64() + votingDelay().toUint64();",
                        "        uint64 deadline = snapshot + votingPeriod().toUint64();",
                        "        proposal.voteStart.setDeadline(snapshot);",
                        "        proposal.voteEnd.setDeadline(deadline);",
                        "        proposal.proposer = proposer;",
                        "    function getVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        return _getVotes(account, blockNumber, _defaultParams());",
                        "        uint256 blockNumber,",
                        "        return _getVotes(account, blockNumber, params);",
                        "        uint256 weight = _getVotes(account, proposal.voteStart.getDeadline(), params);",
                        "abstract contract IGovernor is IERC165 {",
                        "        uint256 startBlock,",
                        "        uint256 endBlock,",
                        "    function COUNTING_MODE() public pure virtual returns (string memory);",
                        "     * @dev Block number used to retrieve user's votes and quorum. As per Compound's Comp and OpenZeppelin's",
                        "     * ERC20Votes, the snapshot is performed at the end of this block. Hence, voting for this proposal starts at the",
                        "     * beginning of the following block.",
                        "     * @dev Block number at which votes close. Votes close at the end of this block, so it is possible to cast a vote",
                        "     * during this block.",
                        "     * @dev Delay, in number of block, between the proposal is created and the vote starts. This can be increased to",
                        "     * leave time for users to buy voting power, or delegate it, before the voting of a proposal starts.",
                        "     * @dev Delay, in number of blocks, between the vote start and vote ends.",
                        "     * Note: The `blockNumber` parameter corresponds to the snapshot used for counting vote. This allows to scale the",
                        "     * quorum depending on values such as the totalSupply of a token at this block (see {ERC20Votes}).",
                        "    function quorum(uint256 blockNumber) public view virtual returns (uint256);",
                        "     * @dev Voting power of an `account` at a specific `blockNumber`.",
                        "    function getVotes(address account, uint256 blockNumber) public view virtual returns (uint256);",
                        "     * @dev Voting power of an `account` at a specific `blockNumber` given additional encoded parameters.",
                        "        uint256 blockNumber,",
                        "     * @dev Create a new proposal. Vote start {IGovernor-votingDelay} blocks after the proposal is created and ends",
                        "     * {IGovernor-votingPeriod} blocks after the voting starts.",
                        "        ProposalDetails storage details = _proposalDetails[proposalId];",
                        "            _msgSender() == details.proposer || getVotes(details.proposer, block.number - 1) < proposalThreshold(),",
                        "        return quorum(block.number - 1);",
                        "    using Timers for Timers.BlockNumber;",
                        "    mapping(uint256 => Timers.BlockNumber) private _extendedDeadlines;",
                        "        return Math.max(super.proposalDeadline(proposalId), _extendedDeadlines[proposalId].getDeadline());",
                        "        Timers.BlockNumber storage extendedDeadline = _extendedDeadlines[proposalId];",
                        "        if (extendedDeadline.isUnset() && _quorumReached(proposalId)) {",
                        "            uint64 extendedDeadlineValue = block.number.toUint64() + lateQuorumVoteExtension();",
                        "            if (extendedDeadlineValue > proposalDeadline(proposalId)) {",
                        "                emit ProposalExtended(proposalId, extendedDeadlineValue);",
                        "            extendedDeadline.setDeadline(extendedDeadlineValue);",
                        "    using Timers for Timers.Timestamp;",
                        "    struct ProposalTimelock {",
                        "        Timers.Timestamp timer;",
                        "    }",
                        "    mapping(uint256 => ProposalTimelock) private _proposalTimelocks;",
                        "        return _proposalTimelocks[proposalId].timer.getDeadline();",
                        "        _proposalTimelocks[proposalId].timer.setDeadline(eta.toUint64());",
                        "            _proposalTimelocks[proposalId].timer.reset();",
                        "    IVotes public immutable token;",
                        "        token = tokenAddress;",
                        "        uint256 blockNumber,",
                        "        return token.getPastVotes(account, blockNumber);",
                        "     * Read the voting weight from the token's built in snapshot mechanism (see {Governor-_getVotes}).",
                        "        uint256 blockNumber,",
                        "        return token.getPriorVotes(account, blockNumber);",
                        "    using Checkpoints for Checkpoints.History;",
                        "    Checkpoints.History private _quorumNumeratorHistory;",
                        "     * @dev Returns the quorum numerator at a specific block number. See {quorumDenominator}.",
                        "    function quorumNumerator(uint256 blockNumber) public view virtual returns (uint256) {",
                        "        Checkpoints.Checkpoint memory latest = _quorumNumeratorHistory._checkpoints[length - 1];",
                        "        if (latest._blockNumber <= blockNumber) {",
                        "        return _quorumNumeratorHistory.getAtBlock(blockNumber);",
                        "     * @dev Returns the quorum for a block number, in terms of number of votes: `supply * numerator / denominator`.",
                        "    function quorum(uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        return (token.getPastTotalSupply(blockNumber) * quorumNumerator(blockNumber)) / quorumDenominator();",
                        "                Checkpoints.Checkpoint({_blockNumber: 0, _value: SafeCast.toUint224(oldQuorumNumerator)})",
                        "        _quorumNumeratorHistory.push(newQuorumNumerator);",
                        "     * @dev Returns the amount of votes that `account` had at the end of a past block (`blockNumber`).",
                        "    function getPastVotes(address account, uint256 blockNumber) external view returns (uint256);",
                        "     * @dev Returns the total supply of votes available at the end of a past block (`blockNumber`).",
                        "    function getPastTotalSupply(uint256 blockNumber) external view returns (uint256);",
                        "abstract contract Votes is IVotes, Context, EIP712 {",
                        "    using Checkpoints for Checkpoints.History;",
                        "    mapping(address => Checkpoints.History) private _delegateCheckpoints;",
                        "    Checkpoints.History private _totalCheckpoints;",
                        "     * @dev Returns the amount of votes that `account` had at the end of a past block (`blockNumber`).",
                        "     * - `blockNumber` must have been already mined",
                        "    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        return _delegateCheckpoints[account].getAtProbablyRecentBlock(blockNumber);",
                        "     * @dev Returns the total supply of votes available at the end of a past block (`blockNumber`).",
                        "     * - `blockNumber` must have been already mined",
                        "    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        require(blockNumber < block.number, \"Votes: block not yet mined\");",
                        "        return _totalCheckpoints.getAtProbablyRecentBlock(blockNumber);",
                        "            _totalCheckpoints.push(_add, amount);",
                        "            _totalCheckpoints.push(_subtract, amount);",
                        "                (uint256 oldValue, uint256 newValue) = _delegateCheckpoints[from].push(_subtract, amount);",
                        "                (uint256 oldValue, uint256 newValue) = _delegateCheckpoints[to].push(_add, amount);",
                        "    function _add(uint256 a, uint256 b) private pure returns (uint256) {",
                        "    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {",
                        "abstract contract ERC20Votes is IVotes, ERC20Permit {",
                        "     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.",
                        "     * - `blockNumber` must have been already mined",
                        "    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");",
                        "        return _checkpointsLookup(_checkpoints[account], blockNumber);",
                        "     * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.",
                        "     * - `blockNumber` must have been already mined",
                        "    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");",
                        "        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);",
                        "    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > blockNumber) {",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > blockNumber) {",
                        "            if (pos > 0 && oldCkpt.fromBlock == block.number) {",
                        "                ckpts.push(",
                        "                    Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)})",
                        "                );"
                    ]
                }
            }
        ],
        "- `Votes`, `ERC20Votes`, `ERC721Votes`: support timestamp checkpointing using EIP-6372. ([#3934](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3934))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3934": {
                    "add": [
                        "        uint64 voteStart;",
                        "        address proposer;",
                        "        bytes4 __gap_unused0;",
                        "        uint64 voteEnd;",
                        "        bytes24 __gap_unused1;",
                        "                type(IERC6372).interfaceId ^",
                        "            interfaceId == (type(IGovernor).interfaceId ^ type(IERC6372).interfaceId ^ this.cancel.selector) ||",
                        "        uint256 currentTimepoint = clock();",
                        "        if (snapshot >= currentTimepoint) {",
                        "        if (deadline >= currentTimepoint) {",
                        "    /**",
                        "     * @dev Part of the Governor Bravo's interface: _\"The number of votes required in order for a voter to become a proposer\"_.",
                        "     */",
                        "    function proposalThreshold() public view virtual returns (uint256) {",
                        "        return 0;",
                        "    }",
                        "        return _proposals[proposalId].voteStart;",
                        "        return _proposals[proposalId].voteEnd;",
                        "     * @dev Address of the proposer",
                        "    function _proposalProposer(uint256 proposalId) internal view virtual returns (address) {",
                        "        return _proposals[proposalId].proposer;",
                        "     * @dev Get the voting weight of `account` at a specific `timepoint`, for a vote as described by `params`.",
                        "    function _getVotes(address account, uint256 timepoint, bytes memory params) internal view virtual returns (uint256);",
                        "        uint256 currentTimepoint = clock();",
                        "            getVotes(proposer, currentTimepoint - 1) >= proposalThreshold(),",
                        "        require(_proposals[proposalId].proposer == address(0), \"Governor: proposal already exists\");",
                        "        uint256 snapshot = currentTimepoint + votingDelay();",
                        "        uint256 deadline = snapshot + votingPeriod();",
                        "        _proposals[proposalId] = ProposalCore({",
                        "            proposer: proposer,",
                        "            voteStart: snapshot.toUint64(),",
                        "            voteEnd: deadline.toUint64(),",
                        "            executed: false,",
                        "            canceled: false,",
                        "            __gap_unused0: 0,",
                        "            __gap_unused1: 0",
                        "        });",
                        "    function getVotes(address account, uint256 timepoint) public view virtual override returns (uint256) {",
                        "        return _getVotes(account, timepoint, _defaultParams());",
                        "        uint256 timepoint,",
                        "        return _getVotes(account, timepoint, params);",
                        "        uint256 weight = _getVotes(account, proposal.voteStart, params);",
                        "abstract contract IGovernor is IERC165, IERC6372 {",
                        "        uint256 voteStart,",
                        "        uint256 voteEnd,",
                        "    /**",
                        "     * @notice module:core",
                        "     * @dev See {IERC6372}",
                        "     */",
                        "    function clock() public view virtual override returns (uint48);",
                        "    /**",
                        "     * @notice module:core",
                        "     * @dev See EIP-6372.",
                        "     */",
                        "    function CLOCK_MODE() public view virtual override returns (string memory);",
                        "    function COUNTING_MODE() public view virtual returns (string memory);",
                        "     * @dev Timepoint used to retrieve user's votes and quorum. If using block number (as per Compound's Comp), the",
                        "     * snapshot is performed at the end of this block. Hence, voting for this proposal starts at the beginning of the",
                        "     * following block.",
                        "     * @dev Timepoint at which votes close. If using block number, votes close at the end of this block, so it is",
                        "     * possible to cast a vote during this block.",
                        "     * @dev Delay, between the proposal is created and the vote starts. The unit this duration is expressed in depends",
                        "     * on the clock (see EIP-6372) this contract uses.",
                        "     *",
                        "     * This can be increased to leave time for users to buy voting power, or delegate it, before the voting of a",
                        "     * proposal starts.",
                        "     * @dev Delay, between the vote start and vote ends. The unit this duration is expressed in depends on the clock",
                        "     * (see EIP-6372) this contract uses.",
                        "     * NOTE: The `timepoint` parameter corresponds to the snapshot used for counting vote. This allows to scale the",
                        "     * quorum depending on values such as the totalSupply of a token at this timepoint (see {ERC20Votes}).",
                        "    function quorum(uint256 timepoint) public view virtual returns (uint256);",
                        "     * @dev Voting power of an `account` at a specific `timepoint`.",
                        "    function getVotes(address account, uint256 timepoint) public view virtual returns (uint256);",
                        "     * @dev Voting power of an `account` at a specific `timepoint` given additional encoded parameters.",
                        "        uint256 timepoint,",
                        "     * @dev Create a new proposal. Vote start after a delay specified by {IGovernor-votingDelay} and lasts for a",
                        "     * duration specified by {IGovernor-votingPeriod}.",
                        "        address proposer = _proposalDetails[proposalId].proposer;",
                        "            _msgSender() == proposer || getVotes(proposer, clock() - 1) < proposalThreshold(),",
                        "        return quorum(clock() - 1);",
                        "    mapping(uint256 => uint64) private _extendedDeadlines;",
                        "        return Math.max(super.proposalDeadline(proposalId), _extendedDeadlines[proposalId]);",
                        "        if (_extendedDeadlines[proposalId] == 0 && _quorumReached(proposalId)) {",
                        "            uint64 extendedDeadline = clock() + lateQuorumVoteExtension();",
                        "            if (extendedDeadline > proposalDeadline(proposalId)) {",
                        "                emit ProposalExtended(proposalId, extendedDeadline);",
                        "            _extendedDeadlines[proposalId] = extendedDeadline;",
                        "    mapping(uint256 => uint64) private _proposalTimelocks;",
                        "        return _proposalTimelocks[proposalId];",
                        "        _proposalTimelocks[proposalId] = eta.toUint64();",
                        "            delete _proposalTimelocks[proposalId];",
                        "    IERC5805 public immutable token;",
                        "        token = IERC5805(address(tokenAddress));",
                        "    }",
                        "    /**",
                        "     * @dev Clock (as specified in EIP-6372) is set to match the token's clock. Fallback to block numbers if the token",
                        "     * does not implement EIP-6372.",
                        "     */",
                        "    function clock() public view virtual override returns (uint48) {",
                        "        try token.clock() returns (uint48 timepoint) {",
                        "            return timepoint;",
                        "        } catch {",
                        "            return SafeCast.toUint48(block.number);",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Machine-readable description of the clock as specified in EIP-6372.",
                        "     */",
                        "    function CLOCK_MODE() public view virtual override returns (string memory) {",
                        "        try token.CLOCK_MODE() returns (string memory clockmode) {",
                        "            return clockmode;",
                        "        } catch {",
                        "            return \"mode=blocknumber&from=default\";",
                        "        }",
                        "        uint256 timepoint,",
                        "        return token.getPastVotes(account, timepoint);",
                        "     * @dev Clock (as specified in EIP-6372) is set to match the token's clock. Fallback to block numbers if the token",
                        "     * does not implement EIP-6372.",
                        "     */",
                        "    function clock() public view virtual override returns (uint48) {",
                        "        try token.clock() returns (uint48 timepoint) {",
                        "            return timepoint;",
                        "        } catch {",
                        "            return SafeCast.toUint48(block.number);",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Machine-readable description of the clock as specified in EIP-6372.",
                        "     */",
                        "    function CLOCK_MODE() public view virtual override returns (string memory) {",
                        "        try token.CLOCK_MODE() returns (string memory clockmode) {",
                        "            return clockmode;",
                        "        } catch {",
                        "            return \"mode=blocknumber&from=default\";",
                        "        }",
                        "    }",
                        "    /**",
                        "     * Read the voting weight from the token's built-in snapshot mechanism (see {Governor-_getVotes}).",
                        "        uint256 timepoint,",
                        "        return token.getPriorVotes(account, timepoint);",
                        "    using SafeCast for *;",
                        "    using Checkpoints for Checkpoints.Trace224;",
                        "    Checkpoints.Trace224 private _quorumNumeratorHistory;",
                        "     * @dev Returns the quorum numerator at a specific timepoint. See {quorumDenominator}.",
                        "    function quorumNumerator(uint256 timepoint) public view virtual returns (uint256) {",
                        "        Checkpoints.Checkpoint224 memory latest = _quorumNumeratorHistory._checkpoints[length - 1];",
                        "        if (latest._key <= timepoint) {",
                        "        return _quorumNumeratorHistory.upperLookupRecent(timepoint.toUint32());",
                        "     * @dev Returns the quorum for a timepoint, in terms of number of votes: `supply * numerator / denominator`.",
                        "    function quorum(uint256 timepoint) public view virtual override returns (uint256) {",
                        "        return (token.getPastTotalSupply(timepoint) * quorumNumerator(timepoint)) / quorumDenominator();",
                        "                Checkpoints.Checkpoint224({_key: 0, _value: oldQuorumNumerator.toUint224()})",
                        "        _quorumNumeratorHistory.push(clock().toUint32(), newQuorumNumerator.toUint224());",
                        "     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is",
                        "     * configured to use block numbers, this will return the value the end of the corresponding block.",
                        "    function getPastVotes(address account, uint256 timepoint) external view returns (uint256);",
                        "     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is",
                        "     * configured to use block numbers, this will return the value the end of the corresponding block.",
                        "    function getPastTotalSupply(uint256 timepoint) external view returns (uint256);",
                        "abstract contract Votes is Context, EIP712, IERC5805 {",
                        "    using Checkpoints for Checkpoints.Trace224;",
                        "    mapping(address => Checkpoints.Trace224) private _delegateCheckpoints;",
                        "    Checkpoints.Trace224 private _totalCheckpoints;",
                        "    /**",
                        "     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based",
                        "     * checkpoints (and voting), in which case {CLOCK_MODE} should be overridden as well to match.",
                        "     */",
                        "    function clock() public view virtual override returns (uint48) {",
                        "        return SafeCast.toUint48(block.number);",
                        "    }",
                        "    /**",
                        "     * @dev Machine-readable description of the clock as specified in EIP-6372.",
                        "     */",
                        "    function CLOCK_MODE() public view virtual override returns (string memory) {",
                        "        require(clock() == block.number);",
                        "        return \"mode=blocknumber&from=default\";",
                        "    }",
                        "     * @dev Returns the amount of votes that `account` had at a specific moment in the past. If the `clock()` is",
                        "     * configured to use block numbers, this will return the value the end of the corresponding block.",
                        "     * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.",
                        "    function getPastVotes(address account, uint256 timepoint) public view virtual override returns (uint256) {",
                        "        require(timepoint < clock(), \"Votes: future lookup\");",
                        "        return _delegateCheckpoints[account].upperLookupRecent(SafeCast.toUint32(timepoint));",
                        "     * @dev Returns the total supply of votes available at a specific moment in the past. If the `clock()` is",
                        "     * configured to use block numbers, this will return the value the end of the corresponding block.",
                        "     * - `timepoint` must be in the past. If operating using block numbers, the block must be already mined.",
                        "    function getPastTotalSupply(uint256 timepoint) public view virtual override returns (uint256) {",
                        "        require(timepoint < clock(), \"Votes: future lookup\");",
                        "        return _totalCheckpoints.upperLookupRecent(SafeCast.toUint32(timepoint));",
                        "            _push(_totalCheckpoints, _add, SafeCast.toUint224(amount));",
                        "            _push(_totalCheckpoints, _subtract, SafeCast.toUint224(amount));",
                        "                (uint256 oldValue, uint256 newValue) = _push(",
                        "                    _delegateCheckpoints[from],",
                        "                    _subtract,",
                        "                    SafeCast.toUint224(amount)",
                        "                );",
                        "                (uint256 oldValue, uint256 newValue) = _push(",
                        "                    _delegateCheckpoints[to],",
                        "                    _add,",
                        "                    SafeCast.toUint224(amount)",
                        "                );",
                        "    function _push(",
                        "        Checkpoints.Trace224 storage store,",
                        "        function(uint224, uint224) view returns (uint224) op,",
                        "        uint224 delta",
                        "    ) private returns (uint224, uint224) {",
                        "        return store.push(SafeCast.toUint32(clock()), op(store.latest(), delta));",
                        "    }",
                        "    function _add(uint224 a, uint224 b) private pure returns (uint224) {",
                        "    function _subtract(uint224 a, uint224 b) private pure returns (uint224) {",
                        "interface IERC5805 is IERC6372, IVotes {}",
                        "interface IERC6372 {",
                        "    /**",
                        "     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).",
                        "     */",
                        "    function clock() external view returns (uint48);",
                        "    /**",
                        "     * @dev Description of the clock",
                        "     */",
                        "    function CLOCK_MODE() external view returns (string memory);",
                        "}",
                        "abstract contract VotesTimestampMock is VotesMock {",
                        "    function clock() public view override returns (uint48) {",
                        "        return uint48(block.timestamp);",
                        "    }",
                        "    function CLOCK_MODE() public view virtual override returns (string memory) {",
                        "        return \"mode=timestamp\";",
                        "    }",
                        "}",
                        "/**",
                        " * @dev Copied from the master branch at commit 86de1e8b6c3fa6b4efa4a5435869d2521be0f5f5",
                        " */",
                        "abstract contract ERC20VotesLegacyMock is IVotes, ERC20Permit {",
                        "    struct Checkpoint {",
                        "        uint32 fromBlock;",
                        "        uint224 votes;",
                        "    }",
                        "    bytes32 private constant _DELEGATION_TYPEHASH =",
                        "        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");",
                        "    mapping(address => address) private _delegates;",
                        "    mapping(address => Checkpoint[]) private _checkpoints;",
                        "    Checkpoint[] private _totalSupplyCheckpoints;",
                        "    /**",
                        "     * @dev Get the `pos`-th checkpoint for `account`.",
                        "     */",
                        "    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {",
                        "        return _checkpoints[account][pos];",
                        "    }",
                        "    /**",
                        "     * @dev Get number of checkpoints for `account`.",
                        "     */",
                        "    function numCheckpoints(address account) public view virtual returns (uint32) {",
                        "        return SafeCast.toUint32(_checkpoints[account].length);",
                        "    }",
                        "    /**",
                        "     * @dev Get the address `account` is currently delegating to.",
                        "     */",
                        "    function delegates(address account) public view virtual override returns (address) {",
                        "        return _delegates[account];",
                        "    }",
                        "    /**",
                        "     * @dev Gets the current votes balance for `account`",
                        "     */",
                        "    function getVotes(address account) public view virtual override returns (uint256) {",
                        "        uint256 pos = _checkpoints[account].length;",
                        "        unchecked {",
                        "            return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `blockNumber` must have been already mined",
                        "     */",
                        "    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");",
                        "        return _checkpointsLookup(_checkpoints[account], blockNumber);",
                        "    }",
                        "    /**",
                        "     * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.",
                        "     * It is NOT the sum of all the delegated votes!",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `blockNumber` must have been already mined",
                        "     */",
                        "    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");",
                        "        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);",
                        "    }",
                        "    /**",
                        "     * @dev Lookup a value in a list of (sorted) checkpoints.",
                        "     */",
                        "    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {",
                        "        //",
                        "        uint256 length = ckpts.length;",
                        "        uint256 low = 0;",
                        "        uint256 high = length;",
                        "        if (length > 5) {",
                        "            uint256 mid = length - Math.sqrt(length);",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > blockNumber) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }",
                        "        }",
                        "        while (low < high) {",
                        "            uint256 mid = Math.average(low, high);",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > blockNumber) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }",
                        "        }",
                        "        unchecked {",
                        "            return high == 0 ? 0 : _unsafeAccess(ckpts, high - 1).votes;",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Delegate votes from the sender to `delegatee`.",
                        "     */",
                        "    function delegate(address delegatee) public virtual override {",
                        "        _delegate(_msgSender(), delegatee);",
                        "    }",
                        "    /**",
                        "     * @dev Delegates votes from signer to `delegatee`",
                        "     */",
                        "    function delegateBySig(",
                        "        address delegatee,",
                        "        uint256 nonce,",
                        "        uint256 expiry,",
                        "        uint8 v,",
                        "        bytes32 r,",
                        "        bytes32 s",
                        "    ) public virtual override {",
                        "        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");",
                        "        address signer = ECDSA.recover(",
                        "            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),",
                        "            v,",
                        "            r,",
                        "            s",
                        "        );",
                        "        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");",
                        "        _delegate(signer, delegatee);",
                        "    }",
                        "    /**",
                        "     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).",
                        "     */",
                        "    function _maxSupply() internal view virtual returns (uint224) {",
                        "        return type(uint224).max;",
                        "    }",
                        "    /**",
                        "     * @dev Snapshots the totalSupply after it has been increased.",
                        "     */",
                        "    function _mint(address account, uint256 amount) internal virtual override {",
                        "        super._mint(account, amount);",
                        "        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");",
                        "        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);",
                        "    }",
                        "    /**",
                        "     * @dev Snapshots the totalSupply after it has been decreased.",
                        "     */",
                        "    function _burn(address account, uint256 amount) internal virtual override {",
                        "        super._burn(account, amount);",
                        "        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);",
                        "    }",
                        "    /**",
                        "     * @dev Move voting power when tokens are transferred.",
                        "     *",
                        "     * Emits a {IVotes-DelegateVotesChanged} event.",
                        "     */",
                        "    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual override {",
                        "        super._afterTokenTransfer(from, to, amount);",
                        "        _moveVotingPower(delegates(from), delegates(to), amount);",
                        "    }",
                        "    /**",
                        "     * @dev Change delegation for `delegator` to `delegatee`.",
                        "     *",
                        "     * Emits events {IVotes-DelegateChanged} and {IVotes-DelegateVotesChanged}.",
                        "     */",
                        "    function _delegate(address delegator, address delegatee) internal virtual {",
                        "        address currentDelegate = delegates(delegator);",
                        "        uint256 delegatorBalance = balanceOf(delegator);",
                        "        _delegates[delegator] = delegatee;",
                        "        emit DelegateChanged(delegator, currentDelegate, delegatee);",
                        "        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);",
                        "    }",
                        "    function _moveVotingPower(address src, address dst, uint256 amount) private {",
                        "        if (src != dst && amount > 0) {",
                        "            if (src != address(0)) {",
                        "                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);",
                        "                emit DelegateVotesChanged(src, oldWeight, newWeight);",
                        "            }",
                        "            if (dst != address(0)) {",
                        "                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);",
                        "                emit DelegateVotesChanged(dst, oldWeight, newWeight);",
                        "            }",
                        "        }",
                        "    }",
                        "    function _writeCheckpoint(",
                        "        Checkpoint[] storage ckpts,",
                        "        function(uint256, uint256) view returns (uint256) op,",
                        "        uint256 delta",
                        "    ) private returns (uint256 oldWeight, uint256 newWeight) {",
                        "        uint256 pos = ckpts.length;",
                        "        unchecked {",
                        "            Checkpoint memory oldCkpt = pos == 0 ? Checkpoint(0, 0) : _unsafeAccess(ckpts, pos - 1);",
                        "            oldWeight = oldCkpt.votes;",
                        "            newWeight = op(oldWeight, delta);",
                        "            if (pos > 0 && oldCkpt.fromBlock == block.number) {",
                        "                _unsafeAccess(ckpts, pos - 1).votes = SafeCast.toUint224(newWeight);",
                        "            } else {",
                        "                ckpts.push(",
                        "                    Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)})",
                        "                );",
                        "            }",
                        "        }",
                        "    }",
                        "    function _add(uint256 a, uint256 b) private pure returns (uint256) {",
                        "        return a + b;",
                        "    }",
                        "    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {",
                        "        return a - b;",
                        "    }",
                        "    /**",
                        "     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.",
                        "     */",
                        "    function _unsafeAccess(Checkpoint[] storage ckpts, uint256 pos) private pure returns (Checkpoint storage result) {",
                        "        assembly {",
                        "            mstore(0, ckpts.slot)",
                        "            result.slot := add(keccak256(0, 0x20), pos)",
                        "        }",
                        "    }",
                        "}",
                        "abstract contract ERC20VotesTimestampMock is ERC20Votes {",
                        "    function clock() public view virtual override returns (uint48) {",
                        "        return SafeCast.toUint48(block.timestamp);",
                        "    }",
                        "    function CLOCK_MODE() public view virtual override returns (string memory) {",
                        "        return \"mode=timestamp\";",
                        "    }",
                        "}",
                        "abstract contract ERC20VotesCompTimestampMock is ERC20VotesComp {",
                        "    function clock() public view virtual override returns (uint48) {",
                        "        return SafeCast.toUint48(block.timestamp);",
                        "    }",
                        "    function CLOCK_MODE() public view virtual override returns (string memory) {",
                        "        return \"mode=timestamp\";",
                        "    }",
                        "}",
                        "abstract contract ERC721VotesTimestampMock is ERC721Votes {",
                        "    function clock() public view virtual override returns (uint48) {",
                        "        return SafeCast.toUint48(block.timestamp);",
                        "    }",
                        "    function CLOCK_MODE() public view virtual override returns (string memory) {",
                        "        return \"mode=timestamp\";",
                        "    }",
                        "}",
                        "abstract contract ERC20Votes is ERC20Permit, IERC5805 {",
                        "    /**",
                        "     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).",
                        "     */",
                        "    function clock() public view virtual override returns (uint48) {",
                        "        return SafeCast.toUint48(block.number);",
                        "    }",
                        "    /**",
                        "     * @dev Description of the clock",
                        "     */",
                        "    function CLOCK_MODE() public view virtual override returns (string memory) {",
                        "        require(clock() == block.number);",
                        "        return \"mode=blocknumber&from=default\";",
                        "    }",
                        "     * @dev Retrieve the number of votes for `account` at the end of `timepoint`.",
                        "     * - `timepoint` must be in the past",
                        "    function getPastVotes(address account, uint256 timepoint) public view virtual override returns (uint256) {",
                        "        require(timepoint < clock(), \"ERC20Votes: future lookup\");",
                        "        return _checkpointsLookup(_checkpoints[account], timepoint);",
                        "     * @dev Retrieve the `totalSupply` at the end of `timepoint`. Note, this value is the sum of all balances.",
                        "     * - `timepoint` must be in the past",
                        "    function getPastTotalSupply(uint256 timepoint) public view virtual override returns (uint256) {",
                        "        require(timepoint < clock(), \"ERC20Votes: future lookup\");",
                        "        return _checkpointsLookup(_totalSupplyCheckpoints, timepoint);",
                        "    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 timepoint) private view returns (uint256) {",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > timepoint) {",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > timepoint) {",
                        "            if (pos > 0 && oldCkpt.fromBlock == clock()) {",
                        "                ckpts.push(Checkpoint({fromBlock: SafeCast.toUint32(clock()), votes: SafeCast.toUint224(newWeight)}));",
                        "    /**",
                        "     * @dev Returns the value in the most recent checkpoint with key lower or equal than the search key.",
                        "     *",
                        "     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high keys).",
                        "     */",
                        "    function upperLookupRecent(Trace224 storage self, uint32 key) internal view returns (uint224) {",
                        "        uint256 len = self._checkpoints.length;",
                        "        uint256 low = 0;",
                        "        uint256 high = len;",
                        "        if (len > 5) {",
                        "            uint256 mid = len - Math.sqrt(len);",
                        "            if (key < _unsafeAccess(self._checkpoints, mid)._key) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }",
                        "        }",
                        "        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);",
                        "        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
                        "    }",
                        "    /**",
                        "     * @dev Returns the value in the most recent checkpoint with key lower or equal than the search key.",
                        "     *",
                        "     * NOTE: This is a variant of {upperLookup} that is optimised to find \"recent\" checkpoint (checkpoints with high keys).",
                        "     */",
                        "    function upperLookupRecent(Trace160 storage self, uint96 key) internal view returns (uint160) {",
                        "        uint256 len = self._checkpoints.length;",
                        "        uint256 low = 0;",
                        "        uint256 high = len;",
                        "        if (len > 5) {",
                        "            uint256 mid = len - Math.sqrt(len);",
                        "            if (key < _unsafeAccess(self._checkpoints, mid)._key) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }",
                        "        }",
                        "        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);",
                        "        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
                        "    }"
                    ],
                    "del": [
                        "    using Timers for Timers.BlockNumber;",
                        "        Timers.BlockNumber voteStart;",
                        "        Timers.BlockNumber voteEnd;",
                        "        address proposer;",
                        "            interfaceId == (type(IGovernor).interfaceId ^ this.cancel.selector) ||",
                        "            interfaceId == type(IGovernor).interfaceId ||",
                        "        if (snapshot >= block.number) {",
                        "        if (deadline >= block.number) {",
                        "        return _proposals[proposalId].voteStart.getDeadline();",
                        "        return _proposals[proposalId].voteEnd.getDeadline();",
                        "     * @dev Part of the Governor Bravo's interface: _\"The number of votes required in order for a voter to become a proposer\"_.",
                        "    function proposalThreshold() public view virtual returns (uint256) {",
                        "        return 0;",
                        "     * @dev Get the voting weight of `account` at a specific `blockNumber`, for a vote as described by `params`.",
                        "    function _getVotes(",
                        "        address account,",
                        "        uint256 blockNumber,",
                        "        bytes memory params",
                        "    ) internal view virtual returns (uint256);",
                        "            getVotes(proposer, block.number - 1) >= proposalThreshold(),",
                        "        ProposalCore storage proposal = _proposals[proposalId];",
                        "        require(proposal.voteStart.isUnset(), \"Governor: proposal already exists\");",
                        "        uint64 snapshot = block.number.toUint64() + votingDelay().toUint64();",
                        "        uint64 deadline = snapshot + votingPeriod().toUint64();",
                        "        proposal.voteStart.setDeadline(snapshot);",
                        "        proposal.voteEnd.setDeadline(deadline);",
                        "        proposal.proposer = proposer;",
                        "    function getVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        return _getVotes(account, blockNumber, _defaultParams());",
                        "        uint256 blockNumber,",
                        "        return _getVotes(account, blockNumber, params);",
                        "        uint256 weight = _getVotes(account, proposal.voteStart.getDeadline(), params);",
                        "abstract contract IGovernor is IERC165 {",
                        "        uint256 startBlock,",
                        "        uint256 endBlock,",
                        "    function COUNTING_MODE() public pure virtual returns (string memory);",
                        "     * @dev Block number used to retrieve user's votes and quorum. As per Compound's Comp and OpenZeppelin's",
                        "     * ERC20Votes, the snapshot is performed at the end of this block. Hence, voting for this proposal starts at the",
                        "     * beginning of the following block.",
                        "     * @dev Block number at which votes close. Votes close at the end of this block, so it is possible to cast a vote",
                        "     * during this block.",
                        "     * @dev Delay, in number of block, between the proposal is created and the vote starts. This can be increased to",
                        "     * leave time for users to buy voting power, or delegate it, before the voting of a proposal starts.",
                        "     * @dev Delay, in number of blocks, between the vote start and vote ends.",
                        "     * Note: The `blockNumber` parameter corresponds to the snapshot used for counting vote. This allows to scale the",
                        "     * quorum depending on values such as the totalSupply of a token at this block (see {ERC20Votes}).",
                        "    function quorum(uint256 blockNumber) public view virtual returns (uint256);",
                        "     * @dev Voting power of an `account` at a specific `blockNumber`.",
                        "    function getVotes(address account, uint256 blockNumber) public view virtual returns (uint256);",
                        "     * @dev Voting power of an `account` at a specific `blockNumber` given additional encoded parameters.",
                        "        uint256 blockNumber,",
                        "     * @dev Create a new proposal. Vote start {IGovernor-votingDelay} blocks after the proposal is created and ends",
                        "     * {IGovernor-votingPeriod} blocks after the voting starts.",
                        "        ProposalDetails storage details = _proposalDetails[proposalId];",
                        "            _msgSender() == details.proposer || getVotes(details.proposer, block.number - 1) < proposalThreshold(),",
                        "        return quorum(block.number - 1);",
                        "    using Timers for Timers.BlockNumber;",
                        "    mapping(uint256 => Timers.BlockNumber) private _extendedDeadlines;",
                        "        return Math.max(super.proposalDeadline(proposalId), _extendedDeadlines[proposalId].getDeadline());",
                        "        Timers.BlockNumber storage extendedDeadline = _extendedDeadlines[proposalId];",
                        "        if (extendedDeadline.isUnset() && _quorumReached(proposalId)) {",
                        "            uint64 extendedDeadlineValue = block.number.toUint64() + lateQuorumVoteExtension();",
                        "            if (extendedDeadlineValue > proposalDeadline(proposalId)) {",
                        "                emit ProposalExtended(proposalId, extendedDeadlineValue);",
                        "            extendedDeadline.setDeadline(extendedDeadlineValue);",
                        "    using Timers for Timers.Timestamp;",
                        "    struct ProposalTimelock {",
                        "        Timers.Timestamp timer;",
                        "    }",
                        "    mapping(uint256 => ProposalTimelock) private _proposalTimelocks;",
                        "        return _proposalTimelocks[proposalId].timer.getDeadline();",
                        "        _proposalTimelocks[proposalId].timer.setDeadline(eta.toUint64());",
                        "            _proposalTimelocks[proposalId].timer.reset();",
                        "    IVotes public immutable token;",
                        "        token = tokenAddress;",
                        "        uint256 blockNumber,",
                        "        return token.getPastVotes(account, blockNumber);",
                        "     * Read the voting weight from the token's built in snapshot mechanism (see {Governor-_getVotes}).",
                        "        uint256 blockNumber,",
                        "        return token.getPriorVotes(account, blockNumber);",
                        "    using Checkpoints for Checkpoints.History;",
                        "    Checkpoints.History private _quorumNumeratorHistory;",
                        "     * @dev Returns the quorum numerator at a specific block number. See {quorumDenominator}.",
                        "    function quorumNumerator(uint256 blockNumber) public view virtual returns (uint256) {",
                        "        Checkpoints.Checkpoint memory latest = _quorumNumeratorHistory._checkpoints[length - 1];",
                        "        if (latest._blockNumber <= blockNumber) {",
                        "        return _quorumNumeratorHistory.getAtBlock(blockNumber);",
                        "     * @dev Returns the quorum for a block number, in terms of number of votes: `supply * numerator / denominator`.",
                        "    function quorum(uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        return (token.getPastTotalSupply(blockNumber) * quorumNumerator(blockNumber)) / quorumDenominator();",
                        "                Checkpoints.Checkpoint({_blockNumber: 0, _value: SafeCast.toUint224(oldQuorumNumerator)})",
                        "        _quorumNumeratorHistory.push(newQuorumNumerator);",
                        "     * @dev Returns the amount of votes that `account` had at the end of a past block (`blockNumber`).",
                        "    function getPastVotes(address account, uint256 blockNumber) external view returns (uint256);",
                        "     * @dev Returns the total supply of votes available at the end of a past block (`blockNumber`).",
                        "    function getPastTotalSupply(uint256 blockNumber) external view returns (uint256);",
                        "abstract contract Votes is IVotes, Context, EIP712 {",
                        "    using Checkpoints for Checkpoints.History;",
                        "    mapping(address => Checkpoints.History) private _delegateCheckpoints;",
                        "    Checkpoints.History private _totalCheckpoints;",
                        "     * @dev Returns the amount of votes that `account` had at the end of a past block (`blockNumber`).",
                        "     * - `blockNumber` must have been already mined",
                        "    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        return _delegateCheckpoints[account].getAtProbablyRecentBlock(blockNumber);",
                        "     * @dev Returns the total supply of votes available at the end of a past block (`blockNumber`).",
                        "     * - `blockNumber` must have been already mined",
                        "    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        require(blockNumber < block.number, \"Votes: block not yet mined\");",
                        "        return _totalCheckpoints.getAtProbablyRecentBlock(blockNumber);",
                        "            _totalCheckpoints.push(_add, amount);",
                        "            _totalCheckpoints.push(_subtract, amount);",
                        "                (uint256 oldValue, uint256 newValue) = _delegateCheckpoints[from].push(_subtract, amount);",
                        "                (uint256 oldValue, uint256 newValue) = _delegateCheckpoints[to].push(_add, amount);",
                        "    function _add(uint256 a, uint256 b) private pure returns (uint256) {",
                        "    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {",
                        "abstract contract ERC20Votes is IVotes, ERC20Permit {",
                        "     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.",
                        "     * - `blockNumber` must have been already mined",
                        "    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");",
                        "        return _checkpointsLookup(_checkpoints[account], blockNumber);",
                        "     * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.",
                        "     * - `blockNumber` must have been already mined",
                        "    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");",
                        "        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);",
                        "    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > blockNumber) {",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > blockNumber) {",
                        "            if (pos > 0 && oldCkpt.fromBlock == block.number) {",
                        "                ckpts.push(",
                        "                    Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)})",
                        "                );"
                    ]
                }
            }
        ],
        "- `ERC4626`: Add mitigation to the inflation attack through virtual shares and assets. ([#3979](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3979))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3979": {
                    "add": [
                        "abstract contract ERC4626OffsetMock is ERC4626 {",
                        "    uint8 private immutable _offset;",
                        "    constructor(uint8 offset_) {",
                        "        _offset = offset_;",
                        "    }",
                        "    function _decimalsOffset() internal view virtual override returns (uint8) {",
                        "        return _offset;",
                        "    }",
                        "}",
                        " * [CAUTION]",
                        " * ====",
                        " * In empty (or nearly empty) ERC-4626 vaults, deposits are at high risk of being stolen through frontrunning",
                        " * with a \"donation\" to the vault that inflates the price of a share. This is variously known as a donation or inflation",
                        " * similarly be affected by slippage. Users can protect against this attack as well as unexpected slippage in general by",
                        " * Since v4.9, this implementation uses virtual assets and shares to mitigate that risk. The `_decimalsOffset()`",
                        " * corresponds to an offset in the decimal representation between the underlying asset's decimals and the vault",
                        " * decimals. This offset also determines the rate of virtual shares to virtual assets in the vault, which itself",
                        " * determines the initial exchange rate. While not fully preventing the attack, analysis shows that the default offset",
                        " * (0) makes it non-profitable, as a result of the value being captured by the virtual shares (out of the attacker's",
                        " * donation) matching the attacker's expected gains. With a larger offset, the attack becomes orders of magnitude more",
                        " * expensive than it is profitable. More details about the underlying math can be found",
                        " * xref:erc4626.adoc#inflation-attack[here].",
                        " *",
                        " * The drawback of this approach is that the virtual shares do capture (a very small) part of the value being accrued",
                        " * to the vault. Also, if the vault experiences losses, the users try to exit the vault, the virtual shares and assets",
                        " * will cause the first user to exit to experience reduced losses in detriment to the last users that will experience",
                        " * bigger losses. Developers willing to revert back to the pre-v4.9 behavior just need to override the",
                        " * `_convertToShares` and `_convertToAssets` functions.",
                        " *",
                        " * To learn more, check out our xref:ROOT:erc4626.adoc[ERC-4626 guide].",
                        " * ====",
                        " *",
                        "    uint8 private immutable _underlyingDecimals;",
                        "        _underlyingDecimals = success ? assetDecimals : 18;",
                        "        return _underlyingDecimals + _decimalsOffset();",
                        "        return type(uint256).max;",
                        "        return assets.mulDiv(totalSupply() + 10 ** _decimalsOffset(), totalAssets() + 1, rounding);",
                        "        return shares.mulDiv(totalAssets() + 1, totalSupply() + 10 ** _decimalsOffset(), rounding);",
                        "    function _decimalsOffset() internal view virtual returns (uint8) {",
                        "        return 0;",
                        "    function _asRounding(uint8 r) private pure returns (Math.Rounding) {"
                    ],
                    "del": [
                        "abstract contract ERC4626DecimalsMock is ERC4626 {",
                        "    using Math for uint256;",
                        "    uint8 private immutable _decimals;",
                        "    constructor(uint8 decimals_) {",
                        "        _decimals = decimals_;",
                        "    }",
                        "    function decimals() public view virtual override returns (uint8) {",
                        "        return _decimals;",
                        "    }",
                        "    function _initialConvertToShares(",
                        "        uint256 assets,",
                        "        Math.Rounding rounding",
                        "    ) internal view virtual override returns (uint256 shares) {",
                        "        return assets.mulDiv(10 ** decimals(), 10 ** super.decimals(), rounding);",
                        "    }",
                        "    function _initialConvertToAssets(",
                        "        uint256 shares,",
                        "        Math.Rounding rounding",
                        "    ) internal view virtual override returns (uint256 assets) {",
                        "        return shares.mulDiv(10 ** super.decimals(), 10 ** decimals(), rounding);",
                        "    }",
                        "}",
                        " * CAUTION: When the vault is empty or nearly empty, deposits are at high risk of being stolen through frontrunning with",
                        " * a \"donation\" to the vault that inflates the price of a share. This is variously known as a donation or inflation",
                        " * similarly be affected by slippage. Users can protect against this attack as well unexpected slippage in general by",
                        "    uint8 private immutable _decimals;",
                        "        _decimals = success ? assetDecimals : super.decimals();",
                        "        return _decimals;",
                        "        return _isVaultHealthy() ? type(uint256).max : 0;",
                        "        uint256 supply = totalSupply();",
                        "        return",
                        "            (assets == 0 || supply == 0)",
                        "                ? _initialConvertToShares(assets, rounding)",
                        "                : assets.mulDiv(supply, totalAssets(), rounding);",
                        "    }",
                        "    /**",
                        "     * @dev Internal conversion function (from assets to shares) to apply when the vault is empty.",
                        "     *",
                        "     * NOTE: Make sure to keep this function consistent with {_initialConvertToAssets} when overriding it.",
                        "     */",
                        "    function _initialConvertToShares(",
                        "        uint256 assets,",
                        "        Math.Rounding /*rounding*/",
                        "    ) internal view virtual returns (uint256 shares) {",
                        "        return assets;",
                        "        uint256 supply = totalSupply();",
                        "        return",
                        "            (supply == 0) ? _initialConvertToAssets(shares, rounding) : shares.mulDiv(totalAssets(), supply, rounding);",
                        "    }",
                        "    /**",
                        "     * @dev Internal conversion function (from shares to assets) to apply when the vault is empty.",
                        "     *",
                        "     * NOTE: Make sure to keep this function consistent with {_initialConvertToShares} when overriding it.",
                        "     */",
                        "    function _initialConvertToAssets(",
                        "        uint256 shares,",
                        "        Math.Rounding /*rounding*/",
                        "    ) internal view virtual returns (uint256) {",
                        "        return shares;",
                        "    /**",
                        "     * @dev Checks if vault is \"healthy\" in the sense of having assets backing the circulating shares.",
                        "     */",
                        "    function _isVaultHealthy() private view returns (bool) {",
                        "        return totalAssets() > 0 || totalSupply() == 0;",
                        "    function test_RT_mint_withdraw(ERC4626Test.Init memory init, uint256 shares) public override {",
                        "        int256 initAssets = 0;",
                        "        for (uint256 i = 0; i < init.share.length; i++) {",
                        "            vm.assume(init.share[i] <= uint256(type(int256).max - initAssets));",
                        "            initAssets += SafeCast.toInt256(init.share[i]);",
                        "        }",
                        "        vm.assume(init.yield > -initAssets);",
                        "        super.test_RT_mint_withdraw(init, shares);",
                        "    }",
                        "    function _asRounding(uint8 r) private returns (Math.Rounding) {"
                    ]
                }
            }
        ],
        "- `ERC20Wrapper`: Make the `underlying` variable private and add a public accessor. ([#4029](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4029))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4029": {
                    "add": [
                        "    IERC20 private immutable _underlying;",
                        "        _underlying = underlyingToken;",
                        "        try IERC20Metadata(address(_underlying)).decimals() returns (uint8 value) {",
                        "    /**",
                        "     * @dev Returns the address of the underlying ERC-20 token that is being wrapped.",
                        "     */",
                        "    function underlying() public view returns (IERC20) {",
                        "        return _underlying;",
                        "    }",
                        "        SafeERC20.safeTransferFrom(_underlying, _msgSender(), address(this), amount);",
                        "        SafeERC20.safeTransfer(_underlying, account, amount);",
                        "        uint256 value = _underlying.balanceOf(address(this)) - totalSupply();"
                    ],
                    "del": [
                        "    IERC20 public immutable underlying;",
                        "        underlying = underlyingToken;",
                        "        try IERC20Metadata(address(underlying)).decimals() returns (uint8 value) {",
                        "        SafeERC20.safeTransferFrom(underlying, _msgSender(), address(this), amount);",
                        "        SafeERC20.safeTransfer(underlying, account, amount);",
                        "        uint256 value = underlying.balanceOf(address(this)) - totalSupply();"
                    ]
                }
            }
        ],
        "- `EIP712`: add EIP-5267 support for better domain discovery. ([#3969](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3969))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3969": {
                    "add": [
                        "interface IERC5267 {",
                        "    /**",
                        "     * @dev MAY be emitted to signal that the domain could have changed.",
                        "     */",
                        "    event EIP712DomainChanged();",
                        "    /**",
                        "     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712",
                        "     * signature.",
                        "     */",
                        "    function eip712Domain()",
                        "        external",
                        "        view",
                        "        returns (",
                        "            bytes1 fields,",
                        "            string memory name,",
                        "            string memory version,",
                        "            uint256 chainId,",
                        "            address verifyingContract,",
                        "            bytes32 salt,",
                        "            uint256[] memory extensions",
                        "        );",
                        "}",
                        " * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain",
                        " * separator of the implementation contract. This will cause the `_domainSeparatorV4` function to always rebuild the",
                        " * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.",
                        " *",
                        " *",
                        " * @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment",
                        "abstract contract EIP712 is IERC5267 {",
                        "    using ShortStrings for *;",
                        "    bytes32 private constant _TYPE_HASH =",
                        "        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");",
                        "    bytes32 private immutable _cachedDomainSeparator;",
                        "    uint256 private immutable _cachedChainId;",
                        "    address private immutable _cachedThis;",
                        "    ShortString private immutable _name;",
                        "    ShortString private immutable _version;",
                        "    string private _nameFallback;",
                        "    string private _versionFallback;",
                        "    bytes32 private immutable _hashedName;",
                        "    bytes32 private immutable _hashedVersion;",
                        "        _name = name.toShortStringWithFallback(_nameFallback);",
                        "        _version = version.toShortStringWithFallback(_versionFallback);",
                        "        _hashedName = keccak256(bytes(name));",
                        "        _hashedVersion = keccak256(bytes(version));",
                        "        _cachedChainId = block.chainid;",
                        "        _cachedDomainSeparator = _buildDomainSeparator();",
                        "        _cachedThis = address(this);",
                        "        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {",
                        "            return _cachedDomainSeparator;",
                        "            return _buildDomainSeparator();",
                        "    function _buildDomainSeparator() private view returns (bytes32) {",
                        "        return keccak256(abi.encode(_TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));",
                        "    /**",
                        "     * @dev See {EIP-5267}.",
                        "     */",
                        "    function eip712Domain()",
                        "        public",
                        "        view",
                        "        virtual",
                        "        override",
                        "        returns (",
                        "            bytes1 fields,",
                        "            string memory name,",
                        "            string memory version,",
                        "            uint256 chainId,",
                        "            address verifyingContract,",
                        "            bytes32 salt,",
                        "            uint256[] memory extensions",
                        "        )",
                        "    {",
                        "        return (",
                        "            _name.toStringWithFallback(_nameFallback),",
                        "            _version.toStringWithFallback(_versionFallback),",
                        "            block.chainid,",
                        "            address(this),",
                        "            bytes32(0),",
                        "            new uint256[](0)",
                        "        );",
                        "    }"
                    ],
                    "del": [
                        "abstract contract EIP712 {",
                        "    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;",
                        "    uint256 private immutable _CACHED_CHAIN_ID;",
                        "    address private immutable _CACHED_THIS;",
                        "    bytes32 private immutable _HASHED_NAME;",
                        "    bytes32 private immutable _HASHED_VERSION;",
                        "    bytes32 private immutable _TYPE_HASH;",
                        "        bytes32 hashedName = keccak256(bytes(name));",
                        "        bytes32 hashedVersion = keccak256(bytes(version));",
                        "        bytes32 typeHash = keccak256(",
                        "            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"",
                        "        );",
                        "        _HASHED_NAME = hashedName;",
                        "        _HASHED_VERSION = hashedVersion;",
                        "        _CACHED_CHAIN_ID = block.chainid;",
                        "        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);",
                        "        _CACHED_THIS = address(this);",
                        "        _TYPE_HASH = typeHash;",
                        "        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {",
                        "            return _CACHED_DOMAIN_SEPARATOR;",
                        "            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);",
                        "    function _buildDomainSeparator(",
                        "        bytes32 typeHash,",
                        "        bytes32 nameHash,",
                        "        bytes32 versionHash",
                        "    ) private view returns (bytes32) {",
                        "        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));"
                    ]
                }
            }
        ],
        "- `AccessControlDefaultAdminRules`: Add an extension of `AccessControl` with additional security rules for the `DEFAULT_ADMIN_ROLE`. ([#4009](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4009))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4009": {
                    "add": [
                        " * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}",
                        " * to enforce additional security measures for this role.",
                        "/**",
                        " * @dev Extension of {AccessControl} that allows specifying special rules to manage",
                        " * the `DEFAULT_ADMIN_ROLE` holder, which is a sensitive role with special permissions",
                        " * over other roles that may potentially have privileged rights in the system.",
                        " *",
                        " * If a specific role doesn't have an admin role assigned, the holder of the",
                        " * `DEFAULT_ADMIN_ROLE` will have the ability to grant it and revoke it.",
                        " *",
                        " * This contract implements the following risk mitigations on top of {AccessControl}:",
                        " *",
                        " * * Only one account holds the `DEFAULT_ADMIN_ROLE` since deployment until it's potentially renounced.",
                        " * * Enforce a 2-step process to transfer the `DEFAULT_ADMIN_ROLE` to another account.",
                        " * * Enforce a configurable delay between the two steps, with the ability to cancel in between.",
                        " *   - Even after the timer has passed to avoid locking it forever.",
                        " * * It is not possible to use another role to manage the `DEFAULT_ADMIN_ROLE`.",
                        " *",
                        " * Example usage:",
                        " *",
                        " * ```solidity",
                        " * contract MyToken is AccessControlDefaultAdminRules {",
                        " *   constructor() AccessControlDefaultAdminRules(",
                        " *     3 days,",
                        " *    ) {}",
                        " *}",
                        " * ```",
                        " *",
                        " * NOTE: The `delay` can only be set in the constructor and is fixed thereafter.",
                        " *",
                        " * _Available since v4.9._",
                        " */",
                        "abstract contract AccessControlDefaultAdminRules is IAccessControlDefaultAdminRules, IERC5313, AccessControl {",
                        "    uint48 private immutable _defaultAdminDelay;",
                        "    address private _currentDefaultAdmin;",
                        "    address private _pendingDefaultAdmin;",
                        "    uint48 private _defaultAdminTransferDelayedUntil;",
                        "    /**",
                        "     * @dev Sets the initial values for {defaultAdminDelay} in seconds and {defaultAdmin}.",
                        "     *",
                        "     * The `defaultAdminDelay` value is immutable. It can only be set at the constructor.",
                        "     */",
                        "    constructor(uint48 defaultAdminDelay_, address initialDefaultAdmin) {",
                        "        _defaultAdminDelay = defaultAdminDelay_;",
                        "        _grantRole(DEFAULT_ADMIN_ROLE, initialDefaultAdmin);",
                        "    }",
                        "    /**",
                        "     * @dev See {IERC5313-owner}.",
                        "     */",
                        "    function owner() public view virtual returns (address) {",
                        "        return defaultAdmin();",
                        "    }",
                        "    /**",
                        "     * @inheritdoc IAccessControlDefaultAdminRules",
                        "     */",
                        "    function defaultAdminDelay() public view virtual returns (uint48) {",
                        "        return _defaultAdminDelay;",
                        "    }",
                        "    /**",
                        "     * @inheritdoc IAccessControlDefaultAdminRules",
                        "     */",
                        "    function defaultAdmin() public view virtual returns (address) {",
                        "        return _currentDefaultAdmin;",
                        "    }",
                        "    /**",
                        "     * @inheritdoc IAccessControlDefaultAdminRules",
                        "     */",
                        "    function pendingDefaultAdmin() public view virtual returns (address) {",
                        "        return _pendingDefaultAdmin;",
                        "    }",
                        "    /**",
                        "     * @inheritdoc IAccessControlDefaultAdminRules",
                        "     */",
                        "    function defaultAdminTransferDelayedUntil() public view virtual returns (uint48) {",
                        "        return _defaultAdminTransferDelayedUntil;",
                        "    }",
                        "    /**",
                        "     * @dev See {IERC165-supportsInterface}.",
                        "     */",
                        "    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {",
                        "        return interfaceId == type(IAccessControlDefaultAdminRules).interfaceId || super.supportsInterface(interfaceId);",
                        "    }",
                        "    /**",
                        "     * @inheritdoc IAccessControlDefaultAdminRules",
                        "     */",
                        "    function beginDefaultAdminTransfer(address newAdmin) public virtual onlyRole(DEFAULT_ADMIN_ROLE) {",
                        "        _beginDefaultAdminTransfer(newAdmin);",
                        "    }",
                        "    /**",
                        "     * @inheritdoc IAccessControlDefaultAdminRules",
                        "     */",
                        "    function acceptDefaultAdminTransfer() public virtual {",
                        "        require(_msgSender() == pendingDefaultAdmin(), \"AccessControl: pending admin must accept\");",
                        "        _acceptDefaultAdminTransfer();",
                        "    }",
                        "    /**",
                        "     * @inheritdoc IAccessControlDefaultAdminRules",
                        "     */",
                        "    function cancelDefaultAdminTransfer() public virtual onlyRole(DEFAULT_ADMIN_ROLE) {",
                        "        _resetDefaultAdminTransfer();",
                        "    }",
                        "    /**",
                        "     * @dev Revokes `role` from the calling account.",
                        "     *",
                        "     * For `DEFAULT_ADMIN_ROLE`, only allows renouncing in two steps, so it's required",
                        "     * that the {defaultAdminTransferDelayedUntil} has passed and the pending default admin is the zero address.",
                        "     * After its execution, it will not be possible to call `onlyRole(DEFAULT_ADMIN_ROLE)`",
                        "     * functions.",
                        "     *",
                        "     * For other roles, see {AccessControl-renounceRole}.",
                        "     *",
                        "     * NOTE: Renouncing `DEFAULT_ADMIN_ROLE` will leave the contract without a defaultAdmin,",
                        "     * thereby disabling any functionality that is only available to the default admin, and the",
                        "     * possibility of reassigning a non-administrated role.",
                        "     */",
                        "    function renounceRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {",
                        "        if (role == DEFAULT_ADMIN_ROLE) {",
                        "            require(",
                        "                pendingDefaultAdmin() == address(0) && _hasDefaultAdminTransferDelayPassed(),",
                        "                \"AccessControl: only can renounce in two delayed steps\"",
                        "            );",
                        "        }",
                        "        super.renounceRole(role, account);",
                        "    }",
                        "    /**",
                        "     * @dev See {AccessControl-grantRole}. Reverts for `DEFAULT_ADMIN_ROLE`.",
                        "     */",
                        "    function grantRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {",
                        "        require(role != DEFAULT_ADMIN_ROLE, \"AccessControl: can't directly grant default admin role\");",
                        "        super.grantRole(role, account);",
                        "    }",
                        "    /**",
                        "     * @dev See {AccessControl-revokeRole}. Reverts for `DEFAULT_ADMIN_ROLE`.",
                        "     */",
                        "    function revokeRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {",
                        "        require(role != DEFAULT_ADMIN_ROLE, \"AccessControl: can't directly revoke default admin role\");",
                        "        super.revokeRole(role, account);",
                        "    }",
                        "    /**",
                        "     * @dev See {AccessControl-_setRoleAdmin}. Reverts for `DEFAULT_ADMIN_ROLE`.",
                        "     */",
                        "    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual override {",
                        "        require(role != DEFAULT_ADMIN_ROLE, \"AccessControl: can't violate default admin rules\");",
                        "        super._setRoleAdmin(role, adminRole);",
                        "    }",
                        "    /**",
                        "     * @dev Grants `role` to `account`.",
                        "     *",
                        "     * For `DEFAULT_ADMIN_ROLE`, it only allows granting if there isn't already a role's holder",
                        "     * or if the role has been previously renounced.",
                        "     *",
                        "     * For other roles, see {AccessControl-renounceRole}.",
                        "     *",
                        "     * NOTE: Exposing this function through another mechanism may make the",
                        "     * `DEFAULT_ADMIN_ROLE` assignable again. Make sure to guarantee this is",
                        "     * the expected behavior in your implementation.",
                        "     */",
                        "    function _grantRole(bytes32 role, address account) internal virtual override {",
                        "        if (role == DEFAULT_ADMIN_ROLE) {",
                        "            require(defaultAdmin() == address(0), \"AccessControl: default admin already granted\");",
                        "            _currentDefaultAdmin = account;",
                        "        }",
                        "        super._grantRole(role, account);",
                        "    }",
                        "    /**",
                        "     * @dev See {acceptDefaultAdminTransfer}.",
                        "     *",
                        "     * Internal function without access restriction.",
                        "     */",
                        "    function _acceptDefaultAdminTransfer() internal virtual {",
                        "        require(_hasDefaultAdminTransferDelayPassed(), \"AccessControl: transfer delay not passed\");",
                        "        _revokeRole(DEFAULT_ADMIN_ROLE, defaultAdmin());",
                        "        _grantRole(DEFAULT_ADMIN_ROLE, pendingDefaultAdmin());",
                        "        _resetDefaultAdminTransfer();",
                        "    }",
                        "    /**",
                        "     * @dev See {beginDefaultAdminTransfer}.",
                        "     *",
                        "     * Internal function without access restriction.",
                        "     */",
                        "    function _beginDefaultAdminTransfer(address newAdmin) internal virtual {",
                        "        _defaultAdminTransferDelayedUntil = SafeCast.toUint48(block.timestamp) + defaultAdminDelay();",
                        "        _pendingDefaultAdmin = newAdmin;",
                        "        emit DefaultAdminRoleChangeStarted(pendingDefaultAdmin(), defaultAdminTransferDelayedUntil());",
                        "    }",
                        "    /**",
                        "     * @dev See {AccessControl-_revokeRole}.",
                        "     */",
                        "    function _revokeRole(bytes32 role, address account) internal virtual override {",
                        "        if (role == DEFAULT_ADMIN_ROLE) {",
                        "            delete _currentDefaultAdmin;",
                        "        }",
                        "        super._revokeRole(role, account);",
                        "    }",
                        "    /**",
                        "     * @dev Resets the pending default admin and delayed until.",
                        "     */",
                        "    function _resetDefaultAdminTransfer() private {",
                        "        delete _pendingDefaultAdmin;",
                        "        delete _defaultAdminTransferDelayedUntil;",
                        "    }",
                        "    /**",
                        "     * @dev Checks if a {defaultAdminTransferDelayedUntil} has been set and passed.",
                        "     */",
                        "    function _hasDefaultAdminTransferDelayPassed() private view returns (bool) {",
                        "        uint48 delayedUntil = defaultAdminTransferDelayedUntil();",
                        "        return delayedUntil > 0 && delayedUntil < block.timestamp;",
                        "    }",
                        "}",
                        "/**",
                        " * @dev External interface of AccessControlDefaultAdminRules declared to support ERC165 detection.",
                        " *",
                        " * _Available since v4.9._",
                        " */",
                        "interface IAccessControlDefaultAdminRules is IAccessControl {",
                        "    /**",
                        "     * @dev Emitted when a `DEFAULT_ADMIN_ROLE` transfer is started, setting `newDefaultAdmin`",
                        "     * as the next default admin, which will have rights to claim the `DEFAULT_ADMIN_ROLE`",
                        "     * after `defaultAdminTransferDelayedUntil` has passed.",
                        "     */",
                        "    event DefaultAdminRoleChangeStarted(address indexed newDefaultAdmin, uint48 defaultAdminTransferDelayedUntil);",
                        "    /**",
                        "     * @dev Returns the delay between each `DEFAULT_ADMIN_ROLE` transfer.",
                        "     */",
                        "    function defaultAdminDelay() external view returns (uint48);",
                        "    /**",
                        "     * @dev Returns the address of the current `DEFAULT_ADMIN_ROLE` holder.",
                        "     */",
                        "    function defaultAdmin() external view returns (address);",
                        "    /**",
                        "     * @dev Returns the address of the pending `DEFAULT_ADMIN_ROLE` holder.",
                        "     */",
                        "    function pendingDefaultAdmin() external view returns (address);",
                        "    /**",
                        "     * @dev Returns the timestamp after which the pending default admin can claim the `DEFAULT_ADMIN_ROLE`.",
                        "     */",
                        "    function defaultAdminTransferDelayedUntil() external view returns (uint48);",
                        "    /**",
                        "     * @dev Starts a `DEFAULT_ADMIN_ROLE` transfer by setting a pending default admin",
                        "     * and a timer to pass.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - Only can be called by the current `DEFAULT_ADMIN_ROLE` holder.",
                        "     *",
                        "     * Emits a {DefaultAdminRoleChangeStarted}.",
                        "     */",
                        "    function beginDefaultAdminTransfer(address newAdmin) external;",
                        "    /**",
                        "     * @dev Completes a `DEFAULT_ADMIN_ROLE` transfer.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - Caller should be the pending default admin.",
                        "     * - `DEFAULT_ADMIN_ROLE` should be granted to the caller.",
                        "     * - `DEFAULT_ADMIN_ROLE` should be revoked from the previous holder.",
                        "     */",
                        "    function acceptDefaultAdminTransfer() external;",
                        "    /**",
                        "     * @dev Cancels a `DEFAULT_ADMIN_ROLE` transfer.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - Can be called even after the timer has passed.",
                        "     * - Can only be called by the current `DEFAULT_ADMIN_ROLE` holder.",
                        "     */",
                        "    function cancelDefaultAdminTransfer() external;",
                        "}",
                        "     * `onlyOwner` functions. Can only be called by the current owner.",
                        "     * thereby disabling any functionality that is only available to the owner."
                    ],
                    "del": [
                        " * accounts that have been granted it.",
                        "     * `onlyOwner` functions anymore. Can only be called by the current owner.",
                        "     * thereby removing any functionality that is only available to the owner."
                    ]
                }
            }
        ],
        "- `SignatureChecker`: Add `isValidERC1271SignatureNow` for checking a signature directly against a smart contract using ERC-1271. ([#3932](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3932))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3932": {
                    "add": [
                        "        return",
                        "            (error == ECDSA.RecoverError.NoError && recovered == signer) ||",
                        "            isValidERC1271SignatureNow(signer, hash, signature);",
                        "    }",
                        "    /**",
                        "     * @dev Checks if a signature is valid for a given signer and data hash. The signature is validated",
                        "     * against the signer smart contract using ERC1271.",
                        "     *",
                        "     * NOTE: Unlike ECDSA signatures, contract signatures are revocable, and the outcome of this function can thus",
                        "     * change through time. It could return true at block N and false at block N+1 (or the opposite).",
                        "     */",
                        "    function isValidERC1271SignatureNow(",
                        "        address signer,",
                        "        bytes32 hash,",
                        "        bytes memory signature",
                        "    ) internal view returns (bool) {"
                    ],
                    "del": [
                        "        if (error == ECDSA.RecoverError.NoError && recovered == signer) {",
                        "            return true;",
                        "        }"
                    ]
                }
            }
        ],
        "- `ERC1967Upgrade`: removed contract-wide `oz-upgrades-unsafe-allow delegatecall` annotation, replaced by granular annotation in `UUPSUpgradeable`. ([#3971](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3971))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3971": {
                    "add": [
                        "     *",
                        "     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall",
                        "     *",
                        "     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall"
                    ],
                    "del": [
                        " *",
                        " * @custom:oz-upgrades-unsafe-allow delegatecall"
                    ]
                }
            }
        ],
        "- `ERC20Wrapper`: self wrapping and deposit by the wrapper itself are now explicitelly forbiden. ([#4100](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4100))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4100": {
                    "add": [
                        "contract ERC20PermitHarness is ERC20Permit {",
                        "contract ERC20WrapperHarness is ERC20Wrapper {",
                        "    constructor(IERC20 _underlying, string memory _name, string memory _symbol) ERC20(_name, _symbol) ERC20Wrapper(_underlying) {}",
                        "    function underlyingTotalSupply() public view returns (uint256) {",
                        "        return underlying().totalSupply();",
                        "    }",
                        "    function underlyingBalanceOf(address account) public view returns (uint256) {",
                        "        return underlying().balanceOf(account);",
                        "    }",
                        "    function underlyingAllowanceToThis(address account) public view returns (uint256) {",
                        "        return underlying().allowance(account, address(this));",
                        "    }",
                        "    function recover(address account) public returns (uint256) {",
                        "        return _recover(account);",
                        "    }",
                        "}",
                        "        require(underlyingToken != this, \"ERC20Wrapper: cannot self wrap\");",
                        "        address sender = _msgSender();",
                        "        require(sender != address(this), \"ERC20Wrapper: wrapper can't deposit\");",
                        "        SafeERC20.safeTransferFrom(_underlying, sender, address(this), amount);"
                    ],
                    "del": [
                        "contract ERC20PermitHarness is ERC20, ERC20Permit {",
                        "        SafeERC20.safeTransferFrom(_underlying, _msgSender(), address(this), amount);"
                    ]
                }
            }
        ],
        "- `ECDSA`: optimize bytes32 computation by using assembly instead of `abi.encodePacked`. ([#3853](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3853))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3853": {
                    "add": [
                        "    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {",
                        "        assembly {",
                        "            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")",
                        "            mstore(0x1c, hash)",
                        "            message := keccak256(0x00, 0x3c)",
                        "        }",
                        "    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {",
                        "        assembly {",
                        "            let ptr := mload(0x40)",
                        "            mstore(ptr, \"\\x19\\x01\")",
                        "            mstore(add(ptr, 0x02), domainSeparator)",
                        "            mstore(add(ptr, 0x22), structHash)",
                        "            data := keccak256(ptr, 0x42)",
                        "        }"
                    ],
                    "del": [
                        "    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {",
                        "        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));",
                        "    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {",
                        "        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));"
                    ]
                }
            }
        ],
        "- `ERC721URIStorage`: Emit ERC-4906 `MetadataUpdate` in `_setTokenURI`. ([#4012](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4012))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4012": {
                    "add": [
                        "interface IERC4906 is IERC165, IERC721 {",
                        "    event MetadataUpdate(uint256 _tokenId);",
                        "    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);",
                        "}",
                        "abstract contract ERC721URIStorage is IERC4906, ERC721 {",
                        "     * Emits {MetadataUpdate}.",
                        "     *",
                        "        emit MetadataUpdate(tokenId);"
                    ],
                    "del": [
                        "abstract contract ERC721URIStorage is ERC721 {"
                    ]
                }
            }
        ],
        "- `SignatureChecker`: Allow return data length greater than 32 from EIP-1271 signers. ([#4038](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4038))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4038": {
                    "add": [
                        "            result.length >= 32 &&"
                    ],
                    "del": [
                        "            result.length == 32 &&"
                    ]
                }
            }
        ],
        "- `UUPSUpgradeable`: added granular `oz-upgrades-unsafe-allow-reachable` annotation to improve upgrade safety checks on latest version of the Upgrades Plugins (starting with `@openzeppelin/upgrades-core@1.21.0`). ([#3971](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3971))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3971": {
                    "add": [
                        "     *",
                        "     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall",
                        "     *",
                        "     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall"
                    ],
                    "del": [
                        " *",
                        " * @custom:oz-upgrades-unsafe-allow delegatecall"
                    ]
                }
            }
        ],
        "- `Math`: optimize `log256` rounding check. ([#3745](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3745))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3745": {
                    "add": [
                        "            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);"
                    ],
                    "del": [
                        "            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);"
                    ]
                }
            }
        ],
        "- `ERC20Votes`: optimize by using unchecked arithmetic. ([#3748](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3748))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3748": {
                    "add": [
                        "        unchecked {",
                        "            return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;",
                        "        }",
                        "     * It is NOT the sum of all the delegated votes!",
                        "        unchecked {",
                        "            return high == 0 ? 0 : _unsafeAccess(ckpts, high - 1).votes;",
                        "        }",
                        "        unchecked {",
                        "            Checkpoint memory oldCkpt = pos == 0 ? Checkpoint(0, 0) : _unsafeAccess(ckpts, pos - 1);",
                        "            oldWeight = oldCkpt.votes;",
                        "            newWeight = op(oldWeight, delta);",
                        "            if (pos > 0 && oldCkpt.fromBlock == block.number) {",
                        "                _unsafeAccess(ckpts, pos - 1).votes = SafeCast.toUint224(newWeight);",
                        "            } else {",
                        "                ckpts.push(",
                        "                    Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)})",
                        "                );",
                        "            }"
                    ],
                    "del": [
                        "        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;",
                        "     * It is but NOT the sum of all the delegated votes!",
                        "        return high == 0 ? 0 : _unsafeAccess(ckpts, high - 1).votes;",
                        "        Checkpoint memory oldCkpt = pos == 0 ? Checkpoint(0, 0) : _unsafeAccess(ckpts, pos - 1);",
                        "        oldWeight = oldCkpt.votes;",
                        "        newWeight = op(oldWeight, delta);",
                        "        if (pos > 0 && oldCkpt.fromBlock == block.number) {",
                        "            _unsafeAccess(ckpts, pos - 1).votes = SafeCast.toUint224(newWeight);",
                        "        } else {",
                        "            ckpts.push(Checkpoint({fromBlock: SafeCast.toUint32(block.number), votes: SafeCast.toUint224(newWeight)}));"
                    ]
                }
            }
        ],
        "- `Multicall`: annotate `multicall` function as upgrade safe to not raise a flag for its delegatecall. ([#3961](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3961))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3961": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- `ERC20Pausable`, `ERC721Pausable`, `ERC1155Pausable`: Add note regarding missing public pausing functionality ([#4007](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4007))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4007": {
                    "add": [
                        " * IMPORTANT: This contract does not include public pause and unpause functions. In",
                        " * addition to inheriting this contract, you must define both functions, invoking the",
                        " * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate",
                        " * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will",
                        " * make the contract unpausable.",
                        " *",
                        " *",
                        " * IMPORTANT: This contract does not include public pause and unpause functions. In",
                        " * addition to inheriting this contract, you must define both functions, invoking the",
                        " * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate",
                        " * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will",
                        " * make the contract unpausable.",
                        " *",
                        " * IMPORTANT: This contract does not include public pause and unpause functions. In",
                        " * addition to inheriting this contract, you must define both functions, invoking the",
                        " * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate",
                        " * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will",
                        " * make the contract unpausable."
                    ],
                    "del": []
                }
            }
        ],
        "- `MerkleProof`: optimize by using unchecked arithmetic. ([#3745](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3745))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3745": {
                    "add": [
                        "            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);"
                    ],
                    "del": [
                        "            return result + (rounding == Rounding.Up && 1 << (result * 8) < value ? 1 : 0);"
                    ]
                }
            }
        ],
        "- `EIP712`: Addition of ERC5267 support requires support for user defined value types, which was released in Solidity version 0.8.8. This requires a pragma change from `^0.8.0` to `^0.8.8`.": [],
        "- `EIP712`: Optimization of the cache for the upgradeable version affects the way `name` and `version` are set. This is no longer done through an initializer, and is instead part of the implementation's constructor. As a consequence, all proxies using the same implementation will necessarily share the same `name` and `version`. Additionally, an implementation upgrade risks changing the EIP712 domain unless the same `name` and `version` are used when deploying the new implementation contract.": [],
        "- `ERC777`: The `ERC777` token standard is no longer supported by OpenZeppelin. Our implementation is now deprecated and will be removed in the next major release. The corresponding standard interfaces remain available. ([#4066](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4066))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4066": {
                    "add": [
                        " *",
                        " * CAUTION: This file is deprecated as of v4.9 and will be removed in the next major release.",
                        " *",
                        " * CAUTION: This file is deprecated as of v4.9 and will be removed in the next major release."
                    ],
                    "del": []
                }
            }
        ],
        "- `ERC1820Implementer`: The `ERC1820` pseudo-introspection mechanism is no longer supported by OpenZeppelin. Our implementation is now deprecated and will be removed in the next major release. The corresponding standard interfaces remain available. ([#4066](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4066))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4066": {
                    "add": [
                        " *",
                        " * CAUTION: This file is deprecated as of v4.9 and will be removed in the next major release.",
                        " *",
                        " * CAUTION: This file is deprecated as of v4.9 and will be removed in the next major release."
                    ],
                    "del": []
                }
            }
        ]
    },
    "4.8.3": {
        "> This release contains fixes for https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-mx2q-35m2-x2rh and https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-93hq-5wgc-jc82.\r": [],
        "- `GovernorCompatibilityBravo`: Fix encoding of proposal data when signatures are missing.\r": [],
        "- `TransparentUpgradeableProxy`: Fix transparency in case of selector clash with non-decodable calldata or payable mutability. ([#4154](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4154))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4154": {
                    "add": [
                        "/**",
                        " * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.",
                        " *",
                        " * _Available since v4.9._",
                        " */",
                        "interface IERC1967 {",
                        "    /**",
                        "     * @dev Emitted when the implementation is upgraded.",
                        "     */",
                        "    event Upgraded(address indexed implementation);",
                        "    /**",
                        "     * @dev Emitted when the admin account has changed.",
                        "     */",
                        "    event AdminChanged(address previousAdmin, address newAdmin);",
                        "    /**",
                        "     * @dev Emitted when the beacon is changed.",
                        "     */",
                        "    event BeaconUpgraded(address indexed beacon);",
                        "}",
                        "abstract contract ERC1967Upgrade is IERC1967 {",
                        "    function getProxyImplementation(ITransparentUpgradeableProxy proxy) public view virtual returns (address) {",
                        "    function getProxyAdmin(ITransparentUpgradeableProxy proxy) public view virtual returns (address) {",
                        "    function changeProxyAdmin(ITransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {",
                        "    function upgrade(ITransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {",
                        "        ITransparentUpgradeableProxy proxy,",
                        "/**",
                        " * @dev Interface for the {TransparentUpgradeableProxy}. This is useful because {TransparentUpgradeableProxy} uses a",
                        " * custom call-routing mechanism, the compiler is unaware of the functions being exposed, and cannot list them. Also",
                        " * {TransparentUpgradeableProxy} does not inherit from this interface because it's implemented in a way that the",
                        " * compiler doesn't understand and cannot verify.",
                        " */",
                        "interface ITransparentUpgradeableProxy is IERC1967 {",
                        "    function admin() external view returns (address);",
                        "    function implementation() external view returns (address);",
                        "    function changeAdmin(address) external;",
                        "    function upgradeTo(address) external;",
                        "    function upgradeToAndCall(address, bytes memory) external payable;",
                        "}",
                        " *",
                        " * WARNING: This contract does not inherit from {ITransparentUpgradeableProxy}, and the admin function is implicitly",
                        " * implemented using a custom call-routing mechanism in `_fallback`. Consequently, the compiler will not produce an",
                        " * ABI for this contract. Also, if you inherit from this contract and add additional functions, the compiler will not",
                        " * check that there are no selector conflicts. A selector clash between any new function and the functions declared in",
                        " * {ITransparentUpgradeableProxy} will be resolved in favor of the new one. This could render the admin operations",
                        " * inaccessible, which could prevent upgradeability.",
                        "     *",
                        "     * CAUTION: This modifier is deprecated, as it could cause issues if the modified function has arguments, and the",
                        "     * implementation provides a function with the same selector.",
                        "    /**",
                        "     * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior",
                        "     */",
                        "    function _fallback() internal virtual override {",
                        "        if (msg.sender == _getAdmin()) {",
                        "            bytes memory ret;",
                        "            bytes4 selector = msg.sig;",
                        "            if (selector == ITransparentUpgradeableProxy.upgradeTo.selector) {",
                        "                ret = _dispatchUpgradeTo();",
                        "            } else if (selector == ITransparentUpgradeableProxy.upgradeToAndCall.selector) {",
                        "                ret = _dispatchUpgradeToAndCall();",
                        "            } else if (selector == ITransparentUpgradeableProxy.changeAdmin.selector) {",
                        "                ret = _dispatchChangeAdmin();",
                        "            } else if (selector == ITransparentUpgradeableProxy.admin.selector) {",
                        "                ret = _dispatchAdmin();",
                        "            } else if (selector == ITransparentUpgradeableProxy.implementation.selector) {",
                        "                ret = _dispatchImplementation();",
                        "            } else {",
                        "                revert(\"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");",
                        "            }",
                        "            assembly {",
                        "                return(add(ret, 0x20), mload(ret))",
                        "            }",
                        "        } else {",
                        "            super._fallback();",
                        "        }",
                        "    }",
                        "    function _dispatchAdmin() private returns (bytes memory) {",
                        "        address admin = _getAdmin();",
                        "        return abi.encode(admin);",
                        "    function _dispatchImplementation() private returns (bytes memory) {",
                        "        address implementation = _implementation();",
                        "        return abi.encode(implementation);",
                        "    function _dispatchChangeAdmin() private returns (bytes memory) {",
                        "        address newAdmin = abi.decode(msg.data[4:], (address));",
                        "        return \"\";",
                        "    function _dispatchUpgradeTo() private returns (bytes memory) {",
                        "        address newImplementation = abi.decode(msg.data[4:], (address));",
                        "        return \"\";",
                        "    function _dispatchUpgradeToAndCall() private returns (bytes memory) {",
                        "        (address newImplementation, bytes memory data) = abi.decode(msg.data[4:], (address, bytes));",
                        "        return \"\";"
                    ],
                    "del": [
                        "abstract contract ERC1967Upgrade {",
                        "    /**",
                        "     * @dev Emitted when the implementation is upgraded.",
                        "     */",
                        "    event Upgraded(address indexed implementation);",
                        "    /**",
                        "     * @dev Emitted when the admin account has changed.",
                        "     */",
                        "    event AdminChanged(address previousAdmin, address newAdmin);",
                        "    /**",
                        "     * @dev Emitted when the beacon is upgraded.",
                        "     */",
                        "    event BeaconUpgraded(address indexed beacon);",
                        "    function getProxyImplementation(TransparentUpgradeableProxy proxy) public view virtual returns (address) {",
                        "    function getProxyAdmin(TransparentUpgradeableProxy proxy) public view virtual returns (address) {",
                        "    function changeProxyAdmin(TransparentUpgradeableProxy proxy, address newAdmin) public virtual onlyOwner {",
                        "    function upgrade(TransparentUpgradeableProxy proxy, address implementation) public virtual onlyOwner {",
                        "        TransparentUpgradeableProxy proxy,",
                        "     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.",
                        "     *",
                        "    function admin() external payable ifAdmin returns (address admin_) {",
                        "        admin_ = _getAdmin();",
                        "     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.",
                        "     *",
                        "    function implementation() external payable ifAdmin returns (address implementation_) {",
                        "        implementation_ = _implementation();",
                        "     *",
                        "     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.",
                        "    function changeAdmin(address newAdmin) external payable virtual ifAdmin {",
                        "     *",
                        "     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.",
                        "    function upgradeTo(address newImplementation) external payable ifAdmin {",
                        "     *",
                        "     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.",
                        "    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {",
                        "    /**",
                        "     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.",
                        "     */",
                        "    function _beforeFallback() internal virtual override {",
                        "        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");",
                        "        super._beforeFallback();",
                        "    }"
                    ]
                }
            }
        ]
    },
    "4.8.2": {
        "> This release contains a fix for https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-878m-3g6q-594q.\r": [],
        "- `ERC721Consecutive`: Fixed a bug when `_mintConsecutive` is used for batches of size 1 that could lead to balance overflow. Refer to the breaking changes section in the changelog for a note on the behavior of `ERC721._beforeTokenTransfer`.\r": [],
        "- `ERC721`: The internal function `_beforeTokenTransfer` no longer updates balances, which it previously did when `batchSize` was greater than 1. This change has no consequence unless a custom ERC721 extension is explicitly invoking `_beforeTokenTransfer`. Balance updates in extensions must now be done explicitly using `__unsafe_increaseBalance`, with a name that indicates that there is an invariant that has to be manually verified.\r": []
    },
    "4.8.1": {
        " * `ERC4626`: Use staticcall instead of call when fetching underlying ERC-20 decimals. ([#3943](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3943))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3943": {
                    "add": [
                        "    function _tryGetAssetDecimals(IERC20 asset_) private view returns (bool, uint8) {",
                        "        (bool success, bytes memory encodedDecimals) = address(asset_).staticcall("
                    ],
                    "del": [
                        "    function _tryGetAssetDecimals(IERC20 asset_) private returns (bool, uint8) {",
                        "        (bool success, bytes memory encodedDecimals) = address(asset_).call("
                    ]
                }
            }
        ]
    },
    "4.8.0": {
        " * `TimelockController`: Added a new `admin` constructor parameter that is assigned the admin role instead of the deployer account. ([#3722](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3722))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3722": {
                    "add": [
                        "     * @dev Initializes the contract with the following parameters:",
                        "     * - `minDelay`: initial minimum delay for operations",
                        "     * - `proposers`: accounts to be granted proposer and canceller roles",
                        "     * - `executors`: accounts to be granted executor role",
                        "     * - `admin`: optional account to be granted admin role; disable with zero address",
                        "     *",
                        "     * IMPORTANT: The optional admin can aid with initial configuration of roles after deployment",
                        "     * without being subject to delay, but this role should be subsequently renounced in favor of",
                        "     * administration through timelocked proposals. Previous versions of this contract would assign",
                        "     * this admin to the deployer automatically and should be renounced as well.",
                        "        address[] memory executors,",
                        "        address admin",
                        "        if (admin != address(0)) {",
                        "            _setupRole(TIMELOCK_ADMIN_ROLE, admin);",
                        "        }"
                    ],
                    "del": [
                        "     * @dev Initializes the contract with a given `minDelay`, and a list of",
                        "     * initial proposers and executors. The proposers receive both the",
                        "     * proposer and the canceller role (for backward compatibility). The",
                        "     * executors receive the executor role.",
                        "     * NOTE: At construction, both the deployer and the timelock itself are",
                        "     * administrators. This helps further configuration of the timelock by the",
                        "     * deployer. After configuration is done, it is recommended that the",
                        "     * deployer renounces its admin position and relies on timelocked",
                        "     * operations to perform future maintenance.",
                        "        address[] memory executors",
                        "        _setupRole(TIMELOCK_ADMIN_ROLE, _msgSender());"
                    ]
                }
            }
        ],
        " * `Address`: optimize `functionCall` by calling `functionCallWithValue` directly. ([#3468](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3468))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3468": {
                    "add": [
                        "        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");"
                    ],
                    "del": [
                        "        return functionCall(target, data, \"Address: low-level call failed\");"
                    ]
                }
            }
        ],
        " * `Address`: optimize `functionCall` functions by checking contract size only if there is no returned data. ([#3469](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3469))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3469": {
                    "add": [
                        "        Address.verifyCallResultFromTarget(target, success, returndata, \"low-level call reverted\");",
                        "        return verifyCallResultFromTarget(target, success, returndata, errorMessage);",
                        "        return verifyCallResultFromTarget(target, success, returndata, errorMessage);",
                        "        return verifyCallResultFromTarget(target, success, returndata, errorMessage);",
                        "    }",
                        "    /**",
                        "     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling",
                        "     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.",
                        "     *",
                        "     * _Available since v4.8._",
                        "     */",
                        "    function verifyCallResultFromTarget(",
                        "        address target,",
                        "        bool success,",
                        "        bytes memory returndata,",
                        "        string memory errorMessage",
                        "    ) internal view returns (bytes memory) {",
                        "        if (success) {",
                        "            if (returndata.length == 0) {",
                        "                require(isContract(target), \"Address: call to non-contract\");",
                        "            }",
                        "            return returndata;",
                        "        } else {",
                        "            _revert(returndata, errorMessage);",
                        "        }",
                        "     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the",
                        "     * revert reason or using the provided one.",
                        "            _revert(returndata, errorMessage);",
                        "        }",
                        "    }",
                        "    function _revert(bytes memory returndata, string memory errorMessage) private pure {",
                        "        if (returndata.length > 0) {",
                        "            assembly {",
                        "                let returndata_size := mload(returndata)",
                        "                revert(add(32, returndata), returndata_size)",
                        "        } else {",
                        "            revert(errorMessage);"
                    ],
                    "del": [
                        "        Address.verifyCallResult(success, returndata, \"low-level call reverted\");",
                        "        require(isContract(target), \"Address: call to non-contract\");",
                        "        return verifyCallResult(success, returndata, errorMessage);",
                        "        require(isContract(target), \"Address: static call to non-contract\");",
                        "        return verifyCallResult(success, returndata, errorMessage);",
                        "        require(isContract(target), \"Address: delegate call to non-contract\");",
                        "        return verifyCallResult(success, returndata, errorMessage);",
                        "     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the",
                        "     * revert reason using the provided one.",
                        "            if (returndata.length > 0) {",
                        "                assembly {",
                        "                    let returndata_size := mload(returndata)",
                        "                    revert(add(32, returndata), returndata_size)",
                        "                }",
                        "            } else {",
                        "                revert(errorMessage);"
                    ]
                }
            }
        ],
        " * `ERC20`: optimize `_transfer`, `_mint` and `_burn` by using `unchecked` arithmetic when possible. ([#3513](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3513))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3513": {
                    "add": [
                        "            _balances[to] += amount;",
                        "        unchecked {",
                        "            _balances[account] += amount;",
                        "        }",
                        "            _totalSupply -= amount;"
                    ],
                    "del": [
                        "        _balances[to] += amount;",
                        "        _balances[account] += amount;",
                        "        _totalSupply -= amount;"
                    ]
                }
            }
        ],
        " * `ERC20Votes`, `ERC721Votes`: optimize `getPastVotes` for looking up recent checkpoints. ([#3673](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3673))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3673": {
                    "add": [
                        "        return _delegateCheckpoints[account].getAtProbablyRecentBlock(blockNumber);",
                        "        return _totalCheckpoints.getAtProbablyRecentBlock(blockNumber);",
                        "    function getAtProbablyRecentBlock(uint256 blockNumber) public view returns (uint256) {",
                        "        return _totalCheckpoints.getAtProbablyRecentBlock(blockNumber);",
                        "        uint256 length = ckpts.length;",
                        "        uint256 high = length;",
                        "        if (length > 5) {",
                        "            uint256 mid = length - Math.sqrt(length);",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > blockNumber) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }",
                        "        }",
                        "            if (_unsafeAccess(ckpts, mid).fromBlock > blockNumber) {",
                        "        return high == 0 ? 0 : _unsafeAccess(ckpts, high - 1).votes;",
                        "        Checkpoint memory oldCkpt = pos == 0 ? Checkpoint(0, 0) : _unsafeAccess(ckpts, pos - 1);",
                        "        oldWeight = oldCkpt.votes;",
                        "        if (pos > 0 && oldCkpt.fromBlock == block.number) {",
                        "            _unsafeAccess(ckpts, pos - 1).votes = SafeCast.toUint224(newWeight);",
                        "    function _unsafeAccess(Checkpoint[] storage ckpts, uint256 pos) private view returns (Checkpoint storage result) {",
                        "        assembly {",
                        "            mstore(0, ckpts.slot)",
                        "            result.slot := add(keccak256(0, 0x20), pos)",
                        "        }",
                        "    }",
                        "     * before it is returned, or zero otherwise. Similar to {upperLookup} but optimized for the case when the searched",
                        "     * checkpoint is probably \"recent\", defined as being among the last sqrt(N) checkpoints where N is the number of",
                        "     * checkpoints.",
                        "    function getAtProbablyRecentBlock(History storage self, uint256 blockNumber) internal view returns (uint256) {",
                        "        uint256 low = 0;",
                        "        uint256 high = length;",
                        "        if (length > 5) {",
                        "            uint256 mid = length - Math.sqrt(length);",
                        "            if (key < _unsafeAccess(self._checkpoints, mid)._blockNumber) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }"
                    ],
                    "del": [
                        "        return _delegateCheckpoints[account].getAtBlock(blockNumber);",
                        "        return _totalCheckpoints.getAtBlock(blockNumber);",
                        "    function getAtRecentBlock(uint256 blockNumber) public view returns (uint256) {",
                        "        return _totalCheckpoints.getAtRecentBlock(blockNumber);",
                        "    function upperLookupRecent(uint32 key) public view returns (uint224) {",
                        "        return _totalCheckpoints.upperLookupRecent(key);",
                        "    }",
                        "    function upperLookupRecent(uint96 key) public view returns (uint224) {",
                        "        return _totalCheckpoints.upperLookupRecent(key);",
                        "    }",
                        "        uint256 high = ckpts.length;",
                        "            if (ckpts[mid].fromBlock > blockNumber) {",
                        "        return high == 0 ? 0 : ckpts[high - 1].votes;",
                        "        oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;",
                        "        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {",
                        "            ckpts[pos - 1].votes = SafeCast.toUint224(newWeight);",
                        "     * before it is returned, or zero otherwise. Similarly to {upperLookup} but optimized for the case when the search",
                        "     * key is known to be recent.",
                        "    function getAtRecentBlock(History storage self, uint256 blockNumber) internal view returns (uint256) {",
                        "        uint256 offset = 1;",
                        "        while (offset <= length && _unsafeAccess(self._checkpoints, length - offset)._blockNumber > key) {",
                        "            offset <<= 1;",
                        "        uint256 low = offset < length ? length - offset : 0;",
                        "        uint256 high = length - (offset >> 1);",
                        "    /**",
                        "     * @dev Returns the value in the most recent checkpoint with key lower or equal than the search key (similarly to",
                        "     * {upperLookup}), optimized for the case when the search key is known to be recent.",
                        "     */",
                        "    function upperLookupRecent(Trace224 storage self, uint32 key) internal view returns (uint224) {",
                        "        uint256 length = self._checkpoints.length;",
                        "        uint256 offset = 1;",
                        "        while (offset <= length && _unsafeAccess(self._checkpoints, length - offset)._key > key) {",
                        "            offset <<= 1;",
                        "        }",
                        "        uint256 low = 0 < offset && offset < length ? length - offset : 0;",
                        "        uint256 high = length - (offset >> 1);",
                        "        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);",
                        "        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
                        "    }",
                        "    /**",
                        "     * @dev Returns the value in the most recent checkpoint with key lower or equal than the search key (similarly to",
                        "     * {upperLookup}), optimized for the case when the search key is known to be recent.",
                        "     */",
                        "    function upperLookupRecent(Trace160 storage self, uint96 key) internal view returns (uint160) {",
                        "        uint256 length = self._checkpoints.length;",
                        "        uint256 offset = 1;",
                        "        while (offset <= length && _unsafeAccess(self._checkpoints, length - offset)._key > key) {",
                        "            offset <<= 1;",
                        "        }",
                        "        uint256 low = 0 < offset && offset < length ? length - offset : 0;",
                        "        uint256 high = length - (offset >> 1);",
                        "        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);",
                        "        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
                        "    }"
                    ]
                }
            }
        ],
        " * `ERC721`: optimize transfers by making approval clearing implicit instead of emitting an event. ([#3481](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3481))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3481": {
                    "add": [
                        "        delete _tokenApprovals[tokenId];"
                    ],
                    "del": [
                        "        _approve(address(0), tokenId);"
                    ]
                }
            }
        ],
        " * `ERC721`: optimize burn by making approval clearing implicit instead of emitting an event. ([#3538](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3538))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3538": {
                    "add": [
                        "        delete _tokenApprovals[tokenId];"
                    ],
                    "del": [
                        "        _approve(address(0), tokenId);"
                    ]
                }
            }
        ],
        " * `ERC721`: Fix balance accounting when a custom `_beforeTokenTransfer` hook results in a transfer of the token under consideration. ([#3611](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3611))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3611": {
                    "add": [
                        "        require(!_exists(tokenId), \"ERC721: token already minted\");",
                        "        owner = ERC721.ownerOf(tokenId);",
                        "        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");"
                    ],
                    "del": []
                }
            }
        ],
        " * `ERC721`: use unchecked arithmetic for balance updates. ([#3524](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3524))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3524": {
                    "add": [
                        "        unchecked {",
                        "            _balances[to] += 1;",
                        "        }",
                        "        unchecked {",
                        "            _balances[owner] -= 1;",
                        "        }",
                        "        unchecked {",
                        "            _balances[from] -= 1;",
                        "            _balances[to] += 1;",
                        "        }"
                    ],
                    "del": [
                        "        _balances[to] += 1;",
                        "        _balances[owner] -= 1;",
                        "        _balances[from] -= 1;",
                        "        _balances[to] += 1;"
                    ]
                }
            }
        ],
        " * `ERC721Consecutive`: Implementation of EIP-2309 that allows batch minting of ERC721 tokens during construction. ([#3311](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3311))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3311": {
                    "add": [
                        "     * @dev Returns whether `account` has cast a vote on `proposalId`.",
                        "/**",
                        " * @dev ERC-2309: ERC-721 Consecutive Transfer Extension.",
                        " *",
                        " * _Available since v4.8._",
                        " */",
                        "interface IERC2309 {",
                        "    /**",
                        "     * @dev Emitted when the tokens from `fromTokenId` to `toTokenId` are transferred from `fromAddress` to `toAddress`.",
                        "     */",
                        "    event ConsecutiveTransfer(",
                        "        uint256 indexed fromTokenId,",
                        "        uint256 toTokenId,",
                        "        address indexed fromAddress,",
                        "        address indexed toAddress",
                        "    );",
                        "}",
                        "    function latestCheckpoint()",
                        "        public",
                        "        view",
                        "        returns (",
                        "            bool,",
                        "            uint256,",
                        "            uint256",
                        "        )",
                        "    {",
                        "        return _totalCheckpoints.latestCheckpoint();",
                        "    }",
                        "    function length() public view returns (uint256) {",
                        "        return _totalCheckpoints.length();",
                        "    }",
                        "    function latestCheckpoint()",
                        "        public",
                        "        view",
                        "        returns (",
                        "            bool,",
                        "            uint32,",
                        "            uint224",
                        "        )",
                        "    {",
                        "        return _totalCheckpoints.latestCheckpoint();",
                        "    }",
                        "    function length() public view returns (uint256) {",
                        "        return _totalCheckpoints.length();",
                        "    }",
                        "    function latestCheckpoint()",
                        "        public",
                        "        view",
                        "        returns (",
                        "            bool,",
                        "            uint96,",
                        "            uint160",
                        "        )",
                        "    {",
                        "        return _totalCheckpoints.latestCheckpoint();",
                        "    }",
                        "    function length() public view returns (uint256) {",
                        "        return _totalCheckpoints.length();",
                        "    }",
                        "/**",
                        " * @title ERC721ConsecutiveMock",
                        " */",
                        "contract ERC721ConsecutiveMock is ERC721Burnable, ERC721Consecutive, ERC721Pausable, ERC721Votes {",
                        "    constructor(",
                        "        string memory name,",
                        "        string memory symbol,",
                        "        address[] memory delegates,",
                        "        address[] memory receivers,",
                        "        uint96[] memory amounts",
                        "    ) ERC721(name, symbol) EIP712(name, \"1\") {",
                        "        for (uint256 i = 0; i < delegates.length; ++i) {",
                        "            _delegate(delegates[i], delegates[i]);",
                        "        }",
                        "        for (uint256 i = 0; i < receivers.length; ++i) {",
                        "            _mintConsecutive(receivers[i], amounts[i]);",
                        "        }",
                        "    }",
                        "    function pause() external {",
                        "        _pause();",
                        "    }",
                        "    function unpause() external {",
                        "        _unpause();",
                        "    }",
                        "    function exists(uint256 tokenId) public view returns (bool) {",
                        "        return _exists(tokenId);",
                        "    }",
                        "    function mint(address to, uint256 tokenId) public {",
                        "        _mint(to, tokenId);",
                        "    }",
                        "    function mintConsecutive(address to, uint96 amount) public {",
                        "        _mintConsecutive(to, amount);",
                        "    }",
                        "    function safeMint(address to, uint256 tokenId) public {",
                        "        _safeMint(to, tokenId);",
                        "    }",
                        "    function _ownerOf(uint256 tokenId) internal view virtual override(ERC721, ERC721Consecutive) returns (address) {",
                        "        return super._ownerOf(tokenId);",
                        "    }",
                        "    function _mint(address to, uint256 tokenId) internal virtual override(ERC721, ERC721Consecutive) {",
                        "        super._mint(to, tokenId);",
                        "    }",
                        "    function _beforeTokenTransfer(",
                        "        address from,",
                        "        address to,",
                        "        uint256 tokenId",
                        "    ) internal virtual override(ERC721, ERC721Pausable) {",
                        "        super._beforeTokenTransfer(from, to, tokenId);",
                        "    }",
                        "    function _afterTokenTransfer(",
                        "        address from,",
                        "        address to,",
                        "        uint256 tokenId",
                        "    ) internal virtual override(ERC721, ERC721Votes, ERC721Consecutive) {",
                        "        super._afterTokenTransfer(from, to, tokenId);",
                        "    }",
                        "    function _beforeConsecutiveTokenTransfer(",
                        "        address from,",
                        "        address to,",
                        "        uint256 first,",
                        "        uint96 size",
                        "    ) internal virtual override(ERC721, ERC721Pausable) {",
                        "        super._beforeConsecutiveTokenTransfer(from, to, first, size);",
                        "    }",
                        "    function _afterConsecutiveTokenTransfer(",
                        "        address from,",
                        "        address to,",
                        "        uint256 first,",
                        "        uint96 size",
                        "    ) internal virtual override(ERC721, ERC721Votes) {",
                        "        super._afterConsecutiveTokenTransfer(from, to, first, size);",
                        "    }",
                        "}",
                        "contract ERC721ConsecutiveEnumerableMock is ERC721Consecutive, ERC721Enumerable {",
                        "    constructor(",
                        "        string memory name,",
                        "        string memory symbol,",
                        "        address[] memory receivers,",
                        "        uint96[] memory amounts",
                        "    ) ERC721(name, symbol) {",
                        "        for (uint256 i = 0; i < receivers.length; ++i) {",
                        "            _mintConsecutive(receivers[i], amounts[i]);",
                        "        }",
                        "    }",
                        "    function supportsInterface(bytes4 interfaceId)",
                        "        public",
                        "        view",
                        "        virtual",
                        "        override(ERC721, ERC721Enumerable)",
                        "        returns (bool)",
                        "    {",
                        "        return super.supportsInterface(interfaceId);",
                        "    }",
                        "    function _ownerOf(uint256 tokenId) internal view virtual override(ERC721, ERC721Consecutive) returns (address) {",
                        "        return super._ownerOf(tokenId);",
                        "    }",
                        "    function _mint(address to, uint256 tokenId) internal virtual override(ERC721, ERC721Consecutive) {",
                        "        super._mint(to, tokenId);",
                        "    }",
                        "    function _beforeTokenTransfer(",
                        "        address from,",
                        "        address to,",
                        "        uint256 tokenId",
                        "    ) internal virtual override(ERC721, ERC721Enumerable) {",
                        "        super._beforeTokenTransfer(from, to, tokenId);",
                        "    }",
                        "    function _afterTokenTransfer(",
                        "        address from,",
                        "        address to,",
                        "        uint256 tokenId",
                        "    ) internal virtual override(ERC721, ERC721Consecutive) {",
                        "        super._afterTokenTransfer(from, to, tokenId);",
                        "    }",
                        "    function _beforeConsecutiveTokenTransfer(",
                        "        address from,",
                        "        address to,",
                        "        uint256 first,",
                        "        uint96 size",
                        "    ) internal virtual override(ERC721, ERC721Enumerable) {",
                        "        super._beforeConsecutiveTokenTransfer(from, to, first, size);",
                        "    }",
                        "}",
                        "contract ERC721ConsecutiveNoConstructorMintMock is ERC721Consecutive {",
                        "    constructor(string memory name, string memory symbol) ERC721(name, symbol) {",
                        "        _mint(msg.sender, 0);",
                        "    }",
                        "}",
                        "        address owner = _ownerOf(tokenId);",
                        "    /**",
                        "     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist",
                        "     */",
                        "    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {",
                        "        return _owners[tokenId];",
                        "    }",
                        "        return _ownerOf(tokenId) != address(0);",
                        "     * @dev Hook that is called before any (single) token transfer. This includes minting and burning.",
                        "     * See {_beforeConsecutiveTokenTransfer}.",
                        "     * @dev Hook that is called after any (single) transfer of tokens. This includes minting and burning.",
                        "     * See {_afterConsecutiveTokenTransfer}.",
                        "    /**",
                        "     * @dev Hook that is called before consecutive token transfers.",
                        "     * Calling conditions are similar to {_beforeTokenTransfer}.",
                        "     *",
                        "     * The default implementation include balances updates that extensions such as {ERC721Consecutive} cannot perform",
                        "     * directly.",
                        "     */",
                        "    function _beforeConsecutiveTokenTransfer(",
                        "        address from,",
                        "        address to,",
                        "        uint256, /*first*/",
                        "        uint96 size",
                        "    ) internal virtual {",
                        "        if (from != address(0)) {",
                        "            _balances[from] -= size;",
                        "        }",
                        "        if (to != address(0)) {",
                        "            _balances[to] += size;",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Hook that is called after consecutive token transfers.",
                        "     * Calling conditions are similar to {_afterTokenTransfer}.",
                        "     */",
                        "    function _afterConsecutiveTokenTransfer(",
                        "        address, /*from*/",
                        "        address, /*to*/",
                        "        uint256, /*first*/",
                        "        uint96 /*size*/",
                        "    ) internal virtual {}",
                        "/**",
                        " * @dev Implementation of the ERC2309 \"Consecutive Transfer Extension\" as defined in",
                        " * https://eips.ethereum.org/EIPS/eip-2309[EIP-2309].",
                        " *",
                        " * This extension allows the minting of large batches of tokens during the contract construction. These batches are",
                        " * limited to 5000 tokens at a time to accommodate off-chain indexers.",
                        " *",
                        " * Using this extension removes the ability to mint single tokens during the contract construction. This ability is",
                        " * regained after construction. During construction, only batch minting is allowed.",
                        " *",
                        " * IMPORTANT: This extension bypasses the hooks {_beforeTokenTransfer} and {_afterTokenTransfer} for tokens minted in",
                        " * batch. When using this extension, you should consider the {_beforeConsecutiveTokenTransfer} and",
                        " * {_afterConsecutiveTokenTransfer} hooks in addition to {_beforeTokenTransfer} and {_afterTokenTransfer}.",
                        " *",
                        " * IMPORTANT: When overriding {_afterTokenTransfer}, be careful about call ordering. {ownerOf} may return invalid",
                        " * values during the {_afterTokenTransfer} execution if the super call is not called first. To be safe, execute the",
                        " * super call before your custom logic.",
                        " *",
                        " * _Available since v4.8._",
                        " */",
                        "abstract contract ERC721Consecutive is IERC2309, ERC721 {",
                        "    using BitMaps for BitMaps.BitMap;",
                        "    using Checkpoints for Checkpoints.Trace160;",
                        "    Checkpoints.Trace160 private _sequentialOwnership;",
                        "    BitMaps.BitMap private _sequentialBurn;",
                        "    /**",
                        "     * @dev See {ERC721-_ownerOf}. Override that checks the sequential ownership structure for tokens that have",
                        "     * been minted as part of a batch, and not yet transferred.",
                        "     */",
                        "    function _ownerOf(uint256 tokenId) internal view virtual override returns (address) {",
                        "        address owner = super._ownerOf(tokenId);",
                        "        if (owner != address(0) || tokenId > type(uint96).max) {",
                        "            return owner;",
                        "        }",
                        "        return _sequentialBurn.get(tokenId) ? address(0) : address(_sequentialOwnership.lowerLookup(uint96(tokenId)));",
                        "    }",
                        "    /**",
                        "     * @dev Mint a batch of tokens of length `batchSize` for `to`.",
                        "     *",
                        "     * WARNING: Consecutive mint is only available during construction. ERC721 requires that any minting done after",
                        "     * construction emits a `Transfer` event, which is not the case of mints performed using this function.",
                        "     *",
                        "     * WARNING: Consecutive mint is limited to batches of 5000 tokens. Further minting is possible from a contract's",
                        "     * point of view but would cause indexing issues for off-chain services.",
                        "     *",
                        "     * Emits a {ConsecutiveTransfer} event.",
                        "     */",
                        "    function _mintConsecutive(address to, uint96 batchSize) internal virtual returns (uint96) {",
                        "        uint96 first = _totalConsecutiveSupply();",
                        "        if (batchSize > 0) {",
                        "            require(!Address.isContract(address(this)), \"ERC721Consecutive: batch minting restricted to constructor\");",
                        "            require(to != address(0), \"ERC721Consecutive: mint to the zero address\");",
                        "            require(batchSize <= 5000, \"ERC721Consecutive: batch too large\");",
                        "            _beforeConsecutiveTokenTransfer(address(0), to, first, batchSize);",
                        "            uint96 last = first + batchSize - 1;",
                        "            _sequentialOwnership.push(last, uint160(to));",
                        "            emit ConsecutiveTransfer(first, last, address(0), to);",
                        "            _afterConsecutiveTokenTransfer(address(0), to, first, batchSize);",
                        "        }",
                        "        return first;",
                        "    }",
                        "    /**",
                        "     * @dev See {ERC721-_mint}. Override version that restricts normal minting to after construction.",
                        "     *",
                        "     * Warning: Using {ERC721Consecutive} prevents using {_mint} during construction in favor of {_mintConsecutive}.",
                        "     * After construction, {_mintConsecutive} is no longer available and {_mint} becomes available.",
                        "     */",
                        "    function _mint(address to, uint256 tokenId) internal virtual override {",
                        "        require(Address.isContract(address(this)), \"ERC721Consecutive: can't mint during construction\");",
                        "        super._mint(to, tokenId);",
                        "    }",
                        "    /**",
                        "     * @dev See {ERC721-_afterTokenTransfer}. Burning of token that have been sequentially minted must be explicit.",
                        "     */",
                        "    function _afterTokenTransfer(",
                        "        address from,",
                        "        address to,",
                        "        uint256 tokenId",
                        "    ) internal virtual override {",
                        "        if (",
                        "        ) {",
                        "            _sequentialBurn.set(tokenId);",
                        "        }",
                        "        super._afterTokenTransfer(from, to, tokenId);",
                        "    }",
                        "    function _totalConsecutiveSupply() private view returns (uint96) {",
                        "        (bool exists, uint96 latestId, ) = _sequentialOwnership.latestCheckpoint();",
                        "        return exists ? latestId + 1 : 0;",
                        "    }",
                        "}",
                        "    /**",
                        "     * @dev Hook that is called before any batch token transfer. For now this is limited",
                        "     * to batch minting by the {ERC721Consecutive} extension.",
                        "     *",
                        "     * Calling conditions:",
                        "     *",
                        "     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be",
                        "     * transferred to `to`.",
                        "     * - When `from` is zero, `tokenId` will be minted for `to`.",
                        "     * - When `to` is zero, ``from``'s `tokenId` will be burned.",
                        "     * - `from` cannot be the zero address.",
                        "     * - `to` cannot be the zero address.",
                        "     *",
                        "     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].",
                        "     */",
                        "    function _beforeConsecutiveTokenTransfer(",
                        "        address,",
                        "        address,",
                        "        uint256,",
                        "        uint96",
                        "    ) internal virtual override {",
                        "        revert(\"ERC721Enumerable: consecutive transfers not supported\");",
                        "    }",
                        "    function _beforeConsecutiveTokenTransfer(",
                        "        address from,",
                        "        address to,",
                        "        uint256 first,",
                        "        uint96 size",
                        "    ) internal virtual override {",
                        "        super._beforeConsecutiveTokenTransfer(from, to, first, size);",
                        "        require(!paused(), \"ERC721Pausable: token transfer while paused\");",
                        "    }",
                        "    /**",
                        "     * @dev Adjusts votes when a batch of tokens is transferred.",
                        "     *",
                        "     * Emits a {Votes-DelegateVotesChanged} event.",
                        "     */",
                        "    function _afterConsecutiveTokenTransfer(",
                        "        address from,",
                        "        address to,",
                        "        uint256 first,",
                        "        uint96 size",
                        "    ) internal virtual override {",
                        "        _transferVotingUnits(from, to, size);",
                        "        super._afterConsecutiveTokenTransfer(from, to, first, size);",
                        "    }",
                        "    function _beforeConsecutiveTokenTransfer(",
                        "        address from,",
                        "        address to,",
                        "        uint256 first,",
                        "        uint96 size",
                        "    ) internal virtual override(ERC721, ERC721Enumerable, ERC721Pausable) {",
                        "        super._beforeConsecutiveTokenTransfer(from, to, first, size);",
                        "    }",
                        "    /**",
                        "     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.",
                        "     */",
                        "    function latest(History storage self) internal view returns (uint224) {",
                        "        uint256 pos = self._checkpoints.length;",
                        "        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
                        "    }",
                        "    /**",
                        "     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value",
                        "     * in the most recent checkpoint.",
                        "     */",
                        "    function latestCheckpoint(History storage self)",
                        "        internal",
                        "        view",
                        "        returns (",
                        "            bool exists,",
                        "            uint32 _blockNumber,",
                        "            uint224 _value",
                        "        )",
                        "    {",
                        "        uint256 pos = self._checkpoints.length;",
                        "        if (pos == 0) {",
                        "            return (false, 0, 0);",
                        "        } else {",
                        "            Checkpoint memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);",
                        "            return (true, ckpt._blockNumber, ckpt._value);",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Returns the number of checkpoint.",
                        "     */",
                        "    function length(History storage self) internal view returns (uint256) {",
                        "        return self._checkpoints.length;",
                        "    }",
                        "    /**",
                        "     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.",
                        "     */",
                        "    function latest(Trace224 storage self) internal view returns (uint224) {",
                        "        uint256 pos = self._checkpoints.length;",
                        "        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
                        "    }",
                        "    /**",
                        "     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value",
                        "     * in the most recent checkpoint.",
                        "     */",
                        "    function latestCheckpoint(Trace224 storage self)",
                        "        internal",
                        "        view",
                        "        returns (",
                        "            bool exists,",
                        "            uint32 _key,",
                        "            uint224 _value",
                        "        )",
                        "    {",
                        "        uint256 pos = self._checkpoints.length;",
                        "        if (pos == 0) {",
                        "            return (false, 0, 0);",
                        "        } else {",
                        "            Checkpoint224 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);",
                        "            return (true, ckpt._key, ckpt._value);",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Returns the number of checkpoint.",
                        "     */",
                        "    function length(Trace224 storage self) internal view returns (uint256) {",
                        "        return self._checkpoints.length;",
                        "    }",
                        "    /**",
                        "     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.",
                        "     */",
                        "    function latest(Trace160 storage self) internal view returns (uint160) {",
                        "        uint256 pos = self._checkpoints.length;",
                        "        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
                        "    }",
                        "    /**",
                        "     * @dev Returns whether there is a checkpoint in the structure (i.e. it is not empty), and if so the key and value",
                        "     * in the most recent checkpoint.",
                        "     */",
                        "    function latestCheckpoint(Trace160 storage self)",
                        "        internal",
                        "        view",
                        "        returns (",
                        "            bool exists,",
                        "            uint96 _key,",
                        "            uint160 _value",
                        "        )",
                        "    {",
                        "        uint256 pos = self._checkpoints.length;",
                        "        if (pos == 0) {",
                        "            return (false, 0, 0);",
                        "        } else {",
                        "            Checkpoint160 memory ckpt = _unsafeAccess(self._checkpoints, pos - 1);",
                        "            return (true, ckpt._key, ckpt._value);",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Returns the number of checkpoint.",
                        "     */",
                        "    function length(Trace160 storage self) internal view returns (uint256) {",
                        "        return self._checkpoints.length;",
                        "    }"
                    ],
                    "del": [
                        "     * @dev Returns weither `account` has cast a vote on `proposalId`.",
                        "    function length() public view returns (uint256) {",
                        "        return _totalCheckpoints._checkpoints.length;",
                        "    }",
                        "    function length() public view returns (uint256) {",
                        "        return _totalCheckpoints._checkpoints.length;",
                        "    }",
                        "    function length() public view returns (uint256) {",
                        "        return _totalCheckpoints._checkpoints.length;",
                        "    }",
                        "        address owner = _owners[tokenId];",
                        "        return _owners[tokenId] != address(0);",
                        "     * @dev Hook that is called before any token transfer. This includes minting",
                        "     * and burning.",
                        "     * @dev Hook that is called after any transfer of tokens. This includes",
                        "     * minting and burning.",
                        "    /**",
                        "     * @dev Returns the value in the latest checkpoint, or zero if there are no checkpoints.",
                        "     */",
                        "    function latest(History storage self) internal view returns (uint256) {",
                        "        uint256 pos = self._checkpoints.length;",
                        "        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
                        "    }",
                        "    /**",
                        "     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.",
                        "     */",
                        "    function latest(Trace224 storage self) internal view returns (uint224) {",
                        "        uint256 pos = self._checkpoints.length;",
                        "        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
                        "    }",
                        "    /**",
                        "     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.",
                        "     */",
                        "    function latest(Trace160 storage self) internal view returns (uint160) {",
                        "        uint256 pos = self._checkpoints.length;",
                        "        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
                        "    }"
                    ]
                }
            }
        ],
        " * `ReentrancyGuard`: Reduce code size impact of the modifier by using internal functions. ([#3515](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3515))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3515": {
                    "add": [
                        "        _nonReentrantBefore();",
                        "        _;",
                        "        _nonReentrantAfter();",
                        "    }",
                        "    function _nonReentrantBefore() private {",
                        "    }",
                        "    function _nonReentrantAfter() private {"
                    ],
                    "del": [
                        "        _;"
                    ]
                }
            }
        ],
        " * `SafeCast`: optimize downcasting of signed integers. ([#3565](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3565))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3565": {
                    "add": [
                        "    function toInt248(int256 value) internal pure returns (int248 downcasted) {",
                        "        downcasted = int248(value);",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");",
                        "    function toInt240(int256 value) internal pure returns (int240 downcasted) {",
                        "        downcasted = int240(value);",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");",
                        "    function toInt232(int256 value) internal pure returns (int232 downcasted) {",
                        "        downcasted = int232(value);",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");",
                        "    function toInt224(int256 value) internal pure returns (int224 downcasted) {",
                        "        downcasted = int224(value);",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");",
                        "    function toInt216(int256 value) internal pure returns (int216 downcasted) {",
                        "        downcasted = int216(value);",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");",
                        "    function toInt208(int256 value) internal pure returns (int208 downcasted) {",
                        "        downcasted = int208(value);",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");",
                        "    function toInt200(int256 value) internal pure returns (int200 downcasted) {",
                        "        downcasted = int200(value);",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");",
                        "    function toInt192(int256 value) internal pure returns (int192 downcasted) {",
                        "        downcasted = int192(value);",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");",
                        "    function toInt184(int256 value) internal pure returns (int184 downcasted) {",
                        "        downcasted = int184(value);",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");",
                        "    function toInt176(int256 value) internal pure returns (int176 downcasted) {",
                        "        downcasted = int176(value);",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");",
                        "    function toInt168(int256 value) internal pure returns (int168 downcasted) {",
                        "        downcasted = int168(value);",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");",
                        "    function toInt160(int256 value) internal pure returns (int160 downcasted) {",
                        "        downcasted = int160(value);",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");",
                        "    function toInt152(int256 value) internal pure returns (int152 downcasted) {",
                        "        downcasted = int152(value);",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");",
                        "    function toInt144(int256 value) internal pure returns (int144 downcasted) {",
                        "        downcasted = int144(value);",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");",
                        "    function toInt136(int256 value) internal pure returns (int136 downcasted) {",
                        "        downcasted = int136(value);",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");",
                        "    function toInt128(int256 value) internal pure returns (int128 downcasted) {",
                        "        downcasted = int128(value);",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");",
                        "    function toInt120(int256 value) internal pure returns (int120 downcasted) {",
                        "        downcasted = int120(value);",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");",
                        "    function toInt112(int256 value) internal pure returns (int112 downcasted) {",
                        "        downcasted = int112(value);",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");",
                        "    function toInt104(int256 value) internal pure returns (int104 downcasted) {",
                        "        downcasted = int104(value);",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");",
                        "    function toInt96(int256 value) internal pure returns (int96 downcasted) {",
                        "        downcasted = int96(value);",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");",
                        "    function toInt88(int256 value) internal pure returns (int88 downcasted) {",
                        "        downcasted = int88(value);",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");",
                        "    function toInt80(int256 value) internal pure returns (int80 downcasted) {",
                        "        downcasted = int80(value);",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");",
                        "    function toInt72(int256 value) internal pure returns (int72 downcasted) {",
                        "        downcasted = int72(value);",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");",
                        "    function toInt64(int256 value) internal pure returns (int64 downcasted) {",
                        "        downcasted = int64(value);",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");",
                        "    function toInt56(int256 value) internal pure returns (int56 downcasted) {",
                        "        downcasted = int56(value);",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");",
                        "    function toInt48(int256 value) internal pure returns (int48 downcasted) {",
                        "        downcasted = int48(value);",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");",
                        "    function toInt40(int256 value) internal pure returns (int40 downcasted) {",
                        "        downcasted = int40(value);",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");",
                        "    function toInt32(int256 value) internal pure returns (int32 downcasted) {",
                        "        downcasted = int32(value);",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");",
                        "    function toInt24(int256 value) internal pure returns (int24 downcasted) {",
                        "        downcasted = int24(value);",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");",
                        "    function toInt16(int256 value) internal pure returns (int16 downcasted) {",
                        "        downcasted = int16(value);",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");",
                        "    function toInt8(int256 value) internal pure returns (int8 downcasted) {",
                        "        downcasted = int8(value);",
                        "        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");"
                    ],
                    "del": [
                        "    function toInt248(int256 value) internal pure returns (int248) {",
                        "        require(value >= type(int248).min && value <= type(int248).max, \"SafeCast: value doesn't fit in 248 bits\");",
                        "        return int248(value);",
                        "    function toInt240(int256 value) internal pure returns (int240) {",
                        "        require(value >= type(int240).min && value <= type(int240).max, \"SafeCast: value doesn't fit in 240 bits\");",
                        "        return int240(value);",
                        "    function toInt232(int256 value) internal pure returns (int232) {",
                        "        require(value >= type(int232).min && value <= type(int232).max, \"SafeCast: value doesn't fit in 232 bits\");",
                        "        return int232(value);",
                        "    function toInt224(int256 value) internal pure returns (int224) {",
                        "        require(value >= type(int224).min && value <= type(int224).max, \"SafeCast: value doesn't fit in 224 bits\");",
                        "        return int224(value);",
                        "    function toInt216(int256 value) internal pure returns (int216) {",
                        "        require(value >= type(int216).min && value <= type(int216).max, \"SafeCast: value doesn't fit in 216 bits\");",
                        "        return int216(value);",
                        "    function toInt208(int256 value) internal pure returns (int208) {",
                        "        require(value >= type(int208).min && value <= type(int208).max, \"SafeCast: value doesn't fit in 208 bits\");",
                        "        return int208(value);",
                        "    function toInt200(int256 value) internal pure returns (int200) {",
                        "        require(value >= type(int200).min && value <= type(int200).max, \"SafeCast: value doesn't fit in 200 bits\");",
                        "        return int200(value);",
                        "    function toInt192(int256 value) internal pure returns (int192) {",
                        "        require(value >= type(int192).min && value <= type(int192).max, \"SafeCast: value doesn't fit in 192 bits\");",
                        "        return int192(value);",
                        "    function toInt184(int256 value) internal pure returns (int184) {",
                        "        require(value >= type(int184).min && value <= type(int184).max, \"SafeCast: value doesn't fit in 184 bits\");",
                        "        return int184(value);",
                        "    function toInt176(int256 value) internal pure returns (int176) {",
                        "        require(value >= type(int176).min && value <= type(int176).max, \"SafeCast: value doesn't fit in 176 bits\");",
                        "        return int176(value);",
                        "    function toInt168(int256 value) internal pure returns (int168) {",
                        "        require(value >= type(int168).min && value <= type(int168).max, \"SafeCast: value doesn't fit in 168 bits\");",
                        "        return int168(value);",
                        "    function toInt160(int256 value) internal pure returns (int160) {",
                        "        require(value >= type(int160).min && value <= type(int160).max, \"SafeCast: value doesn't fit in 160 bits\");",
                        "        return int160(value);",
                        "    function toInt152(int256 value) internal pure returns (int152) {",
                        "        require(value >= type(int152).min && value <= type(int152).max, \"SafeCast: value doesn't fit in 152 bits\");",
                        "        return int152(value);",
                        "    function toInt144(int256 value) internal pure returns (int144) {",
                        "        require(value >= type(int144).min && value <= type(int144).max, \"SafeCast: value doesn't fit in 144 bits\");",
                        "        return int144(value);",
                        "    function toInt136(int256 value) internal pure returns (int136) {",
                        "        require(value >= type(int136).min && value <= type(int136).max, \"SafeCast: value doesn't fit in 136 bits\");",
                        "        return int136(value);",
                        "    function toInt128(int256 value) internal pure returns (int128) {",
                        "        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");",
                        "        return int128(value);",
                        "    function toInt120(int256 value) internal pure returns (int120) {",
                        "        require(value >= type(int120).min && value <= type(int120).max, \"SafeCast: value doesn't fit in 120 bits\");",
                        "        return int120(value);",
                        "    function toInt112(int256 value) internal pure returns (int112) {",
                        "        require(value >= type(int112).min && value <= type(int112).max, \"SafeCast: value doesn't fit in 112 bits\");",
                        "        return int112(value);",
                        "    function toInt104(int256 value) internal pure returns (int104) {",
                        "        require(value >= type(int104).min && value <= type(int104).max, \"SafeCast: value doesn't fit in 104 bits\");",
                        "        return int104(value);",
                        "    function toInt96(int256 value) internal pure returns (int96) {",
                        "        require(value >= type(int96).min && value <= type(int96).max, \"SafeCast: value doesn't fit in 96 bits\");",
                        "        return int96(value);",
                        "    function toInt88(int256 value) internal pure returns (int88) {",
                        "        require(value >= type(int88).min && value <= type(int88).max, \"SafeCast: value doesn't fit in 88 bits\");",
                        "        return int88(value);",
                        "    function toInt80(int256 value) internal pure returns (int80) {",
                        "        require(value >= type(int80).min && value <= type(int80).max, \"SafeCast: value doesn't fit in 80 bits\");",
                        "        return int80(value);",
                        "    function toInt72(int256 value) internal pure returns (int72) {",
                        "        require(value >= type(int72).min && value <= type(int72).max, \"SafeCast: value doesn't fit in 72 bits\");",
                        "        return int72(value);",
                        "    function toInt64(int256 value) internal pure returns (int64) {",
                        "        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");",
                        "        return int64(value);",
                        "    function toInt56(int256 value) internal pure returns (int56) {",
                        "        require(value >= type(int56).min && value <= type(int56).max, \"SafeCast: value doesn't fit in 56 bits\");",
                        "        return int56(value);",
                        "    function toInt48(int256 value) internal pure returns (int48) {",
                        "        require(value >= type(int48).min && value <= type(int48).max, \"SafeCast: value doesn't fit in 48 bits\");",
                        "        return int48(value);",
                        "    function toInt40(int256 value) internal pure returns (int40) {",
                        "        require(value >= type(int40).min && value <= type(int40).max, \"SafeCast: value doesn't fit in 40 bits\");",
                        "        return int40(value);",
                        "    function toInt32(int256 value) internal pure returns (int32) {",
                        "        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");",
                        "        return int32(value);",
                        "    function toInt24(int256 value) internal pure returns (int24) {",
                        "        require(value >= type(int24).min && value <= type(int24).max, \"SafeCast: value doesn't fit in 24 bits\");",
                        "        return int24(value);",
                        "    function toInt16(int256 value) internal pure returns (int16) {",
                        "        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");",
                        "        return int16(value);",
                        "    function toInt8(int256 value) internal pure returns (int8) {",
                        "        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");",
                        "        return int8(value);"
                    ]
                }
            }
        ],
        " * `ECDSA`: Remove redundant check on the `v` value. ([#3591](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3591))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3591": {
                    "add": [],
                    "del": [
                        "        InvalidSignatureV",
                        "        } else if (error == RecoverError.InvalidSignatureV) {",
                        "            revert(\"ECDSA: invalid signature 'v' value\");",
                        "        if (v != 27 && v != 28) {",
                        "            return (address(0), RecoverError.InvalidSignatureV);",
                        "        }"
                    ]
                }
            }
        ],
        " * `VestingWallet`: add `releasable` getters. ([#3580](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3580))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3580": {
                    "add": [
                        "    /**",
                        "     * @dev Getter for the amount of releasable eth.",
                        "     */",
                        "    function releasable() public view virtual returns (uint256) {",
                        "        return vestedAmount(uint64(block.timestamp)) - released();",
                        "    }",
                        "    /**",
                        "     * @dev Getter for the amount of releasable `token` tokens. `token` should be the address of an",
                        "     * IERC20 contract.",
                        "     */",
                        "    function releasable(address token) public view virtual returns (uint256) {",
                        "        return vestedAmount(token, uint64(block.timestamp)) - released(token);",
                        "    }",
                        "        uint256 amount = releasable();",
                        "        _released += amount;",
                        "        emit EtherReleased(amount);",
                        "        Address.sendValue(payable(beneficiary()), amount);",
                        "        uint256 amount = releasable(token);",
                        "        _erc20Released[token] += amount;",
                        "        emit ERC20Released(token, amount);",
                        "        SafeERC20.safeTransfer(IERC20(token), beneficiary(), amount);"
                    ],
                    "del": [
                        "        uint256 releasable = vestedAmount(uint64(block.timestamp)) - released();",
                        "        _released += releasable;",
                        "        emit EtherReleased(releasable);",
                        "        Address.sendValue(payable(beneficiary()), releasable);",
                        "        uint256 releasable = vestedAmount(token, uint64(block.timestamp)) - released(token);",
                        "        _erc20Released[token] += releasable;",
                        "        emit ERC20Released(token, releasable);",
                        "        SafeERC20.safeTransfer(IERC20(token), beneficiary(), releasable);"
                    ]
                }
            }
        ],
        " * `VestingWallet`: remove unused library `Math.sol`. ([#3605](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3605))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3605": {
                    "add": [],
                    "del": []
                }
            }
        ],
        " * `VestingWallet`: make constructor payable. ([#3665](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3665))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3665": {
                    "add": [
                        "    ) payable {"
                    ],
                    "del": [
                        "    ) {"
                    ]
                }
            }
        ],
        " * `Create2`: optimize address computation by using assembly instead of `abi.encodePacked`. ([#3600](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3600))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3600": {
                    "add": [
                        "    ) internal returns (address addr) {",
                        "    ) internal pure returns (address addr) {",
                        "        assembly {",
                        "            mstore(add(ptr, 0x40), bytecodeHash)",
                        "            mstore(add(ptr, 0x20), salt)",
                        "            mstore8(start, 0xff)",
                        "            addr := keccak256(start, 85)",
                        "        }"
                    ],
                    "del": [
                        "    ) internal returns (address) {",
                        "        address addr;",
                        "        return addr;",
                        "    ) internal pure returns (address) {",
                        "        bytes32 _data = keccak256(abi.encodePacked(bytes1(0xff), deployer, salt, bytecodeHash));",
                        "        return address(uint160(uint256(_data)));"
                    ]
                }
            }
        ],
        " * `Clones`: optimized the assembly to use only the scratch space during deployments, and optimized `predictDeterministicAddress` to use fewer operations. ([#3640](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3640))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3640": {
                    "add": [
                        "            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))",
                        "            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))",
                        "            instance := create(0, 0x09, 0x37)",
                        "            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))",
                        "            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))",
                        "            instance := create2(0, 0x09, 0x37, salt)",
                        "            mstore(add(ptr, 0x38), deployer)",
                        "            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)",
                        "            mstore(add(ptr, 0x14), implementation)",
                        "            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)",
                        "            mstore(add(ptr, 0x58), salt)",
                        "            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))",
                        "            predicted := keccak256(add(ptr, 0x43), 0x55)"
                    ],
                    "del": [
                        "            let ptr := mload(0x40)",
                        "            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)",
                        "            mstore(add(ptr, 0x14), shl(0x60, implementation))",
                        "            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)",
                        "            instance := create(0, ptr, 0x37)",
                        "            let ptr := mload(0x40)",
                        "            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)",
                        "            mstore(add(ptr, 0x14), shl(0x60, implementation))",
                        "            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)",
                        "            instance := create2(0, ptr, 0x37, salt)",
                        "            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)",
                        "            mstore(add(ptr, 0x14), shl(0x60, implementation))",
                        "            mstore(add(ptr, 0x28), 0x5af43d82803e903d91602b57fd5bf3ff00000000000000000000000000000000)",
                        "            mstore(add(ptr, 0x38), shl(0x60, deployer))",
                        "            mstore(add(ptr, 0x4c), salt)",
                        "            mstore(add(ptr, 0x6c), keccak256(ptr, 0x37))",
                        "            predicted := keccak256(add(ptr, 0x37), 0x55)"
                    ]
                }
            }
        ],
        " * `Arrays`: Add `unsafeAccess` functions that allow reading and writing to an element in a storage array bypassing Solidity's \"out-of-bounds\" check. ([#3589](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3589))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3589": {
                    "add": [
                        "contract Uint256ArraysMock {",
                        "    using Arrays for uint256[];",
                        "    uint256[] private _array;",
                        "    constructor(uint256[] memory array) {",
                        "        _array = array;",
                        "    }",
                        "    function findUpperBound(uint256 element) external view returns (uint256) {",
                        "        return _array.findUpperBound(element);",
                        "    }",
                        "    function unsafeAccess(uint256 pos) external view returns (uint256) {",
                        "        return _array.unsafeAccess(pos).value;",
                        "    }",
                        "}",
                        "contract AddressArraysMock {",
                        "    using Arrays for address[];",
                        "    address[] private _array;",
                        "    constructor(address[] memory array) {",
                        "        _array = array;",
                        "    }",
                        "    function unsafeAccess(uint256 pos) external view returns (address) {",
                        "        return _array.unsafeAccess(pos).value;",
                        "    }",
                        "}",
                        "contract Bytes32ArraysMock {",
                        "    using Arrays for bytes32[];",
                        "    bytes32[] private _array;",
                        "    constructor(bytes32[] memory array) {",
                        "        _array = array;",
                        "    }",
                        "    function unsafeAccess(uint256 pos) external view returns (bytes32) {",
                        "        return _array.unsafeAccess(pos).value;",
                        "    }",
                        "}",
                        "contract CheckpointsMock {",
                        "    using Checkpoints for Checkpoints.History;",
                        "    Checkpoints.History private _totalCheckpoints;",
                        "    function latest() public view returns (uint256) {",
                        "        return _totalCheckpoints.latest();",
                        "    }",
                        "    function push(uint256 value) public returns (uint256, uint256) {",
                        "        return _totalCheckpoints.push(value);",
                        "    }",
                        "    function getAtBlock(uint256 blockNumber) public view returns (uint256) {",
                        "        return _totalCheckpoints.getAtBlock(blockNumber);",
                        "    }",
                        "    function getAtRecentBlock(uint256 blockNumber) public view returns (uint256) {",
                        "        return _totalCheckpoints.getAtRecentBlock(blockNumber);",
                        "    }",
                        "    function length() public view returns (uint256) {",
                        "        return _totalCheckpoints._checkpoints.length;",
                        "    }",
                        "}",
                        "contract Checkpoints224Mock {",
                        "    using Checkpoints for Checkpoints.Trace224;",
                        "    Checkpoints.Trace224 private _totalCheckpoints;",
                        "    function latest() public view returns (uint224) {",
                        "        return _totalCheckpoints.latest();",
                        "    }",
                        "    function push(uint32 key, uint224 value) public returns (uint224, uint224) {",
                        "        return _totalCheckpoints.push(key, value);",
                        "    }",
                        "    function lowerLookup(uint32 key) public view returns (uint224) {",
                        "        return _totalCheckpoints.lowerLookup(key);",
                        "    }",
                        "    function upperLookup(uint32 key) public view returns (uint224) {",
                        "        return _totalCheckpoints.upperLookup(key);",
                        "    }",
                        "    function upperLookupRecent(uint32 key) public view returns (uint224) {",
                        "        return _totalCheckpoints.upperLookupRecent(key);",
                        "    }",
                        "    function length() public view returns (uint256) {",
                        "        return _totalCheckpoints._checkpoints.length;",
                        "    }",
                        "}",
                        "contract Checkpoints160Mock {",
                        "    using Checkpoints for Checkpoints.Trace160;",
                        "    Checkpoints.Trace160 private _totalCheckpoints;",
                        "    function latest() public view returns (uint160) {",
                        "        return _totalCheckpoints.latest();",
                        "    }",
                        "    function push(uint96 key, uint160 value) public returns (uint160, uint160) {",
                        "        return _totalCheckpoints.push(key, value);",
                        "    }",
                        "    function lowerLookup(uint96 key) public view returns (uint160) {",
                        "        return _totalCheckpoints.lowerLookup(key);",
                        "    }",
                        "    function upperLookup(uint96 key) public view returns (uint160) {",
                        "        return _totalCheckpoints.upperLookup(key);",
                        "    }",
                        "    function upperLookupRecent(uint96 key) public view returns (uint224) {",
                        "        return _totalCheckpoints.upperLookupRecent(key);",
                        "    }",
                        "    function length() public view returns (uint256) {",
                        "        return _totalCheckpoints._checkpoints.length;",
                        "    }",
                        "}",
                        "    using StorageSlot for bytes32;",
                        "            if (unsafeAccess(array, mid).value > element) {",
                        "        if (low > 0 && unsafeAccess(array, low - 1).value == element) {",
                        "    /**",
                        "     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.",
                        "     *",
                        "     * WARNING: Only use if you are certain `pos` is lower than the array length.",
                        "     */",
                        "    function unsafeAccess(address[] storage arr, uint256 pos) internal pure returns (StorageSlot.AddressSlot storage) {",
                        "        bytes32 slot;",
                        "        assembly {",
                        "            mstore(0, arr.slot)",
                        "            slot := add(keccak256(0, 0x20), pos)",
                        "        }",
                        "        return slot.getAddressSlot();",
                        "    }",
                        "    /**",
                        "     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.",
                        "     *",
                        "     * WARNING: Only use if you are certain `pos` is lower than the array length.",
                        "     */",
                        "    function unsafeAccess(bytes32[] storage arr, uint256 pos) internal pure returns (StorageSlot.Bytes32Slot storage) {",
                        "        bytes32 slot;",
                        "        assembly {",
                        "            mstore(0, arr.slot)",
                        "            slot := add(keccak256(0, 0x20), pos)",
                        "        }",
                        "        return slot.getBytes32Slot();",
                        "    }",
                        "    /**",
                        "     * @dev Access an array in an \"unsafe\" way. Skips solidity \"index-out-of-range\" check.",
                        "     *",
                        "     * WARNING: Only use if you are certain `pos` is lower than the array length.",
                        "     */",
                        "    function unsafeAccess(uint256[] storage arr, uint256 pos) internal pure returns (StorageSlot.Uint256Slot storage) {",
                        "        bytes32 slot;",
                        "        assembly {",
                        "            mstore(0, arr.slot)",
                        "            slot := add(keccak256(0, 0x20), pos)",
                        "        }",
                        "        return slot.getUint256Slot();",
                        "    }",
                        "    struct History {",
                        "        Checkpoint[] _checkpoints;",
                        "    }",
                        "        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
                        "        uint32 key = SafeCast.toUint32(blockNumber);",
                        "        uint256 length = self._checkpoints.length;",
                        "        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, length);",
                        "        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
                        "    }",
                        "    /**",
                        "     * @dev Returns the value at a given block number. If a checkpoint is not available at that block, the closest one",
                        "     * before it is returned, or zero otherwise. Similarly to {upperLookup} but optimized for the case when the search",
                        "     * key is known to be recent.",
                        "     */",
                        "    function getAtRecentBlock(History storage self, uint256 blockNumber) internal view returns (uint256) {",
                        "        require(blockNumber < block.number, \"Checkpoints: block not yet mined\");",
                        "        uint32 key = SafeCast.toUint32(blockNumber);",
                        "        uint256 length = self._checkpoints.length;",
                        "        uint256 offset = 1;",
                        "        while (offset <= length && _unsafeAccess(self._checkpoints, length - offset)._blockNumber > key) {",
                        "            offset <<= 1;",
                        "        uint256 low = offset < length ? length - offset : 0;",
                        "        uint256 high = length - (offset >> 1);",
                        "        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);",
                        "        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
                        "        return _insert(self._checkpoints, SafeCast.toUint32(block.number), SafeCast.toUint224(value));",
                        "    /**",
                        "     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,",
                        "     * or by updating the last one.",
                        "     */",
                        "    function _insert(",
                        "        Checkpoint[] storage self,",
                        "        uint32 key,",
                        "        uint224 value",
                        "    ) private returns (uint224, uint224) {",
                        "        uint256 pos = self.length;",
                        "        if (pos > 0) {",
                        "            Checkpoint memory last = _unsafeAccess(self, pos - 1);",
                        "            require(last._blockNumber <= key, \"Checkpoint: invalid key\");",
                        "            if (last._blockNumber == key) {",
                        "                _unsafeAccess(self, pos - 1)._value = value;",
                        "            } else {",
                        "                self.push(Checkpoint({_blockNumber: key, _value: value}));",
                        "            }",
                        "            return (last._value, value);",
                        "        } else {",
                        "            self.push(Checkpoint({_blockNumber: key, _value: value}));",
                        "            return (0, value);",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Return the index of the oldest checkpoint whose key is greater than the search key, or `high` if there is none.",
                        "     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.",
                        "     *",
                        "     * WARNING: `high` should not be greater than the array's length.",
                        "     */",
                        "    function _upperBinaryLookup(",
                        "        Checkpoint[] storage self,",
                        "        uint32 key,",
                        "        uint256 low,",
                        "        uint256 high",
                        "    ) private view returns (uint256) {",
                        "        while (low < high) {",
                        "            uint256 mid = Math.average(low, high);",
                        "            if (_unsafeAccess(self, mid)._blockNumber > key) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }",
                        "        }",
                        "        return high;",
                        "    }",
                        "    /**",
                        "     * @dev Return the index of the oldest checkpoint whose key is greater or equal than the search key, or `high` if there is none.",
                        "     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.",
                        "     *",
                        "     * WARNING: `high` should not be greater than the array's length.",
                        "     */",
                        "    function _lowerBinaryLookup(",
                        "        Checkpoint[] storage self,",
                        "        uint32 key,",
                        "        uint256 low,",
                        "        uint256 high",
                        "    ) private view returns (uint256) {",
                        "        while (low < high) {",
                        "            uint256 mid = Math.average(low, high);",
                        "            if (_unsafeAccess(self, mid)._blockNumber < key) {",
                        "                low = mid + 1;",
                        "            } else {",
                        "                high = mid;",
                        "            }",
                        "        }",
                        "        return high;",
                        "    }",
                        "    function _unsafeAccess(Checkpoint[] storage self, uint256 pos) private view returns (Checkpoint storage result) {",
                        "        assembly {",
                        "            mstore(0, self.slot)",
                        "            result.slot := add(keccak256(0, 0x20), pos)",
                        "        }",
                        "    }",
                        "    struct Trace224 {",
                        "        Checkpoint224[] _checkpoints;",
                        "    }",
                        "    struct Checkpoint224 {",
                        "        uint32 _key;",
                        "        uint224 _value;",
                        "    }",
                        "    /**",
                        "     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.",
                        "     */",
                        "    function latest(Trace224 storage self) internal view returns (uint224) {",
                        "        uint256 pos = self._checkpoints.length;",
                        "        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
                        "    }",
                        "    /**",
                        "     * @dev Pushes a (`key`, `value`) pair into a Trace224 so that it is stored as the checkpoint.",
                        "     *",
                        "     * Returns previous value and new value.",
                        "     */",
                        "    function push(",
                        "        Trace224 storage self,",
                        "        uint32 key,",
                        "        uint224 value",
                        "    ) internal returns (uint224, uint224) {",
                        "        return _insert(self._checkpoints, key, value);",
                        "    }",
                        "    /**",
                        "     * @dev Returns the value in the oldest checkpoint with key greater or equal than the search key, or zero if there is none.",
                        "     */",
                        "    function lowerLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {",
                        "        uint256 length = self._checkpoints.length;",
                        "        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, length);",
                        "        return pos == length ? 0 : _unsafeAccess(self._checkpoints, pos)._value;",
                        "    }",
                        "    /**",
                        "     * @dev Returns the value in the most recent checkpoint with key lower or equal than the search key.",
                        "     */",
                        "    function upperLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {",
                        "        uint256 length = self._checkpoints.length;",
                        "        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, length);",
                        "        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
                        "    }",
                        "    /**",
                        "     * @dev Returns the value in the most recent checkpoint with key lower or equal than the search key (similarly to",
                        "     * {upperLookup}), optimized for the case when the search key is known to be recent.",
                        "     */",
                        "    function upperLookupRecent(Trace224 storage self, uint32 key) internal view returns (uint224) {",
                        "        uint256 length = self._checkpoints.length;",
                        "        uint256 offset = 1;",
                        "        while (offset <= length && _unsafeAccess(self._checkpoints, length - offset)._key > key) {",
                        "            offset <<= 1;",
                        "        }",
                        "        uint256 low = offset < length ? length - offset : 0;",
                        "        uint256 high = length - (offset >> 1);",
                        "        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);",
                        "        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
                        "    }",
                        "    /**",
                        "     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,",
                        "     * or by updating the last one.",
                        "     */",
                        "    function _insert(",
                        "        Checkpoint224[] storage self,",
                        "        uint32 key,",
                        "        uint224 value",
                        "    ) private returns (uint224, uint224) {",
                        "        uint256 pos = self.length;",
                        "        if (pos > 0) {",
                        "            Checkpoint224 memory last = _unsafeAccess(self, pos - 1);",
                        "            require(last._key <= key, \"Checkpoint: invalid key\");",
                        "            if (last._key == key) {",
                        "                _unsafeAccess(self, pos - 1)._value = value;",
                        "            } else {",
                        "                self.push(Checkpoint224({_key: key, _value: value}));",
                        "            }",
                        "            return (last._value, value);",
                        "        } else {",
                        "            self.push(Checkpoint224({_key: key, _value: value}));",
                        "            return (0, value);",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Return the index of the oldest checkpoint whose key is greater than the search key, or `high` if there is none.",
                        "     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.",
                        "     *",
                        "     * WARNING: `high` should not be greater than the array's length.",
                        "     */",
                        "    function _upperBinaryLookup(",
                        "        Checkpoint224[] storage self,",
                        "        uint32 key,",
                        "        uint256 low,",
                        "        uint256 high",
                        "    ) private view returns (uint256) {",
                        "        while (low < high) {",
                        "            uint256 mid = Math.average(low, high);",
                        "            if (_unsafeAccess(self, mid)._key > key) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }",
                        "        }",
                        "        return high;",
                        "    }",
                        "    /**",
                        "     * @dev Return the index of the oldest checkpoint whose key is greater or equal than the search key, or `high` if there is none.",
                        "     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.",
                        "     *",
                        "     * WARNING: `high` should not be greater than the array's length.",
                        "     */",
                        "    function _lowerBinaryLookup(",
                        "        Checkpoint224[] storage self,",
                        "        uint32 key,",
                        "        uint256 low,",
                        "        uint256 high",
                        "    ) private view returns (uint256) {",
                        "        while (low < high) {",
                        "            uint256 mid = Math.average(low, high);",
                        "            if (_unsafeAccess(self, mid)._key < key) {",
                        "                low = mid + 1;",
                        "            } else {",
                        "                high = mid;",
                        "            }",
                        "        }",
                        "        return high;",
                        "    }",
                        "    function _unsafeAccess(Checkpoint224[] storage self, uint256 pos)",
                        "        private",
                        "        view",
                        "        returns (Checkpoint224 storage result)",
                        "    {",
                        "        assembly {",
                        "            mstore(0, self.slot)",
                        "            result.slot := add(keccak256(0, 0x20), pos)",
                        "        }",
                        "    }",
                        "    struct Trace160 {",
                        "        Checkpoint160[] _checkpoints;",
                        "    }",
                        "    struct Checkpoint160 {",
                        "        uint96 _key;",
                        "        uint160 _value;",
                        "    }",
                        "    /**",
                        "     * @dev Returns the value in the most recent checkpoint, or zero if there are no checkpoints.",
                        "     */",
                        "    function latest(Trace160 storage self) internal view returns (uint160) {",
                        "        uint256 pos = self._checkpoints.length;",
                        "        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
                        "    }",
                        "    /**",
                        "     * @dev Pushes a (`key`, `value`) pair into a Trace160 so that it is stored as the checkpoint.",
                        "     *",
                        "     * Returns previous value and new value.",
                        "     */",
                        "    function push(",
                        "        Trace160 storage self,",
                        "        uint96 key,",
                        "        uint160 value",
                        "    ) internal returns (uint160, uint160) {",
                        "        return _insert(self._checkpoints, key, value);",
                        "    }",
                        "    /**",
                        "     * @dev Returns the value in the oldest checkpoint with key greater or equal than the search key, or zero if there is none.",
                        "     */",
                        "    function lowerLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {",
                        "        uint256 length = self._checkpoints.length;",
                        "        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, length);",
                        "        return pos == length ? 0 : _unsafeAccess(self._checkpoints, pos)._value;",
                        "    }",
                        "    /**",
                        "     * @dev Returns the value in the most recent checkpoint with key lower or equal than the search key.",
                        "     */",
                        "    function upperLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {",
                        "        uint256 length = self._checkpoints.length;",
                        "        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, length);",
                        "        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
                        "    }",
                        "    /**",
                        "     * @dev Returns the value in the most recent checkpoint with key lower or equal than the search key (similarly to",
                        "     * {upperLookup}), optimized for the case when the search key is known to be recent.",
                        "     */",
                        "    function upperLookupRecent(Trace160 storage self, uint96 key) internal view returns (uint160) {",
                        "        uint256 length = self._checkpoints.length;",
                        "        uint256 offset = 1;",
                        "        while (offset <= length && _unsafeAccess(self._checkpoints, length - offset)._key > key) {",
                        "            offset <<= 1;",
                        "        }",
                        "        uint256 low = offset < length ? length - offset : 0;",
                        "        uint256 high = length - (offset >> 1);",
                        "        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);",
                        "        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;",
                        "    }",
                        "    /**",
                        "     * @dev Pushes a (`key`, `value`) pair into an ordered list of checkpoints, either by inserting a new checkpoint,",
                        "     * or by updating the last one.",
                        "     */",
                        "    function _insert(",
                        "        Checkpoint160[] storage self,",
                        "        uint96 key,",
                        "        uint160 value",
                        "    ) private returns (uint160, uint160) {",
                        "        uint256 pos = self.length;",
                        "        if (pos > 0) {",
                        "            Checkpoint160 memory last = _unsafeAccess(self, pos - 1);",
                        "            require(last._key <= key, \"Checkpoint: invalid key\");",
                        "            if (last._key == key) {",
                        "                _unsafeAccess(self, pos - 1)._value = value;",
                        "            } else {",
                        "                self.push(Checkpoint160({_key: key, _value: value}));",
                        "            }",
                        "            return (last._value, value);",
                        "        } else {",
                        "            self.push(Checkpoint160({_key: key, _value: value}));",
                        "            return (0, value);",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Return the index of the oldest checkpoint whose key is greater than the search key, or `high` if there is none.",
                        "     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.",
                        "     *",
                        "     * WARNING: `high` should not be greater than the array's length.",
                        "     */",
                        "    function _upperBinaryLookup(",
                        "        Checkpoint160[] storage self,",
                        "        uint96 key,",
                        "        uint256 low,",
                        "        uint256 high",
                        "    ) private view returns (uint256) {",
                        "        while (low < high) {",
                        "            uint256 mid = Math.average(low, high);",
                        "            if (_unsafeAccess(self, mid)._key > key) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }",
                        "        }",
                        "        return high;",
                        "    }",
                        "    /**",
                        "     * @dev Return the index of the oldest checkpoint whose key is greater or equal than the search key, or `high` if there is none.",
                        "     * `low` and `high` define a section where to do the search, with inclusive `low` and exclusive `high`.",
                        "     *",
                        "     * WARNING: `high` should not be greater than the array's length.",
                        "     */",
                        "    function _lowerBinaryLookup(",
                        "        Checkpoint160[] storage self,",
                        "        uint96 key,",
                        "        uint256 low,",
                        "        uint256 high",
                        "    ) private view returns (uint256) {",
                        "        while (low < high) {",
                        "            uint256 mid = Math.average(low, high);",
                        "            if (_unsafeAccess(self, mid)._key < key) {",
                        "                low = mid + 1;",
                        "            } else {",
                        "                high = mid;",
                        "            }",
                        "        }",
                        "        return high;",
                        "    }",
                        "    function _unsafeAccess(Checkpoint160[] storage self, uint256 pos)",
                        "        private",
                        "        view",
                        "        returns (Checkpoint160 storage result)",
                        "    {",
                        "        assembly {",
                        "            mstore(0, self.slot)",
                        "            result.slot := add(keccak256(0, 0x20), pos)",
                        "        }",
                        "    }"
                    ],
                    "del": [
                        "contract ArraysImpl {",
                        "    using Arrays for uint256[];",
                        "    uint256[] private _array;",
                        "    constructor(uint256[] memory array) {",
                        "        _array = array;",
                        "    }",
                        "    function findUpperBound(uint256 element) external view returns (uint256) {",
                        "        return _array.findUpperBound(element);",
                        "    }",
                        "}",
                        "contract CheckpointsImpl {",
                        "    using Checkpoints for Checkpoints.History;",
                        "    Checkpoints.History private _totalCheckpoints;",
                        "    function latest() public view returns (uint256) {",
                        "        return _totalCheckpoints.latest();",
                        "    }",
                        "    function getAtBlock(uint256 blockNumber) public view returns (uint256) {",
                        "        return _totalCheckpoints.getAtBlock(blockNumber);",
                        "    }",
                        "    function push(uint256 value) public returns (uint256, uint256) {",
                        "        return _totalCheckpoints.push(value);",
                        "    }",
                        "    function length() public view returns (uint256) {",
                        "        return _totalCheckpoints._checkpoints.length;",
                        "    }",
                        "}",
                        "            if (array[mid] > element) {",
                        "        if (low > 0 && array[low - 1] == element) {",
                        "    struct History {",
                        "        Checkpoint[] _checkpoints;",
                        "    }",
                        "        return pos == 0 ? 0 : self._checkpoints[pos - 1]._value;",
                        "        uint256 high = self._checkpoints.length;",
                        "        uint256 low = 0;",
                        "        while (low < high) {",
                        "            uint256 mid = Math.average(low, high);",
                        "            if (self._checkpoints[mid]._blockNumber > blockNumber) {",
                        "                high = mid;",
                        "            } else {",
                        "                low = mid + 1;",
                        "            }",
                        "        return high == 0 ? 0 : self._checkpoints[high - 1]._value;",
                        "        uint256 pos = self._checkpoints.length;",
                        "        uint256 old = latest(self);",
                        "        if (pos > 0 && self._checkpoints[pos - 1]._blockNumber == block.number) {",
                        "            self._checkpoints[pos - 1]._value = SafeCast.toUint224(value);",
                        "        } else {",
                        "            self._checkpoints.push(",
                        "                Checkpoint({_blockNumber: SafeCast.toUint32(block.number), _value: SafeCast.toUint224(value)})",
                        "            );",
                        "        }",
                        "        return (old, value);"
                    ]
                }
            }
        ],
        " * `Math` and `SignedMath`: optimize function `max` by using `>` instead of `>=`. ([#3679](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3679))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3679": {
                    "add": [
                        "        return a > b ? a : b;",
                        "        return a > b ? a : b;"
                    ],
                    "del": [
                        "        return a >= b ? a : b;",
                        "        return a >= b ? a : b;"
                    ]
                }
            }
        ],
        " * `TimelockController`: During deployment, the TimelockController used to grant the `TIMELOCK_ADMIN_ROLE` to the deployer and to the timelock itself. The deployer was then expected to renounce this role once configuration of the timelock is over. Failing to renounce that role allows the deployer to change the timelock permissions (but not to bypass the delay for any time-locked actions). The role is no longer given to the deployer by default. A new parameter `admin` can be set to a non-zero address to grant the admin role during construction (to the deployer or any other address). Just like previously, this admin role should be renounced after configuration. If this param is given `address(0)`, the role is not allocated and doesn't need to be revoked. In any case, the timelock itself continues to have this role.\r": [],
        "+import \"@openzeppelin/contracts/utils/cryptography/EIP712.sol\";\r": [],
        "-import \"@openzeppelin/contracts/token/ERC721/extensions/draft-ERC721Votes.sol\";\r": [],
        "+import \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Votes.sol\";\r": [],
        "ERC-721 integrators that interpret contract state from events should make sure that they implement the clearing of approval that is implicit in every transfer according to the EIP. Previous versions of OpenZeppelin Contracts emitted an explicit `Approval` event even though it was not required by the specification, and this is no longer the case.\r": [],
        "With the new `ERC721Consecutive` extension, the internal workings of `ERC721` are slightly changed. Custom extensions to ERC721 should be reviewed to ensure they remain correct. The internal functions that should be considered are `_ownerOf` (new), `_beforeTokenTransfer`, and `_afterTokenTransfer`.\r": []
    },
    "4.8.0-rc.1": {
        "- \u231b **TimelockController:** Add a new admin constructor parameter that is assigned the admin role instead of the deployer account.\r": [],
        "`TimelockController`: During deployment, the TimelockController used to grant the `TIMELOCK_ADMIN_ROLE` to the deployer and to the timelock itself. The deployer was then expected to renounce this role once configuration of the timelock is over. Failing to renounce that role allows the deployer to change the timelock permissions (but not to bypass the delay for any time-locked actions). The role is no longer given to the deployer by default. A new parameter `admin` can be set to a non-zero address to grant the admin role during construction (to the deployer or any other address). Just like previously, this admin role should be renounced after configuration. If this param is given `address(0)`, the role is not allocated and doesn't need to be revoked. In any case, the timelock itself continues to have this role.\r": []
    },
    "4.8.0-rc.0": {
        "To reward issues found we have a **[bug bounty](https://immunefi.com/bounty/openzeppelin/) going up to $25,000** with an **additional reward** for any findings introduced in this release candidate.\r": []
    },
    "4.7.3": {
        ":warning: This is a patch for a high severity issue. For more information [visit the security advisory](https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-4h98-2769-gh6h).\r": [
            "https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-4h98-2769-gh6h"
        ],
        " * `ECDSA`: `recover(bytes32,bytes)` and `tryRecover(bytes32,bytes)` no longer accept compact signatures to prevent malleability. Compact signature support remains available using `recover(bytes32,bytes32,bytes32)` and `tryRecover(bytes32,bytes32,bytes32)`.": []
    },
    "4.7.2": {
        ":warning: This is a patch for three issues, including a high severity issue in `GovernorVotesQuorumFraction`. For more information visit the security advisories ([1](https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-xrc4-737v-9q75), [2](https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-7grf-83vw-6f5x), [3](https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-9j3m-g383-29qr)).\r": [
            "https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-xrc4-737v-9q75",
            "https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-7grf-83vw-6f5x",
            "https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-9j3m-g383-29qr"
        ],
        " 1. `GovernorVotesQuorumFraction`: Fixed quorum updates so they do not affect past proposals that failed due to lack of quorum. ([#3561](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3561))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3561": {
                    "add": [
                        "    using Checkpoints for Checkpoints.History;",
                        "    Checkpoints.History private _quorumNumeratorHistory;",
                        "        return _quorumNumeratorHistory._checkpoints.length == 0 ? _quorumNumerator : _quorumNumeratorHistory.latest();",
                        "    }",
                        "    /**",
                        "     * @dev Returns the quorum numerator at a specific block number. See {quorumDenominator}.",
                        "     */",
                        "    function quorumNumerator(uint256 blockNumber) public view virtual returns (uint256) {",
                        "        uint256 length = _quorumNumeratorHistory._checkpoints.length;",
                        "        if (length == 0) {",
                        "            return _quorumNumerator;",
                        "        }",
                        "        Checkpoints.Checkpoint memory latest = _quorumNumeratorHistory._checkpoints[length - 1];",
                        "        if (latest._blockNumber <= blockNumber) {",
                        "            return latest._value;",
                        "        }",
                        "        return _quorumNumeratorHistory.getAtBlock(blockNumber);",
                        "        return (token.getPastTotalSupply(blockNumber) * quorumNumerator(blockNumber)) / quorumDenominator();",
                        "        uint256 oldQuorumNumerator = quorumNumerator();",
                        "        if (oldQuorumNumerator != 0 && _quorumNumeratorHistory._checkpoints.length == 0) {",
                        "            _quorumNumeratorHistory._checkpoints.push(",
                        "                Checkpoints.Checkpoint({_blockNumber: 0, _value: SafeCast.toUint224(oldQuorumNumerator)})",
                        "            );",
                        "        }",
                        "        _quorumNumeratorHistory.push(newQuorumNumerator);"
                    ],
                    "del": [
                        "    uint256 private _quorumNumerator;",
                        "        return _quorumNumerator;",
                        "        return (token.getPastTotalSupply(blockNumber) * quorumNumerator()) / quorumDenominator();",
                        "        uint256 oldQuorumNumerator = _quorumNumerator;",
                        "        _quorumNumerator = newQuorumNumerator;"
                    ]
                }
            }
        ],
        " 2. `ERC165Checker`: Added protection against large returndata. ([#3587](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3587))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3587": {
                    "add": [
                        "contract ERC165ReturnBombMock is IERC165 {",
                        "    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {",
                        "        if (interfaceId == type(IERC165).interfaceId) {",
                        "            assembly {",
                        "                mstore(0, 1)",
                        "            }",
                        "        }",
                        "        assembly {",
                        "            return(0, 101500)",
                        "        }",
                        "    }",
                        "}",
                        "        bool success;",
                        "        uint256 returnSize;",
                        "        uint256 returnValue;",
                        "        assembly {",
                        "            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)",
                        "            returnSize := returndatasize()",
                        "            returnValue := mload(0x00)",
                        "        }",
                        "        return success && returnSize >= 0x20 && returnValue > 0;"
                    ],
                    "del": [
                        "        (bool success, bytes memory result) = account.staticcall{gas: 30000}(encodedParams);",
                        "        if (result.length < 32) return false;",
                        "        return success && abi.decode(result, (uint256)) > 0;"
                    ]
                }
            }
        ],
        " 3. `LibArbitrumL2`, `CrossChainEnabledArbitrumL2`: Fixed detection of cross-chain calls for EOAs. Previously, calls from EOAs would be classified as cross-chain calls. ([#3578](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3578))": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3578": {
                    "add": [
                        "        return ArbitrumL2_Bridge(arbsys).wasMyCallersAddressAliased();",
                        "        return ArbitrumL2_Bridge(arbsys).myCallersAddressWithoutAliasing();",
                        "    function wasMyCallersAddressAliased() public view returns (bool) {"
                    ],
                    "del": [
                        "        return ArbitrumL2_Bridge(arbsys).isTopLevelCall();",
                        "        return",
                        "            ArbitrumL2_Bridge(arbsys).wasMyCallersAddressAliased()",
                        "                ? ArbitrumL2_Bridge(arbsys).myCallersAddressWithoutAliasing()",
                        "                : msg.sender;",
                        "    function isTopLevelCall() public view returns (bool) {",
                        "    function wasMyCallersAddressAliased() public pure returns (bool) {",
                        "        return true;",
                        "    }"
                    ]
                }
            }
        ]
    },
    "4.7.1": {
        ":warning: This is a patch for a medium severity issue affecting `SignatureChecker` and a high severity issue affecting `ERC165Checker`. For more information visit the security advisories ([1](https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-4g63-c64m-25w9), [2](https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-qh9x-gcfh-pcrw)).\r": [
            "https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-4g63-c64m-25w9",
            "https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-qh9x-gcfh-pcrw"
        ],
        " * `SignatureChecker`: Fix an issue that causes `isValidSignatureNow` to revert when the target contract returns ill-encoded data. ([#3552](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3552))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3552": {
                    "add": [
                        "contract ERC1271MaliciousMock is IERC1271 {",
                        "    function isValidSignature(bytes32, bytes memory) public pure override returns (bytes4) {",
                        "        assembly {",
                        "            mstore(0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)",
                        "            return(0, 32)",
                        "        }",
                        "    }",
                        "}",
                        "contract ERC165MaliciousData {",
                        "    function supportsInterface(bytes4) public view returns (bool) {",
                        "        assembly {",
                        "            mstore(0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)",
                        "            return(0, 32)",
                        "        }",
                        "    }",
                        "}",
                        "        return (success &&",
                        "            result.length == 32 &&",
                        "            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));",
                        "        return success && abi.decode(result, (uint256)) > 0;"
                    ],
                    "del": [
                        "        return (success && result.length == 32 && abi.decode(result, (bytes4)) == IERC1271.isValidSignature.selector);",
                        "        return success && abi.decode(result, (bool));"
                    ]
                }
            }
        ],
        " * `ERC165Checker`: Fix an issue that causes `supportsInterface` to revert when the target contract returns ill-encoded data. ([#3552](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3552))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3552": {
                    "add": [
                        "contract ERC1271MaliciousMock is IERC1271 {",
                        "    function isValidSignature(bytes32, bytes memory) public pure override returns (bytes4) {",
                        "        assembly {",
                        "            mstore(0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)",
                        "            return(0, 32)",
                        "        }",
                        "    }",
                        "}",
                        "contract ERC165MaliciousData {",
                        "    function supportsInterface(bytes4) public view returns (bool) {",
                        "        assembly {",
                        "            mstore(0, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)",
                        "            return(0, 32)",
                        "        }",
                        "    }",
                        "}",
                        "        return (success &&",
                        "            result.length == 32 &&",
                        "            abi.decode(result, (bytes32)) == bytes32(IERC1271.isValidSignature.selector));",
                        "        return success && abi.decode(result, (uint256)) > 0;"
                    ],
                    "del": [
                        "        return (success && result.length == 32 && abi.decode(result, (bytes4)) == IERC1271.isValidSignature.selector);",
                        "        return success && abi.decode(result, (bool));"
                    ]
                }
            }
        ]
    },
    "4.7.0": {
        " * `SafeERC20`: add `safePermit` as mitigation against phantom permit functions. ([#3280](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3280))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3280": {
                    "add": [
                        "contract ERC20PermitNoRevertMock is",
                        "    ERC20(\"ERC20PermitNoRevertMock\", \"ERC20PermitNoRevertMock\"),",
                        "    ERC20Permit(\"ERC20PermitNoRevertMock\")",
                        "{",
                        "    function getChainId() external view returns (uint256) {",
                        "        return block.chainid;",
                        "    }",
                        "    function permitThatMayRevert(",
                        "        address owner,",
                        "        address spender,",
                        "        uint256 value,",
                        "        uint256 deadline,",
                        "        uint8 v,",
                        "        bytes32 r,",
                        "        bytes32 s",
                        "    ) public virtual {",
                        "        super.permit(owner, spender, value, deadline, v, r, s);",
                        "    }",
                        "    function permit(",
                        "        address owner,",
                        "        address spender,",
                        "        uint256 value,",
                        "        uint256 deadline,",
                        "        uint8 v,",
                        "        bytes32 r,",
                        "        bytes32 s",
                        "    ) public virtual override {",
                        "        try this.permitThatMayRevert(owner, spender, value, deadline, v, r, s) {",
                        "        } catch {",
                        "        }",
                        "    }",
                        "}",
                        "    function permit(",
                        "        address owner,",
                        "        address spender,",
                        "        uint256 value,",
                        "        uint256 deadline,",
                        "        uint8 v,",
                        "        bytes32 r,",
                        "        bytes32 s",
                        "    ) public {",
                        "        SafeERC20.safePermit(IERC20Permit(address(_token)), owner, spender, value, deadline, v, r, s);",
                        "    }",
                        "    function safePermit(",
                        "        IERC20Permit token,",
                        "        address owner,",
                        "        address spender,",
                        "        uint256 value,",
                        "        uint256 deadline,",
                        "        uint8 v,",
                        "        bytes32 r,",
                        "        bytes32 s",
                        "    ) internal {",
                        "        uint256 nonceBefore = token.nonces(owner);",
                        "        token.permit(owner, spender, value, deadline, v, r, s);",
                        "        uint256 nonceAfter = token.nonces(owner);",
                        "        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");",
                        "    }"
                    ],
                    "del": []
                }
            }
        ],
        " * `MerkleProof`: add `multiProofVerify` to prove multiple values are part of a Merkle tree. ([#3276](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3276))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3276": {
                    "add": [
                        "    function multiProofVerify(",
                        "        bytes32 root,",
                        "        bytes32[] memory leafs,",
                        "        bytes32[] memory proofs,",
                        "        bool[] memory proofFlag",
                        "    ) public pure returns (bool) {",
                        "        return MerkleProof.multiProofVerify(root, leafs, proofs, proofFlag);",
                        "    }",
                        "    function processMultiProof(",
                        "        bytes32[] memory leafs,",
                        "        bytes32[] memory proofs,",
                        "        bool[] memory proofFlag",
                        "    ) public pure returns (bytes32) {",
                        "        return MerkleProof.processMultiProof(leafs, proofs, proofFlag);",
                        "    }",
                        "            computedHash = _hashPair(computedHash, proof[i]);",
                        "    /**",
                        "     * @dev Returns true if a `leafs` can be proved to be a part of a Merkle tree",
                        "     * defined by `root`. For this, `proofs` for each leaf must be provided, containing",
                        "     * sibling hashes on the branch from the leaf to the root of the tree. Then",
                        "     * 'proofFlag' designates the nodes needed for the multi proof.",
                        "     *",
                        "     * _Available since v4.7._",
                        "     */",
                        "    function multiProofVerify(",
                        "        bytes32 root,",
                        "        bytes32[] memory leafs,",
                        "        bytes32[] memory proofs,",
                        "        bool[] memory proofFlag",
                        "    ) internal pure returns (bool) {",
                        "        return processMultiProof(leafs, proofs, proofFlag) == root;",
                        "    }",
                        "    /**",
                        "     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up",
                        "     * from `leaf` using the multi proof as `proofFlag`. A multi proof is",
                        "     * valid if the final hash matches the root of the tree.",
                        "     *",
                        "     * _Available since v4.7._",
                        "     */",
                        "    function processMultiProof(",
                        "        bytes32[] memory leafs,",
                        "        bytes32[] memory proofs,",
                        "        bool[] memory proofFlag",
                        "    ) internal pure returns (bytes32 merkleRoot) {",
                        "        uint256 leafsLen = leafs.length;",
                        "        uint256 proofsLen = proofs.length;",
                        "        uint256 totalHashes = proofFlag.length;",
                        "        require(leafsLen + proofsLen - 1 == totalHashes, \"MerkleProof: invalid multiproof\");",
                        "        bytes32[] memory hashes = new bytes32[](totalHashes);",
                        "        uint256 leafPos = 0;",
                        "        uint256 hashPos = 0;",
                        "        uint256 proofPos = 0;",
                        "        for (uint256 i = 0; i < totalHashes; i++) {",
                        "            bytes32 a = leafPos < leafsLen ? leafs[leafPos++] : hashes[hashPos++];",
                        "            bytes32 b = proofFlag[i] ? leafPos < leafsLen ? leafs[leafPos++] : hashes[hashPos++] : proofs[proofPos++];",
                        "            hashes[i] = _hashPair(a, b);",
                        "        }",
                        "        return hashes[totalHashes - 1];",
                        "    }",
                        "    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {",
                        "        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);",
                        "    }"
                    ],
                    "del": [
                        "            bytes32 proofElement = proof[i];",
                        "            if (computedHash <= proofElement) {",
                        "                computedHash = _efficientHash(computedHash, proofElement);",
                        "            } else {",
                        "                computedHash = _efficientHash(proofElement, computedHash);",
                        "            }"
                    ]
                }
            }
        ],
        " * `MerkleProof`: add calldata versions of the functions to avoid copying input arrays to memory and save gas. ([#3200](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3200))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3200": {
                    "add": [
                        "    function verifyCalldata(",
                        "        bytes32[] calldata proof,",
                        "        bytes32 root,",
                        "        bytes32 leaf",
                        "    ) public pure returns (bool) {",
                        "        return MerkleProof.verifyCalldata(proof, root, leaf);",
                        "    }",
                        "    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) public pure returns (bytes32) {",
                        "        return MerkleProof.processProofCalldata(proof, leaf);",
                        "    }",
                        "        bytes32[] calldata leafs,",
                        "        bytes32[] calldata proofs,",
                        "        bool[] calldata proofFlag",
                        "        bytes32[] calldata leafs,",
                        "        bytes32[] calldata proofs,",
                        "        bool[] calldata proofFlag",
                        "    /**",
                        "     * @dev Calldata version of {verify}",
                        "     *",
                        "     * _Available since v4.7._",
                        "     */",
                        "    function verifyCalldata(",
                        "        bytes32[] calldata proof,",
                        "        bytes32 root,",
                        "        bytes32 leaf",
                        "    ) internal pure returns (bool) {",
                        "        return processProofCalldata(proof, leaf) == root;",
                        "    }",
                        "    /**",
                        "     * @dev Calldata version of {processProof}",
                        "     *",
                        "     * _Available since v4.7._",
                        "     */",
                        "    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {",
                        "        bytes32 computedHash = leaf;",
                        "        for (uint256 i = 0; i < proof.length; i++) {",
                        "            computedHash = _hashPair(computedHash, proof[i]);",
                        "        }",
                        "        return computedHash;",
                        "    }",
                        "        bytes32[] calldata leaves,",
                        "        bytes32[] calldata proofs,",
                        "        bool[] calldata proofFlag",
                        "        return processMultiProof(leaves, proofs, proofFlag) == root;",
                        "        bytes32[] calldata leaves,",
                        "        bytes32[] calldata proofs,",
                        "        bool[] calldata proofFlag",
                        "        uint256 leavesLen = leaves.length;",
                        "        require(leavesLen + proofs.length - 1 == totalHashes, \"MerkleProof: invalid multiproof\");",
                        "            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];",
                        "            bytes32 b = proofFlag[i] ? leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++] : proofs[proofPos++];",
                        "        } else if (leavesLen > 0) {",
                        "            return leaves[0];"
                    ],
                    "del": [
                        "        bytes32[] memory leafs,",
                        "        bytes32[] memory proofs,",
                        "        bool[] memory proofFlag",
                        "        bytes32[] memory leafs,",
                        "        bytes32[] memory proofs,",
                        "        bool[] memory proofFlag",
                        "        bytes32[] memory leafs,",
                        "        bytes32[] memory proofs,",
                        "        bool[] memory proofFlag",
                        "        return processMultiProof(leafs, proofs, proofFlag) == root;",
                        "        bytes32[] memory leafs,",
                        "        bytes32[] memory proofs,",
                        "        bool[] memory proofFlag",
                        "        uint256 leafsLen = leafs.length;",
                        "        uint256 proofsLen = proofs.length;",
                        "        require(leafsLen + proofsLen - 1 == totalHashes, \"MerkleProof: invalid multiproof\");",
                        "            bytes32 a = leafPos < leafsLen ? leafs[leafPos++] : hashes[hashPos++];",
                        "            bytes32 b = proofFlag[i] ? leafPos < leafsLen ? leafs[leafPos++] : hashes[hashPos++] : proofs[proofPos++];",
                        "        } else if (leafsLen > 0) {",
                        "            return leafs[0];"
                    ]
                }
            }
        ],
        " * `ERC721`, `ERC1155`: simplified revert reasons. ([#3254](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3254), ([#3438](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3438)))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3254": {
                    "add": [
                        "            \"ERC1155: caller is not token owner nor approved\"",
                        "            \"ERC1155: caller is not token owner nor approved\"",
                        "            \"ERC1155: caller is not token owner nor approved\"",
                        "            \"ERC1155: caller is not token owner nor approved\"",
                        "            \"ERC721: approve caller is not token owner nor approved for all\"",
                        "        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");",
                        "        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");",
                        "        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");"
                    ],
                    "del": [
                        "            \"ERC1155: caller is not owner nor approved\"",
                        "            \"ERC1155: transfer caller is not owner nor approved\"",
                        "            \"ERC1155: caller is not owner nor approved\"",
                        "            \"ERC1155: caller is not owner nor approved\"",
                        "            \"ERC721: approve caller is not owner nor approved for all\"",
                        "        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");",
                        "        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");",
                        "        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721Burnable: caller is not owner nor approved\");"
                    ]
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3438": {
                    "add": [
                        "        require(owner != address(0), \"ERC721: invalid token ID\");",
                        "        _requireMinted(tokenId);",
                        "        _requireMinted(tokenId);",
                        "    /**",
                        "     * @dev Reverts if the `tokenId` has not been minted yet.",
                        "     */",
                        "    function _requireMinted(uint256 tokenId) internal view virtual {",
                        "        require(_exists(tokenId), \"ERC721: invalid token ID\");",
                        "    }",
                        "        _requireMinted(tokenId);"
                    ],
                    "del": [
                        "        require(owner != address(0), \"ERC721: owner query for nonexistent token\");",
                        "        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");",
                        "        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");",
                        "        require(_exists(tokenId), \"ERC721URIStorage: URI query for nonexistent token\");"
                    ]
                }
            }
        ],
        " * `Proxies`: remove runtime check of ERC1967 storage slots. ([#3455](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3455))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3455": {
                    "add": [],
                    "del": [
                        "        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));",
                        "        assert(_BEACON_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.beacon\")) - 1));",
                        "        assert(_ADMIN_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));"
                    ]
                }
            }
        ],
        " * `Initializable`: functions decorated with the modifier `reinitializer(1)` may no longer invoke each other.": []
    },
    "4.7.0-rc.0": {
        "This prerelease is now available for open review! Let us know your feedback and if you find any security issues.\r": [],
        "We have a [bug bounty](https://immunefi.com/bounty/openzeppelin/) with rewards of up to USD $25,000 and a special POAP for submitting a valid issue.\r": []
    },
    "4.6.0": {
        " * `AccessControl`: add a virtual `_checkRole(bytes32)` function that can be overridden to alter the `onlyRole` modifier behavior. ([#3137](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3137))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3137": {
                    "add": [
                        "        _checkRole(role);",
                        "    /**",
                        "     * @dev Revert with a standard message if `_msgSender()` is missing `role`.",
                        "     * Overriding this function changes the behavior of the {onlyRole} modifier.",
                        "     *",
                        "     * Format of the revert message is described in {_checkRole}.",
                        "     *",
                        "     * _Available since v4.6._",
                        "     */",
                        "    function _checkRole(bytes32 role) internal view virtual {",
                        "        _checkRole(role, _msgSender());",
                        "    }"
                    ],
                    "del": [
                        "        _checkRole(role, _msgSender());"
                    ]
                }
            }
        ],
        " * `ERC20FlashMint`: support infinite allowance when paying back a flash loan. ([#3226](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3226))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3226": {
                    "add": [
                        "        _spendAllowance(address(receiver), address(this), amount + fee);"
                    ],
                    "del": [
                        "        uint256 currentAllowance = allowance(address(receiver), address(this));",
                        "        require(currentAllowance >= amount + fee, \"ERC20FlashMint: allowance does not allow refund\");",
                        "        _approve(address(receiver), address(this), currentAllowance - amount - fee);"
                    ]
                }
            }
        ],
        " * `ERC20Wrapper`: the `decimals()` function now tries to fetch the value from the underlying token instance. If that calls revert, then the default value is used. ([#3259](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3259))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3259": {
                    "add": [
                        "    function mint(address account, uint256 amount) public {",
                        "        _mint(account, amount);",
                        "    }",
                        "    function burn(address account, uint256 amount) public {",
                        "        _burn(account, amount);",
                        "    }",
                        "    /**",
                        "     * @dev See {ERC20-decimals}.",
                        "     */",
                        "    function decimals() public view virtual override returns (uint8) {",
                        "        try IERC20Metadata(address(underlying)).decimals() returns (uint8 value) {",
                        "            return value;",
                        "        } catch {",
                        "            return super.decimals();",
                        "        }",
                        "    }"
                    ],
                    "del": []
                }
            }
        ],
        " * `draft-ERC20Permit`: replace `immutable` with `constant` for `_PERMIT_TYPEHASH` since the `keccak256` of string literals is treated specially and the hash is evaluated at compile time. ([#3196](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3196))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3196": {
                    "add": [
                        "    bytes32 private constant _PERMIT_TYPEHASH =",
                        "    /**",
                        "     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.",
                        "     * However, to ensure consistency with the upgradeable transpiler, we will continue",
                        "     * to reserve a slot.",
                        "     * @custom:oz-renamed-from _PERMIT_TYPEHASH",
                        "     */",
                        "    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;"
                    ],
                    "del": [
                        "    bytes32 private immutable _PERMIT_TYPEHASH ="
                    ]
                }
            }
        ],
        " * `ERC1155`: Add a `_afterTokenTransfer` hook for improved extensibility. ([#3166](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3166))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3166": {
                    "add": [
                        "        uint256[] memory ids = _asSingletonArray(id);",
                        "        uint256[] memory amounts = _asSingletonArray(amount);",
                        "        _beforeTokenTransfer(operator, from, to, ids, amounts, data);",
                        "        _afterTokenTransfer(operator, from, to, ids, amounts, data);",
                        "        _afterTokenTransfer(operator, from, to, ids, amounts, data);",
                        "        uint256[] memory ids = _asSingletonArray(id);",
                        "        uint256[] memory amounts = _asSingletonArray(amount);",
                        "        _beforeTokenTransfer(operator, address(0), to, ids, amounts, data);",
                        "        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);",
                        "        _afterTokenTransfer(operator, address(0), to, ids, amounts, data);",
                        "        uint256[] memory ids = _asSingletonArray(id);",
                        "        uint256[] memory amounts = _asSingletonArray(amount);",
                        "        _beforeTokenTransfer(operator, from, address(0), ids, amounts, \"\");",
                        "        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");",
                        "        _afterTokenTransfer(operator, from, address(0), ids, amounts, \"\");",
                        "    /**",
                        "     * @dev Hook that is called after any token transfer. This includes minting",
                        "     * and burning, as well as batched variants.",
                        "     *",
                        "     * The same hook is called on both single and batched variants. For single",
                        "     * transfers, the length of the `id` and `amount` arrays will be 1.",
                        "     *",
                        "     * Calling conditions (for each `id` and `amount` pair):",
                        "     *",
                        "     * - When `from` and `to` are both non-zero, `amount` of ``from``'s tokens",
                        "     * of token type `id` will be  transferred to `to`.",
                        "     * - When `from` is zero, `amount` tokens of token type `id` will be minted",
                        "     * for `to`.",
                        "     * - when `to` is zero, `amount` of ``from``'s tokens of token type `id`",
                        "     * will be burned.",
                        "     * - `from` and `to` are never both zero.",
                        "     * - `ids` and `amounts` have the same, non-zero length.",
                        "     *",
                        "     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].",
                        "     */",
                        "    function _afterTokenTransfer(",
                        "        address operator,",
                        "        address from,",
                        "        address to,",
                        "        uint256[] memory ids,",
                        "        uint256[] memory amounts,",
                        "        bytes memory data",
                        "    ) internal virtual {}"
                    ],
                    "del": [
                        "        _beforeTokenTransfer(operator, from, to, _asSingletonArray(id), _asSingletonArray(amount), data);",
                        "        _beforeTokenTransfer(operator, address(0), to, _asSingletonArray(id), _asSingletonArray(amount), data);",
                        "        _beforeTokenTransfer(operator, from, address(0), _asSingletonArray(id), _asSingletonArray(amount), \"\");"
                    ]
                }
            }
        ],
        " * `ERC1155URIStorage`: add a new extension that implements a `_setURI` behavior similar to ERC721's `_setTokenURI`. ([#3210](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3210))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3210": {
                    "add": [
                        "contract ERC1155URIStorageMock is ERC1155Mock, ERC1155URIStorage {",
                        "    constructor(string memory _uri) ERC1155Mock(_uri) {}",
                        "    function uri(uint256 tokenId) public view virtual override(ERC1155, ERC1155URIStorage) returns (string memory) {",
                        "        return ERC1155URIStorage.uri(tokenId);",
                        "    }",
                        "    function setURI(uint256 tokenId, string memory _tokenURI) public {",
                        "        _setURI(tokenId, _tokenURI);",
                        "    }",
                        "    function setBaseURI(string memory baseURI) public {",
                        "        _setBaseURI(baseURI);",
                        "    }",
                        "}",
                        "/**",
                        " * @dev ERC1155 token with storage based token URI management.",
                        " * Inspired by the ERC721URIStorage extension",
                        " *",
                        " * _Available since v4.6._",
                        " */",
                        "abstract contract ERC1155URIStorage is ERC1155 {",
                        "    using Strings for uint256;",
                        "    string private _baseURI = \"\";",
                        "    mapping(uint256 => string) private _tokenURIs;",
                        "    /**",
                        "     * @dev See {IERC1155MetadataURI-uri}.",
                        "     *",
                        "     * This implementation returns the concatenation of the `_baseURI`",
                        "     * and the token-specific uri if the latter is set",
                        "     *",
                        "     * This enables the following behaviors:",
                        "     *",
                        "     * - if `_tokenURIs[tokenId]` is set, then the result is the concatenation",
                        "     *   of `_baseURI` and `_tokenURIs[tokenId]` (keep in mind that `_baseURI`",
                        "     *   is empty per default);",
                        "     *",
                        "     * - if `_tokenURIs[tokenId]` is NOT set then we fallback to `super.uri()`",
                        "     *   which in most cases will contain `ERC1155._uri`;",
                        "     *",
                        "     * - if `_tokenURIs[tokenId]` is NOT set, and if the parents do not have a",
                        "     *   uri value set, then the result is empty.",
                        "     */",
                        "    function uri(uint256 tokenId) public view virtual override returns (string memory) {",
                        "        string memory tokenURI = _tokenURIs[tokenId];",
                        "        return bytes(tokenURI).length > 0 ? string(abi.encodePacked(_baseURI, tokenURI)) : super.uri(tokenId);",
                        "    }",
                        "    /**",
                        "     * @dev Sets `tokenURI` as the tokenURI of `tokenId`.",
                        "     */",
                        "    function _setURI(uint256 tokenId, string memory tokenURI) internal virtual {",
                        "        _tokenURIs[tokenId] = tokenURI;",
                        "        emit URI(uri(tokenId), tokenId);",
                        "    }",
                        "    /**",
                        "     * @dev Sets `baseURI` as the `_baseURI` for all tokens",
                        "     */",
                        "    function _setBaseURI(string memory baseURI) internal virtual {",
                        "        _baseURI = baseURI;",
                        "    }",
                        "}"
                    ],
                    "del": []
                }
            }
        ],
        " * `Governor`: improved security of `onlyGovernance` modifier when using an external executor contract (e.g. a timelock) that can operate without necessarily going through the governance protocol. ([#3147](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3147))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3147": {
                    "add": [
                        "    using DoubleEndedQueue for DoubleEndedQueue.Bytes32Deque;",
                        "    DoubleEndedQueue.Bytes32Deque private _governanceCall;",
                        "     * @dev Restricts a function so it can only be executed through governance proposals. For example, governance",
                        "     * parameter setters in {GovernorSettings} are protected using this modifier.",
                        "     *",
                        "     * The governance executing address may be different from the Governor's own address, for example it could be a",
                        "     * timelock. This can be customized by modules by overriding {_executor}. The executor is only able to invoke these",
                        "     * functions during the execution of the governor's {execute} function, and not under any other circumstances. Thus,",
                        "     * for example, additional timelock proposers are not able to change governance parameters without going through the",
                        "     * governance protocol (since v4.6).",
                        "        if (_executor() != address(this)) {",
                        "            bytes32 msgDataHash = keccak256(_msgData());",
                        "            while (_governanceCall.popFront() != msgDataHash) {}",
                        "        }",
                        "            getVotes(_msgSender(), block.number - 1) >= proposalThreshold(),",
                        "        _beforeExecute(proposalId, targets, values, calldatas, descriptionHash);",
                        "        _afterExecute(proposalId, targets, values, calldatas, descriptionHash);",
                        "    /**",
                        "     * @dev Hook before execution is trigerred.",
                        "     */",
                        "    function _beforeExecute(",
                        "        uint256, /* proposalId */",
                        "        address[] memory targets,",
                        "        uint256[] memory, /* values */",
                        "        bytes[] memory calldatas,",
                        "        bytes32 /*descriptionHash*/",
                        "    ) internal virtual {",
                        "        if (_executor() != address(this)) {",
                        "            for (uint256 i = 0; i < targets.length; ++i) {",
                        "                if (targets[i] == address(this)) {",
                        "                    _governanceCall.pushBack(keccak256(calldatas[i]));",
                        "                }",
                        "            }",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Hook after execution is trigerred.",
                        "     */",
                        "    function _afterExecute(",
                        "        uint256, /* proposalId */",
                        "        address[] memory, /* targets */",
                        "        uint256[] memory, /* values */",
                        "        bytes[] memory, /* calldatas */",
                        "        bytes32 /*descriptionHash*/",
                        "    ) internal virtual {",
                        "        if (_executor() != address(this)) {",
                        "            if (!_governanceCall.empty()) {",
                        "                _governanceCall.clear();",
                        "            }",
                        "        }",
                        "    }",
                        "    function nonGovernanceFunction() external {}"
                    ],
                    "del": [
                        "     * @dev Restrict access of functions to the governance executor, which may be the Governor itself or a timelock",
                        "     * contract, as specified by {_executor}. This generally means that function with this modifier must be voted on and",
                        "     * executed through the governance protocol.",
                        "            getVotes(msg.sender, block.number - 1) >= proposalThreshold(),"
                    ]
                }
            }
        ],
        " * `Governor`: fix an inconsistency in data locations that could lead to invalid bytecode being produced. ([#3295](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3295))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3295": {
                    "add": [
                        "        address[] memory targets,",
                        "        uint256[] memory values,",
                        "        bytes[] memory calldatas,"
                    ],
                    "del": [
                        "        address[] calldata targets,",
                        "        uint256[] calldata values,",
                        "        bytes[] calldata calldatas,"
                    ]
                }
            }
        ],
        " * `Governor`: Implement `IERC721Receiver` and `IERC1155Receiver` to improve token custody by governors. ([#3230](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3230))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3230": {
                    "add": [
                        "abstract contract Governor is Context, ERC165, EIP712, IGovernor, IERC721Receiver, IERC1155Receiver {",
                        "            interfaceId == type(IERC1155Receiver).interfaceId ||",
                        "    /**",
                        "     * @dev See {IERC721Receiver-onERC721Received}.",
                        "     */",
                        "    function onERC721Received(",
                        "        address,",
                        "        address,",
                        "        uint256,",
                        "        bytes memory",
                        "    ) public virtual override returns (bytes4) {",
                        "        return this.onERC721Received.selector;",
                        "    }",
                        "    /**",
                        "     * @dev See {IERC1155Receiver-onERC1155Received}.",
                        "     */",
                        "    function onERC1155Received(",
                        "        address,",
                        "        address,",
                        "        uint256,",
                        "        uint256,",
                        "        bytes memory",
                        "    ) public virtual override returns (bytes4) {",
                        "        return this.onERC1155Received.selector;",
                        "    }",
                        "    /**",
                        "     * @dev See {IERC1155Receiver-onERC1155BatchReceived}.",
                        "     */",
                        "    function onERC1155BatchReceived(",
                        "        address,",
                        "        address,",
                        "        uint256[] memory,",
                        "        uint256[] memory,",
                        "        bytes memory",
                        "    ) public virtual override returns (bytes4) {",
                        "        return this.onERC1155BatchReceived.selector;",
                        "    }",
                        "contract TimelockController is AccessControl, IERC721Receiver, IERC1155Receiver {",
                        "    /**",
                        "     * @dev See {IERC165-supportsInterface}.",
                        "     */",
                        "    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, AccessControl) returns (bool) {",
                        "        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);",
                        "    }",
                        "    /**",
                        "     * @dev See {IERC721Receiver-onERC721Received}.",
                        "     */",
                        "    function onERC721Received(",
                        "        address,",
                        "        address,",
                        "        uint256,",
                        "        bytes memory",
                        "    ) public virtual override returns (bytes4) {",
                        "        return this.onERC721Received.selector;",
                        "    }",
                        "    /**",
                        "     * @dev See {IERC1155Receiver-onERC1155Received}.",
                        "     */",
                        "    function onERC1155Received(",
                        "        address,",
                        "        address,",
                        "        uint256,",
                        "        uint256,",
                        "        bytes memory",
                        "    ) public virtual override returns (bytes4) {",
                        "        return this.onERC1155Received.selector;",
                        "    }",
                        "    /**",
                        "     * @dev See {IERC1155Receiver-onERC1155BatchReceived}.",
                        "     */",
                        "    function onERC1155BatchReceived(",
                        "        address,",
                        "        address,",
                        "        uint256[] memory,",
                        "        uint256[] memory,",
                        "        bytes memory",
                        "    ) public virtual override returns (bytes4) {",
                        "        return this.onERC1155BatchReceived.selector;",
                        "    }"
                    ],
                    "del": [
                        "abstract contract Governor is Context, ERC165, EIP712, IGovernor {",
                        "contract TimelockController is AccessControl {"
                    ]
                }
            }
        ],
        " * `TimelockController`: Implement `IERC721Receiver` and `IERC1155Receiver` to improve token custody by timelocks. ([#3230](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3230))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3230": {
                    "add": [
                        "abstract contract Governor is Context, ERC165, EIP712, IGovernor, IERC721Receiver, IERC1155Receiver {",
                        "            interfaceId == type(IERC1155Receiver).interfaceId ||",
                        "    /**",
                        "     * @dev See {IERC721Receiver-onERC721Received}.",
                        "     */",
                        "    function onERC721Received(",
                        "        address,",
                        "        address,",
                        "        uint256,",
                        "        bytes memory",
                        "    ) public virtual override returns (bytes4) {",
                        "        return this.onERC721Received.selector;",
                        "    }",
                        "    /**",
                        "     * @dev See {IERC1155Receiver-onERC1155Received}.",
                        "     */",
                        "    function onERC1155Received(",
                        "        address,",
                        "        address,",
                        "        uint256,",
                        "        uint256,",
                        "        bytes memory",
                        "    ) public virtual override returns (bytes4) {",
                        "        return this.onERC1155Received.selector;",
                        "    }",
                        "    /**",
                        "     * @dev See {IERC1155Receiver-onERC1155BatchReceived}.",
                        "     */",
                        "    function onERC1155BatchReceived(",
                        "        address,",
                        "        address,",
                        "        uint256[] memory,",
                        "        uint256[] memory,",
                        "        bytes memory",
                        "    ) public virtual override returns (bytes4) {",
                        "        return this.onERC1155BatchReceived.selector;",
                        "    }",
                        "contract TimelockController is AccessControl, IERC721Receiver, IERC1155Receiver {",
                        "    /**",
                        "     * @dev See {IERC165-supportsInterface}.",
                        "     */",
                        "    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, AccessControl) returns (bool) {",
                        "        return interfaceId == type(IERC1155Receiver).interfaceId || super.supportsInterface(interfaceId);",
                        "    }",
                        "    /**",
                        "     * @dev See {IERC721Receiver-onERC721Received}.",
                        "     */",
                        "    function onERC721Received(",
                        "        address,",
                        "        address,",
                        "        uint256,",
                        "        bytes memory",
                        "    ) public virtual override returns (bytes4) {",
                        "        return this.onERC721Received.selector;",
                        "    }",
                        "    /**",
                        "     * @dev See {IERC1155Receiver-onERC1155Received}.",
                        "     */",
                        "    function onERC1155Received(",
                        "        address,",
                        "        address,",
                        "        uint256,",
                        "        uint256,",
                        "        bytes memory",
                        "    ) public virtual override returns (bytes4) {",
                        "        return this.onERC1155Received.selector;",
                        "    }",
                        "    /**",
                        "     * @dev See {IERC1155Receiver-onERC1155BatchReceived}.",
                        "     */",
                        "    function onERC1155BatchReceived(",
                        "        address,",
                        "        address,",
                        "        uint256[] memory,",
                        "        uint256[] memory,",
                        "        bytes memory",
                        "    ) public virtual override returns (bytes4) {",
                        "        return this.onERC1155BatchReceived.selector;",
                        "    }"
                    ],
                    "del": [
                        "abstract contract Governor is Context, ERC165, EIP712, IGovernor {",
                        "contract TimelockController is AccessControl {"
                    ]
                }
            }
        ],
        " * `Initializable`: add a reinitializer modifier that enables the initialization of new modules, added to already initialized contracts through upgradeability. ([#3232](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3232))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3232": {
                    "add": [
                        "contract ReinitializerMock is Initializable {",
                        "    uint256 public counter;",
                        "    function initialize() public initializer {",
                        "        doStuff();",
                        "    }",
                        "    function reinitialize(uint8 i) public reinitializer(i) {",
                        "        doStuff();",
                        "    }",
                        "    function nestedReinitialize(uint8 i, uint8 j) public reinitializer(i) {",
                        "        reinitialize(j);",
                        "    }",
                        "    function chainReinitialize(uint8 i, uint8 j) public {",
                        "        reinitialize(i);",
                        "        reinitialize(j);",
                        "    }",
                        "    function disableInitializers() public {",
                        "        _disableInitializers();",
                        "    }",
                        "    function doStuff() public onlyInitializing {",
                        "        counter++;",
                        "    }",
                        "}",
                        " * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be",
                        " * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in",
                        " * case an upgrade adds a module that needs to be initialized.",
                        " *",
                        " * For example:",
                        " *",
                        " * [.hljs-theme-light.nopadding]",
                        " * ```",
                        " * contract MyToken is ERC20Upgradeable {",
                        " *     function initialize() initializer public {",
                        " *         __ERC20_init(\"MyToken\", \"MTK\");",
                        " *     }",
                        " * }",
                        " * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {",
                        " *     function initializeV2() reinitializer(2) public {",
                        " *         __ERC20Permit_init(\"MyToken\");",
                        " *     }",
                        " * }",
                        " * ```",
                        " *",
                        " * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke",
                        " * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:",
                        " * constructor() {",
                        " *     _disableInitializers();",
                        " * }",
                        "     * @custom:oz-retyped-from bool",
                        "    uint8 private _initialized;",
                        "     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,",
                        "     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.",
                        "        bool isTopLevelCall = _setInitializedVersion(1);",
                        "        if (isTopLevelCall) {",
                        "            _initializing = false;",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the",
                        "     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be",
                        "     * used to initialize parent contracts.",
                        "     *",
                        "     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original",
                        "     * initialization step. This is essential to configure modules that are added through upgrades and that require",
                        "     * initialization.",
                        "     *",
                        "     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in",
                        "     * a contract, executing them in the right order is up to the developer or operator.",
                        "     */",
                        "    modifier reinitializer(uint8 version) {",
                        "        bool isTopLevelCall = _setInitializedVersion(version);",
                        "        if (isTopLevelCall) {",
                        "            _initializing = true;",
                        "        }",
                        "        _;",
                        "     * {initializer} and {reinitializer} modifiers, directly or indirectly.",
                        "    /**",
                        "     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.",
                        "     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized",
                        "     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called",
                        "     * through proxies.",
                        "     */",
                        "    function _disableInitializers() internal virtual {",
                        "        _setInitializedVersion(type(uint8).max);",
                        "    }",
                        "    function _setInitializedVersion(uint8 version) private returns (bool) {",
                        "        if (_initializing) {",
                        "            require(",
                        "                version == 1 && !Address.isContract(address(this)),",
                        "                \"Initializable: contract is already initialized\"",
                        "            );",
                        "            return false;",
                        "        } else {",
                        "            require(_initialized < version, \"Initializable: contract is already initialized\");",
                        "            _initialized = version;",
                        "            return true;",
                        "        }"
                    ],
                    "del": [
                        " * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the",
                        " * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:",
                        " * constructor() initializer {}",
                        "    bool private _initialized;",
                        "     * @dev Modifier to protect an initializer function from being invoked twice.",
                        "        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");",
                        "        bool isTopLevelCall = !_initializing;",
                        "            _initialized = true;",
                        "     * {initializer} modifier, directly or indirectly.",
                        "    function _isConstructor() private view returns (bool) {",
                        "        return !Address.isContract(address(this));"
                    ]
                }
            }
        ],
        " * `ERC2981`: make `royaltiInfo` public to allow super call in overrides. ([#3305](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3305))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3305": {
                    "add": [
                        "    function royaltyInfo(uint256 _tokenId, uint256 _salePrice) public view virtual override returns (address, uint256) {"
                    ],
                    "del": [
                        "    function royaltyInfo(uint256 _tokenId, uint256 _salePrice)",
                        "        external",
                        "        view",
                        "        virtual",
                        "        override",
                        "        returns (address, uint256)",
                        "    {"
                    ]
                }
            }
        ],
        "* `TimelockController`: **(Action needed)** The upgrade from <4.6 to >=4.6 introduces a new `CANCELLER_ROLE` that requires set up to be assignable. After the upgrade, only addresses with this role will have the ability to cancel. Proposers will no longer be able to cancel. Assigning cancellers can be done by an admin (including the timelock itself) once the role admin is set up. To do this, we recommend upgrading to the `TimelockControllerWith46MigrationUpgradeable` contract and then calling the `migrateTo46` function.\r": [],
        "* `Governor`: Adds internal virtual `_getVotes` method that must be implemented; this is a breaking change for existing concrete extensions to `Governor`. To fix this on an existing voting module extension, rename `getVotes` to `_getVotes` and add a `bytes memory` argument. ([#3043](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3043))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3043": {
                    "add": [
                        " * - A voting module must implement {_getVotes}",
                        "    bytes32 public constant EXTENDED_BALLOT_TYPEHASH =",
                        "        keccak256(\"ExtendedBallot(uint256 proposalId,uint8 support,string reason,bytes params)\");",
                        "        return",
                        "            interfaceId ==",
                        "            (type(IGovernor).interfaceId ^",
                        "                this.castVoteWithReasonAndParams.selector ^",
                        "                this.castVoteWithReasonAndParamsBySig.selector ^",
                        "                this.getVotesWithParams.selector) ||",
                        "            interfaceId == type(IGovernor).interfaceId ||",
                        "            super.supportsInterface(interfaceId);",
                        "    /**",
                        "     * @dev Get the voting weight of `account` at a specific `blockNumber`, for a vote as described by `params`.",
                        "     */",
                        "    function _getVotes(",
                        "        address account,",
                        "        uint256 blockNumber,",
                        "        bytes memory params",
                        "    ) internal view virtual returns (uint256);",
                        "        uint256 weight,",
                        "        bytes memory params",
                        "    /**",
                        "     * @dev Default additional encoded parameters used by castVote methods that don't include them",
                        "     *",
                        "     * Note: Should be overriden by specific implementations to use an appropriate value, the",
                        "     * meaning of the additional params, in the context of that implementation",
                        "     */",
                        "    function _defaultParams() internal view virtual returns (bytes memory) {",
                        "        return \"\";",
                        "    }",
                        "    /**",
                        "     * @dev See {IGovernor-getVotes}.",
                        "     */",
                        "    function getVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {",
                        "        return _getVotes(account, blockNumber, _defaultParams());",
                        "    }",
                        "    /**",
                        "     * @dev See {IGovernor-getVotesWithParams}.",
                        "     */",
                        "    function getVotesWithParams(",
                        "        address account,",
                        "        uint256 blockNumber,",
                        "        bytes memory params",
                        "    ) public view virtual override returns (uint256) {",
                        "        return _getVotes(account, blockNumber, params);",
                        "    }",
                        "    /**",
                        "     * @dev See {IGovernor-castVoteWithReasonAndParams}.",
                        "     */",
                        "    function castVoteWithReasonAndParams(",
                        "        uint256 proposalId,",
                        "        uint8 support,",
                        "        string calldata reason,",
                        "        bytes memory params",
                        "    ) public virtual override returns (uint256) {",
                        "        address voter = _msgSender();",
                        "        return _castVote(proposalId, voter, support, reason, params);",
                        "    }",
                        "    /**",
                        "     * @dev See {IGovernor-castVoteWithReasonAndParamsBySig}.",
                        "     */",
                        "    function castVoteWithReasonAndParamsBySig(",
                        "        uint256 proposalId,",
                        "        uint8 support,",
                        "        string calldata reason,",
                        "        bytes memory params,",
                        "        uint8 v,",
                        "        bytes32 r,",
                        "        bytes32 s",
                        "    ) public virtual override returns (uint256) {",
                        "        address voter = ECDSA.recover(",
                        "            _hashTypedDataV4(",
                        "                keccak256(",
                        "                    abi.encode(",
                        "                        EXTENDED_BALLOT_TYPEHASH,",
                        "                        proposalId,",
                        "                        support,",
                        "                        keccak256(bytes(reason)),",
                        "                        keccak256(params)",
                        "                    )",
                        "                )",
                        "            ),",
                        "            v,",
                        "            r,",
                        "            s",
                        "        );",
                        "        return _castVote(proposalId, voter, support, reason, params);",
                        "    }",
                        "     * voting weight using {IGovernor-getVotes} and call the {_countVote} internal function. Uses the _defaultParams().",
                        "    ) internal virtual returns (uint256) {",
                        "        return _castVote(proposalId, account, support, reason, _defaultParams());",
                        "    }",
                        "    /**",
                        "     * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve",
                        "     * voting weight using {IGovernor-getVotes} and call the {_countVote} internal function.",
                        "     *",
                        "     * Emits a {IGovernor-VoteCast} event.",
                        "     */",
                        "    function _castVote(",
                        "        uint256 proposalId,",
                        "        address account,",
                        "        uint8 support,",
                        "        string memory reason,",
                        "        bytes memory params",
                        "        uint256 weight = _getVotes(account, proposal.voteStart.getDeadline(), params);",
                        "        _countVote(proposalId, account, support, weight, params);",
                        "        if (params.length == 0) {",
                        "            emit VoteCast(account, proposalId, support, weight, reason);",
                        "        } else {",
                        "            emit VoteCastWithParams(account, proposalId, support, weight, reason, params);",
                        "        }",
                        "     * @dev Emitted when a vote is cast without params.",
                        "     * Note: `support` values should be seen as buckets. Their interpretation depends on the voting module used.",
                        "    /**",
                        "     * @dev Emitted when a vote is cast with params.",
                        "     *",
                        "     * Note: `support` values should be seen as buckets. Their interpretation depends on the voting module used.",
                        "     * `params` are additional encoded parameters. Their intepepretation also depends on the voting module used.",
                        "     */",
                        "    event VoteCastWithParams(",
                        "        address indexed voter,",
                        "        uint256 proposalId,",
                        "        uint8 support,",
                        "        uint256 weight,",
                        "        string reason,",
                        "        bytes params",
                        "    );",
                        "     * If a counting module makes use of encoded `params`, it should  include this under a `params` key with a unique",
                        "     * name that describes the behavior. For example:",
                        "     *",
                        "     * - `params=fractional` might refer to a scheme where votes are divided fractionally between for/against/abstain.",
                        "     * - `params=erc721` might refer to a scheme where specific NFTs are delegated to vote.",
                        "     *",
                        "    /**",
                        "     * @notice module:reputation",
                        "     * @dev Voting power of an `account` at a specific `blockNumber` given additional encoded parameters.",
                        "     */",
                        "    function getVotesWithParams(",
                        "        address account,",
                        "        uint256 blockNumber,",
                        "        bytes memory params",
                        "    ) public view virtual returns (uint256);",
                        "     * @dev Cast a vote with a reason and additional encoded parameters",
                        "     *",
                        "     * Emits a {VoteCast} event.",
                        "     */",
                        "    function castVoteWithReasonAndParams(",
                        "        uint256 proposalId,",
                        "        uint8 support,",
                        "        string calldata reason,",
                        "        bytes memory params",
                        "    ) public virtual returns (uint256 balance);",
                        "    /**",
                        "     * @dev Cast a vote using the user's cryptographic signature.",
                        "    /**",
                        "     * @dev Cast a vote with a reason and additional encoded parameters using the user's cryptographic signature.",
                        "     *",
                        "     * Emits a {VoteCast} event.",
                        "     */",
                        "    function castVoteWithReasonAndParamsBySig(",
                        "        uint256 proposalId,",
                        "        uint8 support,",
                        "        string calldata reason,",
                        "        bytes memory params,",
                        "        uint8 v,",
                        "        bytes32 r,",
                        "        bytes32 s",
                        "    ) public virtual returns (uint256 balance);",
                        "        uint256 weight,",
                        "        uint256 weight,",
                        "        string memory reason,",
                        "        bytes memory params",
                        "        uint256 result = super._castVote(proposalId, account, support, reason, params);",
                        "     * Read the voting weight from the token's built in snapshot mechanism (see {Governor-_getVotes}).",
                        "    function _getVotes(",
                        "        address account,",
                        "        uint256 blockNumber,",
                        "        bytes memory /*params*/",
                        "    ) internal view virtual override returns (uint256) {",
                        "     * Read the voting weight from the token's built in snapshot mechanism (see {Governor-_getVotes}).",
                        "    function _getVotes(",
                        "        address account,",
                        "        uint256 blockNumber,",
                        "        bytes memory /*params*/",
                        "    ) internal view virtual override returns (uint256) {",
                        "        string memory reason,",
                        "        bytes memory params",
                        "        return super._castVote(proposalId, account, support, reason, params);",
                        "contract GovernorWithParamsMock is GovernorVotes, GovernorCountingSimple {",
                        "    event CountParams(uint256 uintParam, string strParam);",
                        "    constructor(string memory name_, IVotes token_) Governor(name_) GovernorVotes(token_) {}",
                        "    function quorum(uint256) public pure override returns (uint256) {",
                        "        return 0;",
                        "    }",
                        "    function votingDelay() public pure override returns (uint256) {",
                        "        return 4;",
                        "    }",
                        "    function votingPeriod() public pure override returns (uint256) {",
                        "        return 16;",
                        "    }",
                        "    function _getVotes(",
                        "        address account,",
                        "        uint256 blockNumber,",
                        "        bytes memory params",
                        "    ) internal view virtual override(Governor, GovernorVotes) returns (uint256) {",
                        "        uint256 reduction = 0;",
                        "        if (params.length > 0) {",
                        "            (reduction, ) = abi.decode(params, (uint256, string));",
                        "        }",
                        "        return super._getVotes(account, blockNumber, params) - reduction;",
                        "    }",
                        "    function _countVote(",
                        "        uint256 proposalId,",
                        "        address account,",
                        "        uint8 support,",
                        "        uint256 weight,",
                        "        bytes memory params",
                        "    ) internal virtual override(Governor, GovernorCountingSimple) {",
                        "        if (params.length > 0) {",
                        "            (uint256 _uintParam, string memory _strParam) = abi.decode(params, (uint256, string));",
                        "            emit CountParams(_uintParam, _strParam);",
                        "        }",
                        "        return super._countVote(proposalId, account, support, weight, params);",
                        "    }",
                        "    function cancel(",
                        "        address[] memory targets,",
                        "        uint256[] memory values,",
                        "        bytes[] memory calldatas,",
                        "        bytes32 salt",
                        "    ) public returns (uint256 proposalId) {",
                        "        return _cancel(targets, values, calldatas, salt);",
                        "    }",
                        "}"
                    ],
                    "del": [
                        " * - A voting module must implement {getVotes}",
                        "        return interfaceId == type(IGovernor).interfaceId || super.supportsInterface(interfaceId);",
                        "        uint256 weight",
                        "     * voting weight using {IGovernor-getVotes} and call the {_countVote} internal function.",
                        "        uint256 weight = getVotes(account, proposal.voteStart.getDeadline());",
                        "        _countVote(proposalId, account, support, weight);",
                        "        emit VoteCast(account, proposalId, support, weight, reason);",
                        "     * @dev Emitted when a vote is cast.",
                        "     * Note: `support` values should be seen as buckets. There interpretation depends on the voting module used.",
                        "     * @dev Cast a vote using the user cryptographic signature.",
                        "        uint256 weight",
                        "        uint256 weight",
                        "        string memory reason",
                        "        uint256 result = super._castVote(proposalId, account, support, reason);",
                        "     * Read the voting weight from the token's built in snapshot mechanism (see {IGovernor-getVotes}).",
                        "    function getVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {",
                        "     * Read the voting weight from the token's built in snapshot mechanism (see {IGovernor-getVotes}).",
                        "    function getVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {",
                        "    function getVotes(address account, uint256 blockNumber)",
                        "        public",
                        "        view",
                        "        virtual",
                        "        override(IGovernor, GovernorVotesComp)",
                        "        returns (uint256)",
                        "    {",
                        "        return super.getVotes(account, blockNumber);",
                        "    }",
                        "    function getVotes(address account, uint256 blockNumber)",
                        "        public",
                        "        view",
                        "        virtual",
                        "        override(IGovernor, GovernorVotesComp)",
                        "        returns (uint256)",
                        "    {",
                        "        return super.getVotes(account, blockNumber);",
                        "    }",
                        "    function getVotes(address account, uint256 blockNumber)",
                        "        public",
                        "        view",
                        "        virtual",
                        "        override(IGovernor, GovernorVotes)",
                        "        returns (uint256)",
                        "    {",
                        "        return super.getVotes(account, blockNumber);",
                        "    }",
                        "        string memory reason",
                        "        return super._castVote(proposalId, account, support, reason);",
                        "    function getVotes(address account, uint256 blockNumber)",
                        "        public",
                        "        view",
                        "        virtual",
                        "        override(IGovernor, GovernorVotes)",
                        "        returns (uint256)",
                        "    {",
                        "        return super.getVotes(account, blockNumber);",
                        "    }",
                        "    function getVotes(address account, uint256 blockNumber)",
                        "        public",
                        "        view",
                        "        virtual",
                        "        override(IGovernor, GovernorVotes)",
                        "        returns (uint256)",
                        "    {",
                        "        return super.getVotes(account, blockNumber);",
                        "    }",
                        "    function getVotes(address account, uint256 blockNumber)",
                        "        public",
                        "        view",
                        "        virtual",
                        "        override(IGovernor, GovernorVotes)",
                        "        returns (uint256)",
                        "    {",
                        "        return super.getVotes(account, blockNumber);",
                        "    }",
                        "    function getVotes(address account, uint256 blockNumber)",
                        "        public",
                        "        view",
                        "        override(IGovernor, GovernorVotes)",
                        "        returns (uint256)",
                        "    {",
                        "        return super.getVotes(account, blockNumber);",
                        "    }",
                        "    function getVotes(address account, uint256 blockNumber)",
                        "        public",
                        "        view",
                        "        override(IGovernor, GovernorVotes)",
                        "        returns (uint256)",
                        "    {",
                        "        return super.getVotes(account, blockNumber);",
                        "    }",
                        "    function getVotes(address account, uint256 blockNumber)",
                        "        public",
                        "        view",
                        "        override(IGovernor, GovernorVotes)",
                        "        returns (uint256)",
                        "    {",
                        "        return super.getVotes(account, blockNumber);",
                        "    }"
                    ]
                }
            }
        ],
        "* `Votes`: The internal virtual function `_getVotingUnits` was made `view` (which was accidentally missing). Any overrides should now be updated so they are `view` as well.\r": []
    },
    "4.6.0-rc.0": {
        "This prerelease is now available for open review! Let us know your feedback and if you find any security issues.\r": [],
        "We have a [bug bounty](https://immunefi.com/bounty/openzeppelin/) with rewards of up to USD $25,000 and a special POAP for submitting a valid issue.\r": []
    },
    "4.5.0": {
        " * `GovernorTimelockControl`: improve the `state()` function to have it reflect cases where a proposal has been canceled directly on the timelock. ([#2977](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2977))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2977": {
                    "add": [
                        "        } else if (_timelock.isOperationPending(queueid)) {",
                        "        } else {",
                        "            return ProposalState.Canceled;"
                    ],
                    "del": [
                        "        } else {"
                    ]
                }
            }
        ],
        " * `Governor`: add a relay function to help recover assets sent to a governor that is not its own executor (e.g. when using a timelock). ([#2926](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2926))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2926": {
                    "add": [
                        "    /**",
                        "     * @dev Relays a transaction or function call to an arbitrary target. In cases where the governance executor",
                        "     * is some contract other than the governor itself, like when using a timelock, this function can be invoked",
                        "     * in a governance proposal to recover tokens or Ether that was sent to the governor contract by mistake.",
                        "     * Note that if the executor is simply the governor itself, use of `relay` is redundant.",
                        "     */",
                        "    function relay(",
                        "        address target,",
                        "        uint256 value,",
                        "        bytes calldata data",
                        "    ) external onlyGovernance {",
                        "        Address.functionCallWithValue(target, data, value);",
                        "    }"
                    ],
                    "del": []
                }
            }
        ],
        " * `ERC721`: improved revert reason when transferring from wrong owner. ([#2975](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2975))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2975": {
                    "add": [
                        "        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");"
                    ],
                    "del": [
                        "        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");"
                    ]
                }
            }
        ],
        " * `ERC2771Context`: use immutable storage to store the forwarder address, no longer an issue since Solidity >=0.8.8 allows reading immutable variables in the constructor. ([#2917](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2917))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2917": {
                    "add": [
                        "    address private immutable _trustedForwarder;",
                        "    constructor(address trustedForwarder) ERC2771Context(trustedForwarder) {",
                        "    }"
                    ],
                    "del": [
                        "    address private _trustedForwarder;",
                        "    constructor(address trustedForwarder) ERC2771Context(trustedForwarder) {}"
                    ]
                }
            }
        ],
        " * `ERC20`: reduce allowance before triggering transfer. ([#3056](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3056))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3056": {
                    "add": [
                        "        _transfer(sender, recipient, amount);",
                        "        _move(spender, holder, recipient, amount, \"\", \"\");"
                    ],
                    "del": [
                        "        _transfer(sender, recipient, amount);",
                        "        _move(spender, holder, recipient, amount, \"\", \"\");"
                    ]
                }
            }
        ],
        " * `ERC20`: do not update allowance on `transferFrom` when allowance is `type(uint256).max`. ([#3085](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3085))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3085": {
                    "add": [
                        "     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on",
                        "     * `transferFrom`. This is semantically equivalent to an infinite approval.",
                        "     *",
                        "     * NOTE: Does not update the allowance if the current allowance",
                        "     * is the maximum `uint256`.",
                        "     *",
                        "        if (currentAllowance != type(uint256).max) {",
                        "            require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");",
                        "            unchecked {",
                        "                _approve(sender, _msgSender(), currentAllowance - amount);",
                        "            }",
                        "     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on",
                        "     * `transferFrom`. This is semantically equivalent to an infinite approval.",
                        "     *",
                        "     * NOTE: Does not update the allowance if the current allowance",
                        "     * is the maximum `uint256`.",
                        "     *",
                        "        if (currentAllowance != type(uint256).max) {",
                        "            require(currentAllowance >= amount, \"ERC777: transfer amount exceeds allowance\");",
                        "            unchecked {",
                        "                _approve(holder, spender, currentAllowance - amount);",
                        "            }",
                        "        }"
                    ],
                    "del": [
                        "        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");",
                        "        unchecked {",
                        "            _approve(sender, _msgSender(), currentAllowance - amount);",
                        "        require(currentAllowance >= amount, \"ERC777: transfer amount exceeds allowance\");",
                        "        _approve(holder, spender, currentAllowance - amount);"
                    ]
                }
            }
        ],
        " * `ERC20Burnable`: do not update allowance on `burnFrom` when allowance is `type(uint256).max`. ([#3170](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3170))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3170": {
                    "add": [
                        "        _spendAllowance(from, spender, amount);",
                        "    /**",
                        "     * @dev Spend `amount` form the allowance of `owner` toward `spender`.",
                        "     *",
                        "     * Does not update the allowance amount in case of infinite allowance.",
                        "     * Revert if not enough allowance is available.",
                        "     *",
                        "     * Might emit an {Approval} event.",
                        "     */",
                        "    function _spendAllowance(",
                        "        address owner,",
                        "        address spender,",
                        "        uint256 amount",
                        "    ) internal virtual {",
                        "        uint256 currentAllowance = allowance(owner, spender);",
                        "        if (currentAllowance != type(uint256).max) {",
                        "            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");",
                        "            unchecked {",
                        "                _approve(owner, spender, currentAllowance - amount);",
                        "            }",
                        "        }",
                        "    }",
                        "        _spendAllowance(account, _msgSender(), amount);",
                        "        _spendAllowance(holder, spender, amount);",
                        "    /**",
                        "     * @dev Spend `amount` form the allowance of `owner` toward `spender`.",
                        "     *",
                        "     * Does not update the allowance amount in case of infinite allowance.",
                        "     * Revert if not enough allowance is available.",
                        "     *",
                        "     * Might emit an {Approval} event.",
                        "     */",
                        "    function _spendAllowance(",
                        "        address owner,",
                        "        address spender,",
                        "        uint256 amount",
                        "    ) internal virtual {",
                        "        uint256 currentAllowance = allowance(owner, spender);",
                        "        if (currentAllowance != type(uint256).max) {",
                        "            require(currentAllowance >= amount, \"ERC777: insufficient allowance\");",
                        "            unchecked {",
                        "                _approve(owner, spender, currentAllowance - amount);",
                        "            }",
                        "        }",
                        "    }"
                    ],
                    "del": [
                        "        uint256 currentAllowance = allowance(from, spender);",
                        "        if (currentAllowance != type(uint256).max) {",
                        "            require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");",
                        "            unchecked {",
                        "                _approve(from, spender, currentAllowance - amount);",
                        "            }",
                        "        }",
                        "        uint256 currentAllowance = allowance(account, _msgSender());",
                        "        require(currentAllowance >= amount, \"ERC20: burn amount exceeds allowance\");",
                        "        unchecked {",
                        "            _approve(account, _msgSender(), currentAllowance - amount);",
                        "        }",
                        "        uint256 currentAllowance = _allowances[holder][spender];",
                        "        if (currentAllowance != type(uint256).max) {",
                        "            require(currentAllowance >= amount, \"ERC777: transfer amount exceeds allowance\");",
                        "            unchecked {",
                        "                _approve(holder, spender, currentAllowance - amount);",
                        "            }",
                        "        }"
                    ]
                }
            }
        ],
        " * `ERC777`: do not update allowance on `transferFrom` when allowance is `type(uint256).max`. ([#3085](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3085))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3085": {
                    "add": [
                        "     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on",
                        "     * `transferFrom`. This is semantically equivalent to an infinite approval.",
                        "     *",
                        "     * NOTE: Does not update the allowance if the current allowance",
                        "     * is the maximum `uint256`.",
                        "     *",
                        "        if (currentAllowance != type(uint256).max) {",
                        "            require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");",
                        "            unchecked {",
                        "                _approve(sender, _msgSender(), currentAllowance - amount);",
                        "            }",
                        "     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on",
                        "     * `transferFrom`. This is semantically equivalent to an infinite approval.",
                        "     *",
                        "     * NOTE: Does not update the allowance if the current allowance",
                        "     * is the maximum `uint256`.",
                        "     *",
                        "        if (currentAllowance != type(uint256).max) {",
                        "            require(currentAllowance >= amount, \"ERC777: transfer amount exceeds allowance\");",
                        "            unchecked {",
                        "                _approve(holder, spender, currentAllowance - amount);",
                        "            }",
                        "        }"
                    ],
                    "del": [
                        "        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");",
                        "        unchecked {",
                        "            _approve(sender, _msgSender(), currentAllowance - amount);",
                        "        require(currentAllowance >= amount, \"ERC777: transfer amount exceeds allowance\");",
                        "        _approve(holder, spender, currentAllowance - amount);"
                    ]
                }
            }
        ],
        " * `SignedMath`: add a `abs(int256)` method that returns the unsigned absolute value of a signed value. ([#2984](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2984))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2984": {
                    "add": [
                        "    function abs(int256 n) public pure returns (uint256) {",
                        "        return Math.abs(n);",
                        "    }",
                        "    /**",
                        "     * @dev Returns the absolute unsigned value of a signed value.",
                        "     */",
                        "    function abs(int256 n) internal pure returns (uint256) {",
                        "        unchecked {",
                        "            return uint256(n >= 0 ? n : -n);",
                        "        }",
                        "    }"
                    ],
                    "del": []
                }
            }
        ],
        " * `ERC1967Upgrade`: Refactor the secure upgrade to use `ERC1822` instead of the previous rollback mechanism. This reduces code complexity and attack surface with similar security guarantees. ([#3021](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3021))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3021": {
                    "add": [
                        "/**",
                        " * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified",
                        " * proxy whose upgrades are fully controlled by the current implementation.",
                        " */",
                        "interface IERC1822Proxiable {",
                        "    /**",
                        "     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation",
                        "     * address.",
                        "     *",
                        "     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks",
                        "     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this",
                        "     * function revert if invoked through a proxy.",
                        "     */",
                        "    function proxiableUUID() external view returns (bytes32);",
                        "}",
                        "contract UUPSUpgradeableLegacyMock is UUPSUpgradeableMock {",
                        "    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;",
                        "    function __setImplementation(address newImplementation) private {",
                        "        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");",
                        "        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;",
                        "    }",
                        "    function _upgradeToAndCallSecureLegacyV1(",
                        "        address newImplementation,",
                        "        bytes memory data,",
                        "        bool forceCall",
                        "    ) internal {",
                        "        address oldImplementation = _getImplementation();",
                        "        __setImplementation(newImplementation);",
                        "        if (data.length > 0 || forceCall) {",
                        "            Address.functionDelegateCall(newImplementation, data);",
                        "        }",
                        "        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);",
                        "        if (!rollbackTesting.value) {",
                        "            rollbackTesting.value = true;",
                        "            Address.functionDelegateCall(",
                        "                newImplementation,",
                        "                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)",
                        "            );",
                        "            rollbackTesting.value = false;",
                        "            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");",
                        "            _upgradeTo(newImplementation);",
                        "        }",
                        "    }",
                        "    function upgradeTo(address newImplementation) external virtual override {",
                        "        _upgradeToAndCallSecureLegacyV1(newImplementation, bytes(\"\"), false);",
                        "    }",
                        "    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual override {",
                        "        _upgradeToAndCallSecureLegacyV1(newImplementation, data, false);",
                        "    }",
                        "}",
                        "    function _upgradeToAndCallUUPS(",
                        "        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {",
                        "            _setImplementation(newImplementation);",
                        "        } else {",
                        "            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {",
                        "                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");",
                        "            } catch {",
                        "                revert(\"ERC1967Upgrade: new implementation is not UUPS\");",
                        "            }",
                        "            _upgradeToAndCall(newImplementation, data, forceCall);",
                        "abstract contract UUPSUpgradeable is IERC1822Proxiable, ERC1967Upgrade {",
                        "    /**",
                        "     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be",
                        "     * callable on the implementing contract but not through proxies.",
                        "     */",
                        "    modifier notDelegated() {",
                        "        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");",
                        "        _;",
                        "    }",
                        "    /**",
                        "     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the",
                        "     * implementation. It is used to validate that the this implementation remains valid after an upgrade.",
                        "     *",
                        "     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks",
                        "     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this",
                        "     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.",
                        "     */",
                        "    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {",
                        "        return _IMPLEMENTATION_SLOT;",
                        "    }",
                        "        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);",
                        "        _upgradeToAndCallUUPS(newImplementation, data, true);"
                    ],
                    "del": [
                        "contract UUPSUpgradeableBrokenMock is UUPSUpgradeableMock {",
                        "    function upgradeTo(address) external virtual override {",
                        "    }",
                        "    function upgradeToAndCall(address, bytes memory) external payable virtual override {",
                        "    }",
                        "}",
                        "    function _upgradeToAndCallSecure(",
                        "        address oldImplementation = _getImplementation();",
                        "        _setImplementation(newImplementation);",
                        "        if (data.length > 0 || forceCall) {",
                        "            Address.functionDelegateCall(newImplementation, data);",
                        "        }",
                        "        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);",
                        "        if (!rollbackTesting.value) {",
                        "            rollbackTesting.value = true;",
                        "            Address.functionDelegateCall(",
                        "                newImplementation,",
                        "                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)",
                        "            );",
                        "            rollbackTesting.value = false;",
                        "            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");",
                        "            _upgradeTo(newImplementation);",
                        "abstract contract UUPSUpgradeable is ERC1967Upgrade {",
                        "        _upgradeToAndCallSecure(newImplementation, new bytes(0), false);",
                        "        _upgradeToAndCallSecure(newImplementation, data, true);"
                    ]
                }
            }
        ],
        " * `UUPSUpgradeable`: Add `ERC1822` compliance to support the updated secure upgrade mechanism. ([#3021](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3021))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3021": {
                    "add": [
                        "/**",
                        " * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified",
                        " * proxy whose upgrades are fully controlled by the current implementation.",
                        " */",
                        "interface IERC1822Proxiable {",
                        "    /**",
                        "     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation",
                        "     * address.",
                        "     *",
                        "     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks",
                        "     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this",
                        "     * function revert if invoked through a proxy.",
                        "     */",
                        "    function proxiableUUID() external view returns (bytes32);",
                        "}",
                        "contract UUPSUpgradeableLegacyMock is UUPSUpgradeableMock {",
                        "    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;",
                        "    function __setImplementation(address newImplementation) private {",
                        "        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");",
                        "        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;",
                        "    }",
                        "    function _upgradeToAndCallSecureLegacyV1(",
                        "        address newImplementation,",
                        "        bytes memory data,",
                        "        bool forceCall",
                        "    ) internal {",
                        "        address oldImplementation = _getImplementation();",
                        "        __setImplementation(newImplementation);",
                        "        if (data.length > 0 || forceCall) {",
                        "            Address.functionDelegateCall(newImplementation, data);",
                        "        }",
                        "        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);",
                        "        if (!rollbackTesting.value) {",
                        "            rollbackTesting.value = true;",
                        "            Address.functionDelegateCall(",
                        "                newImplementation,",
                        "                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)",
                        "            );",
                        "            rollbackTesting.value = false;",
                        "            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");",
                        "            _upgradeTo(newImplementation);",
                        "        }",
                        "    }",
                        "    function upgradeTo(address newImplementation) external virtual override {",
                        "        _upgradeToAndCallSecureLegacyV1(newImplementation, bytes(\"\"), false);",
                        "    }",
                        "    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual override {",
                        "        _upgradeToAndCallSecureLegacyV1(newImplementation, data, false);",
                        "    }",
                        "}",
                        "    function _upgradeToAndCallUUPS(",
                        "        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {",
                        "            _setImplementation(newImplementation);",
                        "        } else {",
                        "            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {",
                        "                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");",
                        "            } catch {",
                        "                revert(\"ERC1967Upgrade: new implementation is not UUPS\");",
                        "            }",
                        "            _upgradeToAndCall(newImplementation, data, forceCall);",
                        "abstract contract UUPSUpgradeable is IERC1822Proxiable, ERC1967Upgrade {",
                        "    /**",
                        "     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be",
                        "     * callable on the implementing contract but not through proxies.",
                        "     */",
                        "    modifier notDelegated() {",
                        "        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");",
                        "        _;",
                        "    }",
                        "    /**",
                        "     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the",
                        "     * implementation. It is used to validate that the this implementation remains valid after an upgrade.",
                        "     *",
                        "     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks",
                        "     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this",
                        "     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.",
                        "     */",
                        "    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {",
                        "        return _IMPLEMENTATION_SLOT;",
                        "    }",
                        "        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);",
                        "        _upgradeToAndCallUUPS(newImplementation, data, true);"
                    ],
                    "del": [
                        "contract UUPSUpgradeableBrokenMock is UUPSUpgradeableMock {",
                        "    function upgradeTo(address) external virtual override {",
                        "    }",
                        "    function upgradeToAndCall(address, bytes memory) external payable virtual override {",
                        "    }",
                        "}",
                        "    function _upgradeToAndCallSecure(",
                        "        address oldImplementation = _getImplementation();",
                        "        _setImplementation(newImplementation);",
                        "        if (data.length > 0 || forceCall) {",
                        "            Address.functionDelegateCall(newImplementation, data);",
                        "        }",
                        "        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);",
                        "        if (!rollbackTesting.value) {",
                        "            rollbackTesting.value = true;",
                        "            Address.functionDelegateCall(",
                        "                newImplementation,",
                        "                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)",
                        "            );",
                        "            rollbackTesting.value = false;",
                        "            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");",
                        "            _upgradeTo(newImplementation);",
                        "abstract contract UUPSUpgradeable is ERC1967Upgrade {",
                        "        _upgradeToAndCallSecure(newImplementation, new bytes(0), false);",
                        "        _upgradeToAndCallSecure(newImplementation, data, true);"
                    ]
                }
            }
        ],
        "* `ERC1967Upgrade`: The function `_upgradeToAndCallSecure` was renamed to `_upgradeToAndCallUUPS`, along with the change in security mechanism described above.\r": [],
        "* `Address`: The Solidity pragma is increased from `^0.8.0` to `^0.8.1`. This is required by the `account.code.length` syntax that replaces inline assembly. This may require users to bump their compiler version from `0.8.0` to `0.8.1` or later. Note that other parts of the code already include stricter requirements.\r": []
    },
    "4.5.0-rc.0": {
        "This prerelease is now available for review! Let us know your feedback and if you find any security issues.\r": [],
        "We have a [bug bounty](https://immunefi.com/bounty/openzeppelin/) with rewards of up to USD $25,000 and a special POAP for submitting a valid issue.\r": []
    },
    "4.4.2": {
        ":warning: This is a patch for a medium severity issue. For more information [visit the security advisory](https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-m6w8-fq7v-ph4m).\r": [
            "https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-m6w8-fq7v-ph4m"
        ],
        " * `GovernorCompatibilityBravo`: Fix error in the encoding of calldata for proposals submitted through the compatibility interface with explicit signatures. ([#3100](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/#3100))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/#3100": {
                    "add": [],
                    "del": []
                }
            }
        ]
    },
    "4.4.1": {
        ":warning: This is a patch for a low severity vulnerability. For more information [visit the security advisory](https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-9c22-pwxw-p6hx).\r": [
            "https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-9c22-pwxw-p6hx"
        ],
        " * `Initializable`: change the existing `initializer` modifier and add a new `onlyInitializing` modifier to prevent reentrancy risk. ([#3006](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3006))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/3006": {
                    "add": [
                        "    bool public onlyInitializingRan;",
                        "    function initializeOnlyInitializing() public onlyInitializing {",
                        "        onlyInitializingRan = true;",
                        "    }",
                        "    function initializerNested() public initializer {",
                        "    function onlyInitializingNested() public initializer {",
                        "        initializeOnlyInitializing();",
                        "    }",
                        "contract ConstructorInitializableMock is Initializable {",
                        "    bool public initializerRan;",
                        "    bool public onlyInitializingRan;",
                        "    constructor() initializer {",
                        "        initialize();",
                        "        initializeOnlyInitializing();",
                        "    }",
                        "    function initialize() public initializer {",
                        "        initializerRan = true;",
                        "    }",
                        "    function initializeOnlyInitializing() public onlyInitializing {",
                        "        onlyInitializingRan = true;",
                        "    }",
                        "}",
                        "        __SampleHuman_init();",
                        "    }",
                        "    function __SampleHuman_init() internal onlyInitializing {",
                        "        __SampleHuman_init_unchained();",
                        "    }",
                        "    function __SampleHuman_init_unchained() internal onlyInitializing {",
                        "        __SampleMother_init(value);",
                        "    }",
                        "    function __SampleMother_init(uint256 value) internal onlyInitializing {",
                        "        __SampleHuman_init();",
                        "        __SampleMother_init_unchained(value);",
                        "    }",
                        "    function __SampleMother_init_unchained(uint256 value) internal onlyInitializing {",
                        "        __SampleGramps_init(value);",
                        "    }",
                        "    function __SampleGramps_init(string memory value) internal onlyInitializing {",
                        "        __SampleHuman_init();",
                        "        __SampleGramps_init_unchained(value);",
                        "    }",
                        "    function __SampleGramps_init_unchained(string memory value) internal onlyInitializing {",
                        "        __SampleFather_init(_gramps, _father);",
                        "    }",
                        "    function __SampleFather_init(string memory _gramps, uint256 _father) internal onlyInitializing {",
                        "        __SampleGramps_init(_gramps);",
                        "        __SampleFather_init_unchained(_father);",
                        "    }",
                        "    function __SampleFather_init_unchained(uint256 _father) internal onlyInitializing {",
                        "        __SampleChild_init(_mother, _gramps, _father, _child);",
                        "    }",
                        "    function __SampleChild_init(",
                        "        uint256 _mother,",
                        "        string memory _gramps,",
                        "        uint256 _father,",
                        "        uint256 _child",
                        "    ) internal onlyInitializing {",
                        "        __SampleMother_init(_mother);",
                        "        __SampleFather_init(_gramps, _father);",
                        "        __SampleChild_init_unchained(_child);",
                        "    }",
                        "    function __SampleChild_init_unchained(uint256 _child) internal onlyInitializing {",
                        "        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");",
                        "    /**",
                        "     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the",
                        "     * {initializer} modifier, directly or indirectly.",
                        "     */",
                        "    modifier onlyInitializing() {",
                        "        require(_initializing, \"Initializable: contract is not initializing\");",
                        "        _;",
                        "    }",
                        "    function _isConstructor() private view returns (bool) {",
                        "        return !Address.isContract(address(this));",
                        "    }"
                    ],
                    "del": [
                        "    function initializeNested() public initializer {",
                        "        SampleHuman.initialize();",
                        "        SampleHuman.initialize();",
                        "        SampleGramps.initialize(_gramps);",
                        "        SampleMother.initialize(_mother);",
                        "        SampleFather.initialize(_gramps, _father);",
                        "        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");"
                    ]
                }
            }
        ],
        "It is no longer possible to call an `initializer`-protected function from within another `initializer` function outside the context of a constructor. Projects using OpenZeppelin upgradeable proxies should continue to work as is, since in the common case the initializer is invoked in the constructor directly. If this is not the case for you, the suggested change is to use the new `onlyInitializing` modifier in the following way:\r": []
    },
    "4.4.0": {
        "And if you missed it, we recently announced an official **bug bounty program** for OpenZeppelin Contracts. [Check it out!](https://forum.openzeppelin.com/t/openzeppelin-contracts-bug-bounty-program-on-immunefi/19279)\r": [],
        " * `Ownable`: add an internal `_transferOwnership(address)`. ([#2568](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2568))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2568": {
                    "add": [
                        "     *",
                        "     * NOTE: This function is deprecated in favor of {_grantRole}.",
                        "    /**",
                        "     * @dev Grants `role` to `account`.",
                        "     *",
                        "     * Internal function without access restriction.",
                        "     */",
                        "    function _grantRole(bytes32 role, address account) internal virtual {",
                        "    /**",
                        "     * @dev Revokes `role` from `account`.",
                        "     *",
                        "     * Internal function without access restriction.",
                        "     */",
                        "    function _revokeRole(bytes32 role, address account) internal virtual {",
                        "        _transferOwnership(_msgSender());",
                        "        _transferOwnership(address(0));",
                        "        _transferOwnership(newOwner);",
                        "    /**",
                        "     * @dev Transfers ownership of the contract to a new account (`newOwner`).",
                        "     * Internal function without access restriction.",
                        "     */",
                        "    function _transferOwnership(address newOwner) internal virtual {"
                    ],
                    "del": [
                        "    function _grantRole(bytes32 role, address account) private {",
                        "    function _revokeRole(bytes32 role, address account) private {",
                        "        _setOwner(_msgSender());",
                        "        _setOwner(address(0));",
                        "        _setOwner(newOwner);",
                        "    function _setOwner(address newOwner) private {"
                    ]
                }
            }
        ],
        " * `AccessControl`: add internal `_grantRole(bytes32,address)` and `_revokeRole(bytes32,address)`. ([#2568](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2568))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2568": {
                    "add": [
                        "     *",
                        "     * NOTE: This function is deprecated in favor of {_grantRole}.",
                        "    /**",
                        "     * @dev Grants `role` to `account`.",
                        "     *",
                        "     * Internal function without access restriction.",
                        "     */",
                        "    function _grantRole(bytes32 role, address account) internal virtual {",
                        "    /**",
                        "     * @dev Revokes `role` from `account`.",
                        "     *",
                        "     * Internal function without access restriction.",
                        "     */",
                        "    function _revokeRole(bytes32 role, address account) internal virtual {",
                        "        _transferOwnership(_msgSender());",
                        "        _transferOwnership(address(0));",
                        "        _transferOwnership(newOwner);",
                        "    /**",
                        "     * @dev Transfers ownership of the contract to a new account (`newOwner`).",
                        "     * Internal function without access restriction.",
                        "     */",
                        "    function _transferOwnership(address newOwner) internal virtual {"
                    ],
                    "del": [
                        "    function _grantRole(bytes32 role, address account) private {",
                        "    function _revokeRole(bytes32 role, address account) private {",
                        "        _setOwner(_msgSender());",
                        "        _setOwner(address(0));",
                        "        _setOwner(newOwner);",
                        "    function _setOwner(address newOwner) private {"
                    ]
                }
            }
        ],
        " * `AccessControl`: mark `_setupRole(bytes32,address)` as deprecated in favor of `_grantRole(bytes32,address)`. ([#2568](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2568))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2568": {
                    "add": [
                        "     *",
                        "     * NOTE: This function is deprecated in favor of {_grantRole}.",
                        "    /**",
                        "     * @dev Grants `role` to `account`.",
                        "     *",
                        "     * Internal function without access restriction.",
                        "     */",
                        "    function _grantRole(bytes32 role, address account) internal virtual {",
                        "    /**",
                        "     * @dev Revokes `role` from `account`.",
                        "     *",
                        "     * Internal function without access restriction.",
                        "     */",
                        "    function _revokeRole(bytes32 role, address account) internal virtual {",
                        "        _transferOwnership(_msgSender());",
                        "        _transferOwnership(address(0));",
                        "        _transferOwnership(newOwner);",
                        "    /**",
                        "     * @dev Transfers ownership of the contract to a new account (`newOwner`).",
                        "     * Internal function without access restriction.",
                        "     */",
                        "    function _transferOwnership(address newOwner) internal virtual {"
                    ],
                    "del": [
                        "    function _grantRole(bytes32 role, address account) private {",
                        "    function _revokeRole(bytes32 role, address account) private {",
                        "        _setOwner(_msgSender());",
                        "        _setOwner(address(0));",
                        "        _setOwner(newOwner);",
                        "    function _setOwner(address newOwner) private {"
                    ]
                }
            }
        ],
        " * `AccessControlEnumerable`: hook into `_grantRole(bytes32,address)` and `_revokeRole(bytes32,address)`. ([#2946](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2946))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2946": {
                    "add": [
                        "     * @dev Overload {_grantRole} to track enumerable memberships",
                        "    function _grantRole(bytes32 role, address account) internal virtual override {",
                        "        super._grantRole(role, account);",
                        "     * @dev Overload {_revokeRole} to track enumerable memberships",
                        "    function _revokeRole(bytes32 role, address account) internal virtual override {",
                        "        super._revokeRole(role, account);"
                    ],
                    "del": [
                        "     * @dev Overload {grantRole} to track enumerable memberships",
                        "    function grantRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {",
                        "        super.grantRole(role, account);",
                        "     * @dev Overload {revokeRole} to track enumerable memberships",
                        "    function revokeRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {",
                        "        super.revokeRole(role, account);",
                        "    /**",
                        "     * @dev Overload {renounceRole} to track enumerable memberships",
                        "     */",
                        "    function renounceRole(bytes32 role, address account) public virtual override(AccessControl, IAccessControl) {",
                        "        super.renounceRole(role, account);",
                        "        _roleMembers[role].remove(account);",
                        "    }",
                        "    /**",
                        "     * @dev Overload {_setupRole} to track enumerable memberships",
                        "     */",
                        "    function _setupRole(bytes32 role, address account) internal virtual override {",
                        "        super._setupRole(role, account);",
                        "        _roleMembers[role].add(account);",
                        "    }"
                    ]
                }
            }
        ],
        " * `EIP712`: cache `address(this)` to immutable storage to avoid potential issues if a vanilla contract is used in a delegatecall context. ([#2852](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2852))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2852": {
                    "add": [
                        "    address private immutable _CACHED_THIS;",
                        "        _CACHED_THIS = address(this);",
                        "        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {"
                    ],
                    "del": [
                        "        if (block.chainid == _CACHED_CHAIN_ID) {"
                    ]
                }
            }
        ],
        " * `GovernorCompatibilityBravo`: consider quorum an inclusive rather than exclusive minimum to match Compound's GovernorBravo. ([#2974](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2974))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2974": {
                    "add": [
                        "        return quorum(proposalSnapshot(proposalId)) <= details.forVotes;"
                    ],
                    "del": [
                        "        return quorum(proposalSnapshot(proposalId)) < details.forVotes;"
                    ]
                }
            }
        ],
        " * `ECDSA`: add a variant of `toEthSignedMessageHash` for arbitrary length message hashing. ([#2865](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2865))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2865": {
                    "add": [
                        "    using ECDSA for bytes;",
                        "    function toEthSignedMessageHash(bytes memory s) public pure returns (bytes32) {",
                        "        return s.toEthSignedMessageHash();",
                        "    }",
                        "    /**",
                        "     * @dev Returns an Ethereum Signed Message, created from `s`. This",
                        "     * produces hash corresponding to the one signed with the",
                        "     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]",
                        "     * JSON-RPC method as part of EIP-191.",
                        "     *",
                        "     * See {recover}.",
                        "     */",
                        "    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {",
                        "        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));",
                        "    }"
                    ],
                    "del": []
                }
            }
        ],
        " * `VestingWallet`: new contract that handles the vesting of Ether and ERC20 tokens following a customizable vesting schedule. ([#2748](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2748))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2748": {
                    "add": [
                        "/**",
                        " * @title VestingWallet",
                        " * @dev This contract handles the vesting of Eth and ERC20 tokens for a given beneficiary. Custody of multiple tokens",
                        " * can be given to this contract, which will release the token to the beneficiary following a given vesting schedule.",
                        " * The vesting schedule is customizable through the {vestedAmount} function.",
                        " *",
                        " * Any token transferred to this contract will follow the vesting schedule as if they were locked from the beginning.",
                        " * Consequently, if the vesting has already started, any amount of tokens sent to this contract will (at least partly)",
                        " * be immediately releasable.",
                        " */",
                        "contract VestingWallet is Context {",
                        "    event EtherReleased(uint256 amount);",
                        "    event ERC20Released(address token, uint256 amount);",
                        "    uint256 private _released;",
                        "    mapping(address => uint256) private _erc20Released;",
                        "    address private immutable _beneficiary;",
                        "    uint64 private immutable _start;",
                        "    uint64 private immutable _duration;",
                        "    /**",
                        "     * @dev Set the beneficiary, start timestamp and vesting duration of the vesting wallet.",
                        "     */",
                        "    constructor(",
                        "        address beneficiaryAddress,",
                        "        uint64 startTimestamp,",
                        "        uint64 durationSeconds",
                        "    ) {",
                        "        require(beneficiaryAddress != address(0), \"VestingWallet: beneficiary is zero address\");",
                        "        _beneficiary = beneficiaryAddress;",
                        "        _start = startTimestamp;",
                        "        _duration = durationSeconds;",
                        "    }",
                        "    /**",
                        "     * @dev The contract should be able to receive Eth.",
                        "     */",
                        "    receive() external payable virtual {}",
                        "    /**",
                        "     * @dev Getter for the beneficiary address.",
                        "     */",
                        "    function beneficiary() public view virtual returns (address) {",
                        "        return _beneficiary;",
                        "    }",
                        "    /**",
                        "     * @dev Getter for the start timestamp.",
                        "     */",
                        "    function start() public view virtual returns (uint256) {",
                        "        return _start;",
                        "    }",
                        "    /**",
                        "     * @dev Getter for the vesting duration.",
                        "     */",
                        "    function duration() public view virtual returns (uint256) {",
                        "        return _duration;",
                        "    }",
                        "    /**",
                        "     * @dev Amount of eth already released",
                        "     */",
                        "    function released() public view virtual returns (uint256) {",
                        "        return _released;",
                        "    }",
                        "    /**",
                        "     * @dev Amount of token already released",
                        "     */",
                        "    function released(address token) public view virtual returns (uint256) {",
                        "        return _erc20Released[token];",
                        "    }",
                        "    /**",
                        "     * @dev Release the native token (ether) that have already vested.",
                        "     *",
                        "     * Emits a {TokensReleased} event.",
                        "     */",
                        "    function release() public virtual {",
                        "        uint256 releasable = vestedAmount(uint64(block.timestamp)) - released();",
                        "        _released += releasable;",
                        "        emit EtherReleased(releasable);",
                        "        Address.sendValue(payable(beneficiary()), releasable);",
                        "    }",
                        "    /**",
                        "     * @dev Release the tokens that have already vested.",
                        "     *",
                        "     * Emits a {TokensReleased} event.",
                        "     */",
                        "    function release(address token) public virtual {",
                        "        uint256 releasable = vestedAmount(token, uint64(block.timestamp)) - released(token);",
                        "        _erc20Released[token] += releasable;",
                        "        emit ERC20Released(token, releasable);",
                        "        SafeERC20.safeTransfer(IERC20(token), beneficiary(), releasable);",
                        "    }",
                        "    /**",
                        "     * @dev Calculates the amount of ether that has already vested. Default implementation is a linear vesting curve.",
                        "     */",
                        "    function vestedAmount(uint64 timestamp) public view virtual returns (uint256) {",
                        "        return _vestingSchedule(address(this).balance + released(), timestamp);",
                        "    }",
                        "    /**",
                        "     * @dev Calculates the amount of tokens that has already vested. Default implementation is a linear vesting curve.",
                        "     */",
                        "    function vestedAmount(address token, uint64 timestamp) public view virtual returns (uint256) {",
                        "        return _vestingSchedule(IERC20(token).balanceOf(address(this)) + released(token), timestamp);",
                        "    }",
                        "    /**",
                        "     * @dev Virtual implementation of the vesting formula. This returns the amout vested, as a function of time, for",
                        "     * an asset given its total historical allocation.",
                        "     */",
                        "    function _vestingSchedule(uint256 totalAllocation, uint64 timestamp) internal view virtual returns (uint256) {",
                        "        if (timestamp < start()) {",
                        "            return 0;",
                        "        } else if (timestamp > start() + duration()) {",
                        "            return totalAllocation;",
                        "        } else {",
                        "            return (totalAllocation * (timestamp - start())) / duration();",
                        "        }",
                        "    }",
                        "}"
                    ],
                    "del": []
                }
            }
        ],
        " * `GovernorTimelockCompound`: fix ability to use Ether stored in the Timelock contract. ([#2748](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2849))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2849": {
                    "add": [
                        "    /**",
                        "     * @dev Function to receive ETH that will be handled by the governor (disabled if executor is a third party contract)",
                        "     */",
                        "    receive() external payable virtual {",
                        "        require(_executor() == address(this));",
                        "    }",
                        "        Address.sendValue(payable(_timelock), msg.value);",
                        "            _timelock.executeTransaction(targets[i], values[i], \"\", calldatas[i], eta);"
                    ],
                    "del": [
                        "            _timelock.executeTransaction{value: values[i]}(targets[i], values[i], \"\", calldatas[i], eta);",
                        "    receive() external payable {}",
                        "    receive() external payable {}"
                    ]
                }
            }
        ]
    },
    "4.3.3": {
        ":warning: This is a security patch. For more information visit the [security advisory](https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-wmpv-c2jp-j2xg).\r": [
            "https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-wmpv-c2jp-j2xg"
        ],
        " * `ERC1155Supply`: Handle `totalSupply` changes by hooking into `_beforeTokenTransfer` to ensure consistency of balances and supply during `IERC1155Receiver.onERC1155Received` calls.\r": []
    },
    "4.3.2": {
        ":warning: This is a security patch. For more information visit the [security advisory](https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-5vp3-v4hc-gx76).\r": [
            "https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-5vp3-v4hc-gx76"
        ],
        " * `UUPSUpgradeable`: Add modifiers to prevent `upgradeTo` and `upgradeToAndCall` being executed on any contract that is not the active ERC1967 proxy. This prevents these functions being called on implementation contracts or minimal ERC1167 clones, in particular.\r": []
    },
    "4.3.1": {
        ":warning: This is a security patch. For more information visit the [security advisory](https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-fg47-3c2x-m2wr).\r": [
            "https://github.com/OpenZeppelin/openzeppelin-contracts/security/advisories/GHSA-fg47-3c2x-m2wr"
        ],
        " * `TimelockController`: Add additional isOperationReady check.\r": []
    },
    "3.4.2-solc-0.7": {
        " * `TimelockController`: Add additional isOperationReady check.\r": []
    },
    "3.4.2": {
        " * `TimelockController`: Add additional isOperationReady check.\r": []
    },
    "4.3.0": {
        " * `ERC2771Context`: use private variable from storage to store the forwarder address. Fixes issues where `_msgSender()` was not callable from constructors. ([#2754](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2754))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2754": {
                    "add": [
                        "    address private _trustedForwarder;"
                    ],
                    "del": [
                        "    address immutable _trustedForwarder;"
                    ]
                }
            }
        ],
        " * `ECDSA`: add `tryRecover` functions that will not throw if the signature is invalid, and will return an error flag instead. ([#2661](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2661))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2661": {
                    "add": [
                        "    function recover_v_r_s(",
                        "        bytes32 hash,",
                        "        uint8 v,",
                        "        bytes32 r,",
                        "        bytes32 s",
                        "    ) public pure returns (address) {",
                        "        return hash.recover(v, r, s);",
                        "    }",
                        "    function recover_r_vs(",
                        "        bytes32 hash,",
                        "        bytes32 r,",
                        "        bytes32 vs",
                        "    ) public pure returns (address) {",
                        "        return hash.recover(r, vs);",
                        "    }",
                        "    enum RecoverError {",
                        "        NoError,",
                        "        InvalidSignature,",
                        "        InvalidSignatureLength,",
                        "        InvalidSignatureS,",
                        "        InvalidSignatureV",
                        "    }",
                        "    function _throwError(RecoverError error) private pure {",
                        "        if (error == RecoverError.NoError) {",
                        "        } else if (error == RecoverError.InvalidSignature) {",
                        "            revert(\"ECDSA: invalid signature\");",
                        "        } else if (error == RecoverError.InvalidSignatureLength) {",
                        "            revert(\"ECDSA: invalid signature length\");",
                        "        } else if (error == RecoverError.InvalidSignatureS) {",
                        "            revert(\"ECDSA: invalid signature 's' value\");",
                        "        } else if (error == RecoverError.InvalidSignatureV) {",
                        "            revert(\"ECDSA: invalid signature 'v' value\");",
                        "        }",
                        "    }",
                        "     * `signature` or error string. This address can then be used for verification purposes.",
                        "     *",
                        "     * _Available since v4.3._",
                        "    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {",
                        "            return tryRecover(hash, v, r, s);",
                        "            return tryRecover(hash, r, vs);",
                        "            return (address(0), RecoverError.InvalidSignatureLength);",
                        "     * @dev Returns the address that signed a hashed message (`hash`) with",
                        "     * `signature`. This address can then be used for verification purposes.",
                        "     *",
                        "     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:",
                        "     * this function rejects them by requiring the `s` value to be in the lower",
                        "     * half order, and the `v` value to be either 27 or 28.",
                        "     *",
                        "     * IMPORTANT: `hash` _must_ be the result of a hash operation for the",
                        "     * verification to be secure: it is possible to craft signatures that",
                        "     * recover to arbitrary addresses for non-hashed data. A safe way to ensure",
                        "     * this is by receiving a hash of the original message (which may otherwise",
                        "     * be too long), and then calling {toEthSignedMessageHash} on it.",
                        "     */",
                        "    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {",
                        "        (address recovered, RecoverError error) = tryRecover(hash, signature);",
                        "        _throwError(error);",
                        "        return recovered;",
                        "    }",
                        "    /**",
                        "     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.",
                        "     * _Available since v4.3._",
                        "    function tryRecover(",
                        "    ) internal pure returns (address, RecoverError) {",
                        "        return tryRecover(hash, v, r, s);",
                        "     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.",
                        "     *",
                        "     * _Available since v4.2._",
                        "        bytes32 hash,",
                        "        bytes32 r,",
                        "        bytes32 vs",
                        "    ) internal pure returns (address) {",
                        "        (address recovered, RecoverError error) = tryRecover(hash, r, vs);",
                        "        _throwError(error);",
                        "        return recovered;",
                        "    }",
                        "    /**",
                        "     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,",
                        "     * `r` and `s` signature fields separately.",
                        "     *",
                        "     * _Available since v4.3._",
                        "     */",
                        "    function tryRecover(",
                        "    ) internal pure returns (address, RecoverError) {",
                        "        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {",
                        "            return (address(0), RecoverError.InvalidSignatureS);",
                        "        }",
                        "        if (v != 27 && v != 28) {",
                        "            return (address(0), RecoverError.InvalidSignatureV);",
                        "        }",
                        "        if (signer == address(0)) {",
                        "            return (address(0), RecoverError.InvalidSignature);",
                        "        }",
                        "        return (signer, RecoverError.NoError);",
                        "    }",
                        "    /**",
                        "     * @dev Overload of {ECDSA-recover} that receives the `v`,",
                        "     * `r` and `s` signature fields separately.",
                        "     */",
                        "    function recover(",
                        "        bytes32 hash,",
                        "        uint8 v,",
                        "        bytes32 r,",
                        "        bytes32 s",
                        "    ) internal pure returns (address) {",
                        "        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);",
                        "        _throwError(error);",
                        "        return recovered;",
                        "        (address recovered, ECDSA.RecoverError error) = ECDSA.tryRecover(hash, signature);",
                        "        if (error == ECDSA.RecoverError.NoError && recovered == signer) {",
                        "            return true;",
                        "        (bool success, bytes memory result) = signer.staticcall(",
                        "            abi.encodeWithSelector(IERC1271.isValidSignature.selector, hash, signature)",
                        "        );",
                        "        return (success && result.length == 32 && abi.decode(result, (bytes4)) == IERC1271.isValidSignature.selector);"
                    ],
                    "del": [
                        "     * `signature`. This address can then be used for verification purposes.",
                        "    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {",
                        "            return recover(hash, v, r, s);",
                        "            return recover(hash, r, vs);",
                        "            revert(\"ECDSA: invalid signature length\");",
                        "     * @dev Overload of {ECDSA-recover} that receives the `r` and `vs` short-signature fields separately.",
                        "     * _Available since v4.2._",
                        "    function recover(",
                        "    ) internal pure returns (address) {",
                        "        return recover(hash, v, r, s);",
                        "     * @dev Overload of {ECDSA-recover} that receives the `v`, `r` and `s` signature fields separately.",
                        "    ) internal pure returns (address) {",
                        "        require(",
                        "            uint256(s) <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0,",
                        "            \"ECDSA: invalid signature 's' value\"",
                        "        );",
                        "        require(v == 27 || v == 28, \"ECDSA: invalid signature 'v' value\");",
                        "        require(signer != address(0), \"ECDSA: invalid signature\");",
                        "        return signer;",
                        "        if (Address.isContract(signer)) {",
                        "            try IERC1271(signer).isValidSignature(hash, signature) returns (bytes4 magicValue) {",
                        "                return magicValue == IERC1271.isValidSignature.selector;",
                        "            } catch {",
                        "                return false;",
                        "            }",
                        "        } else {",
                        "            return ECDSA.recover(hash, signature) == signer;"
                    ]
                }
            }
        ]
    },
    "4.2.0": {
        " * `ERC20VotesComp`: Variant of `ERC20Votes` that is compatible with Compound's `Comp` token interface but restricts supply to `uint96`. ([#2706](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2706))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2706": {
                    "add": [
                        "contract ERC20VotesCompMock is ERC20VotesComp {",
                        "    constructor (string memory name, string memory symbol)",
                        "    ERC20(name, symbol)",
                        "    ERC20Permit(name)",
                        "    {}",
                        "    function mint(address account, uint256 amount) public {",
                        "        _mint(account, amount);",
                        "    }",
                        "    function burn(address account, uint256 amount) public {",
                        "        _burn(account, amount);",
                        "    }",
                        "    function getChainId() external view returns (uint256) {",
                        "        return block.chainid;",
                        "    }",
                        "}",
                        "    function toUint224(uint a) public pure returns (uint224) {",
                        "        return a.toUint224();",
                        "    function toUint96(uint a) public pure returns (uint96) {",
                        "        return a.toUint96();",
                        "    }",
                        "    function toInt256(uint a) public pure returns (int256) {",
                        "        return a.toInt256();",
                        "    }",
                        " * @dev Extension of ERC20 to support Compound-like voting and delegation. This version is more generic than Compound's,",
                        " * and supports token supply up to 2^224^ - 1, while COMP is limited to 2^96^ - 1.",
                        " * NOTE: If exact COMP compatibility is required, use the {ERC20VotesComp} variant of this module.",
                        " *",
                        " * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either",
                        " * power can be queried through the public accessors {getVotes} and {getPastVotes}.",
                        "abstract contract ERC20Votes is ERC20Permit {",
                        "    struct Checkpoint {",
                        "        uint32  fromBlock;",
                        "        uint224 votes;",
                        "    }",
                        "    /**",
                        "     * @dev Emitted when an account changes their delegate.",
                        "     */",
                        "    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);",
                        "    /**",
                        "     * @dev Emitted when a token transfer or delegate change results in changes to an account's voting power.",
                        "     */",
                        "    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);",
                        "    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {",
                        "    function numCheckpoints(address account) public view virtual returns (uint32) {",
                        "    function delegates(address account) public view virtual returns (address) {",
                        "    function getVotes(address account) public view returns (uint256) {",
                        "    function getPastVotes(address account, uint256 blockNumber) public view returns (uint256) {",
                        "    function getPastTotalSupply(uint256 blockNumber) public view returns (uint256) {",
                        "    function delegate(address delegatee) public virtual {",
                        "        public virtual",
                        "     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).",
                        "     */",
                        "    function _maxSupply() internal view virtual returns (uint224) {",
                        "        return type(uint224).max;",
                        "    }",
                        "    /**",
                        "     * @dev Snapshots the totalSupply after it has been increased.",
                        "        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");",
                        "     * @dev Snapshots the totalSupply after it has been decreased.",
                        "     * @dev Move voting power when tokens are transferred.",
                        "     *",
                        "     * Emits a {DelegateVotesChanged} event.",
                        "     *",
                        "     * Emits events {DelegateChanged} and {DelegateVotesChanged}.",
                        "/**",
                        " * @dev Extension of ERC20 to support Compound's voting and delegation. This version exactly matches Compound's",
                        " * interface, with the drawback of only supporting supply up to (2^96^ - 1).",
                        " *",
                        " * NOTE: You should use this contract if you need exact compatibility with COMP (for example in order to use your token",
                        " * with Governor Alpha or Bravo) and if you are sure the supply cap of 2^96^ is enough for you. Otherwise, use the",
                        " * {ERC20Votes} variant of this module.",
                        " *",
                        " * This extensions keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either",
                        " * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting",
                        " * power can be queried through the public accessors {getCurrentVotes} and {getPriorVotes}.",
                        " *",
                        " * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it",
                        " * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.",
                        " * Enabling self-delegation can easily be done by overriding the {delegates} function. Keep in mind however that this",
                        " * will significantly increase the base gas cost of transfers.",
                        " *",
                        " * _Available since v4.2._",
                        " */",
                        "abstract contract ERC20VotesComp is ERC20Votes {",
                        "    /**",
                        "     * @dev Comp version of the {getVotes} accessor, with `uint96` return type.",
                        "     */",
                        "    function getCurrentVotes(address account) external view returns (uint96) {",
                        "        return SafeCast.toUint96(getVotes(account));",
                        "    }",
                        "    /**",
                        "     * @dev Comp version of the {getPastVotes} accessor, with `uint96` return type.",
                        "     */",
                        "    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint96) {",
                        "        return SafeCast.toUint96(getPastVotes(account, blockNumber));",
                        "    }",
                        "    /**",
                        "     * @dev Maximum token supply. Reduced to `type(uint96).max` (2^96^ - 1) to fit COMP interface.",
                        "     */",
                        "    function _maxSupply() internal view virtual override returns (uint224) {",
                        "        return type(uint96).max;",
                        "    }",
                        "}",
                        "        require(value <= type(uint224).max, \"SafeCast: value doesn\\'t fit in 224 bits\");",
                        "        require(value <= type(uint128).max, \"SafeCast: value doesn\\'t fit in 128 bits\");",
                        "    /**",
                        "     * @dev Returns the downcasted uint96 from uint256, reverting on",
                        "     * overflow (when the input is greater than largest uint96).",
                        "     *",
                        "     * Counterpart to Solidity's `uint96` operator.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - input must fit into 96 bits",
                        "     */",
                        "    function toUint96(uint256 value) internal pure returns (uint96) {",
                        "        require(value <= type(uint96).max, \"SafeCast: value doesn\\'t fit in 96 bits\");",
                        "        return uint96(value);",
                        "    }",
                        "        require(value <= type(uint64).max, \"SafeCast: value doesn\\'t fit in 64 bits\");",
                        "        require(value <= type(uint32).max, \"SafeCast: value doesn\\'t fit in 32 bits\");",
                        "        require(value <= type(uint16).max, \"SafeCast: value doesn\\'t fit in 16 bits\");",
                        "        require(value <= type(uint8).max, \"SafeCast: value doesn\\'t fit in 8 bits\");",
                        "        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn\\'t fit in 128 bits\");",
                        "        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn\\'t fit in 64 bits\");",
                        "        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn\\'t fit in 32 bits\");",
                        "        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn\\'t fit in 16 bits\");",
                        "        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn\\'t fit in 8 bits\");",
                        "        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");"
                    ],
                    "del": [
                        "    function toInt256(uint a) public pure returns (int256) {",
                        "        return a.toInt256();",
                        " * @dev Extension of the ERC20 token contract to support Compound's voting and delegation.",
                        " * This extensions keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either",
                        " * power can be queried through the public accessors {getCurrentVotes} and {getPriorVotes}.",
                        "abstract contract ERC20Votes is IERC20Votes, ERC20Permit {",
                        "    function checkpoints(address account, uint32 pos) external view virtual override returns (Checkpoint memory) {",
                        "    function numCheckpoints(address account) external view virtual override returns (uint32) {",
                        "    function delegates(address account) public view virtual override returns (address) {",
                        "    function getCurrentVotes(address account) external view override returns (uint256) {",
                        "    function getPriorVotes(address account, uint256 blockNumber) external view override returns (uint256) {",
                        "    function getPriorTotalSupply(uint256 blockNumber) external view override returns (uint256) {",
                        "    function delegate(address delegatee) public virtual override {",
                        "        public virtual override",
                        "     * @dev snapshot the totalSupply after it has been increassed.",
                        "        require(totalSupply() <= type(uint224).max, \"ERC20Votes: total supply exceeds 2**224\");",
                        "     * @dev snapshot the totalSupply after it has been decreased.",
                        "     * @dev move voting power when tokens are transferred.",
                        "interface IERC20Votes is IERC20 {",
                        "    struct Checkpoint {",
                        "        uint32  fromBlock;",
                        "        uint224 votes;",
                        "    }",
                        "    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);",
                        "    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);",
                        "    function delegates(address owner) external view returns (address);",
                        "    function checkpoints(address account, uint32 pos) external view returns (Checkpoint memory);",
                        "    function numCheckpoints(address account) external view returns (uint32);",
                        "    function getCurrentVotes(address account) external view returns (uint256);",
                        "    function getPriorVotes(address account, uint256 blockNumber) external view returns (uint256);",
                        "    function getPriorTotalSupply(uint256 blockNumber) external view returns(uint256);",
                        "    function delegate(address delegatee) external;",
                        "    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) external;",
                        "}",
                        "        require(value < 2**224, \"SafeCast: value doesn\\'t fit in 224 bits\");",
                        "        require(value < 2**128, \"SafeCast: value doesn\\'t fit in 128 bits\");",
                        "        require(value < 2**64, \"SafeCast: value doesn\\'t fit in 64 bits\");",
                        "        require(value < 2**32, \"SafeCast: value doesn\\'t fit in 32 bits\");",
                        "        require(value < 2**16, \"SafeCast: value doesn\\'t fit in 16 bits\");",
                        "        require(value < 2**8, \"SafeCast: value doesn\\'t fit in 8 bits\");",
                        "        require(value >= -2**127 && value < 2**127, \"SafeCast: value doesn\\'t fit in 128 bits\");",
                        "        require(value >= -2**63 && value < 2**63, \"SafeCast: value doesn\\'t fit in 64 bits\");",
                        "        require(value >= -2**31 && value < 2**31, \"SafeCast: value doesn\\'t fit in 32 bits\");",
                        "        require(value >= -2**15 && value < 2**15, \"SafeCast: value doesn\\'t fit in 16 bits\");",
                        "        require(value >= -2**7 && value < 2**7, \"SafeCast: value doesn\\'t fit in 8 bits\");",
                        "        require(value < 2**255, \"SafeCast: value doesn't fit in an int256\");"
                    ]
                }
            }
        ],
        " * `ERC20Wrapper`: add a new extension of the `ERC20` token which wraps an underlying token. Deposit and withdraw guarantee that the total supply is backed by a corresponding amount of underlying token. ([#2633](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2633))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2633": {
                    "add": [
                        "contract ERC20WrapperMock is ERC20Wrapper {",
                        "    constructor(",
                        "        IERC20 _underlyingToken,",
                        "        string memory name,",
                        "        string memory symbol",
                        "    ) ERC20(name, symbol) ERC20Wrapper(_underlyingToken) {}",
                        "    function recover(address account) public returns (uint256) {",
                        "        return _recover(account);",
                        "    }",
                        "}",
                        "/**",
                        " * @dev Extension of the ERC20 token contract to support token wrapping.",
                        " *",
                        " * Users can deposit and withdraw \"underlying tokens\" and receive a matching number of \"wrapped tokens\". This is useful",
                        " * in conjunction with other modules. For example, combining this wrapping mechanism with {ERC20Votes} will allow the",
                        " * wrapping of an existing \"basic\" ERC20 into a governance token.",
                        " *",
                        " * _Available since v4.2._",
                        " */",
                        "abstract contract ERC20Wrapper is ERC20 {",
                        "    IERC20 public immutable underlying;",
                        "    constructor(IERC20 underlyingToken) {",
                        "        underlying = underlyingToken;",
                        "    }",
                        "    /**",
                        "     * @dev Allow a user to deposit underlying tokens and mint the corresponding number of wrapped tokens.",
                        "     */",
                        "    function depositFor(address account, uint256 amount) public virtual returns (bool) {",
                        "        SafeERC20.safeTransferFrom(underlying, _msgSender(), address(this), amount);",
                        "        _mint(account, amount);",
                        "        return true;",
                        "    }",
                        "    /**",
                        "     * @dev Allow a user to burn a number of wrapped tokens and withdraw the corresponding number of underlying tokens.",
                        "     */",
                        "    function withdrawTo(address account, uint256 amount) public virtual returns (bool) {",
                        "        _burn(_msgSender(), amount);",
                        "        SafeERC20.safeTransfer(underlying, account, amount);",
                        "        return true;",
                        "    }",
                        "    /**",
                        "     * @dev Mint wrapped token to cover any underlyingTokens that would have been transfered by mistake. Internal",
                        "     * function that can be exposed with access control if desired.",
                        "     */",
                        "    function _recover(address account) internal virtual returns (uint256) {",
                        "        uint256 value = underlying.balanceOf(address(this)) - totalSupply();",
                        "        _mint(account, value);",
                        "        return value;",
                        "    }",
                        "}"
                    ],
                    "del": []
                }
            }
        ],
        " * Enumerables: Improve gas cost of removal in `EnumerableSet` and `EnumerableMap`.\r": [],
        " * Enumerables: Improve gas cost of lookup in `EnumerableSet` and `EnumerableMap`.\r": [],
        " * Tokens: Wrap definitely safe subtractions in `unchecked` blocks.\r": []
    },
    "4.1.0": {
        " * `ERC777`: make reception acquirement optional in `_mint`. ([#2552](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2552))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2552": {
                    "add": [
                        "    function mintInternalExtended (",
                        "        address to,",
                        "        uint256 amount,",
                        "        bytes memory userData,",
                        "        bytes memory operatorData,",
                        "        bool requireReceptionAck",
                        "    ) public {",
                        "        _mint(to, amount, userData, operatorData, requireReceptionAck);",
                        "    }",
                        "    {",
                        "        _mint(account, amount, userData, operatorData, true);",
                        "    }",
                        "    /**",
                        "     * @dev Creates `amount` tokens and assigns them to `account`, increasing",
                        "     * the total supply.",
                        "     *",
                        "     * If `requireReceptionAck` is set to true, and if a send hook is",
                        "     * registered for `account`, the corresponding function will be called with",
                        "     * `operator`, `data` and `operatorData`.",
                        "     *",
                        "     * See {IERC777Sender} and {IERC777Recipient}.",
                        "     *",
                        "     * Emits {Minted} and {IERC20-Transfer} events.",
                        "     *",
                        "     * Requirements",
                        "     *",
                        "     * - `account` cannot be the zero address.",
                        "     * - if `account` is a contract, it must implement the {IERC777Recipient}",
                        "     * interface.",
                        "     */",
                        "    function _mint(",
                        "        address account,",
                        "        uint256 amount,",
                        "        bytes memory userData,",
                        "        bytes memory operatorData,",
                        "        bool requireReceptionAck",
                        "    )",
                        "        internal",
                        "        virtual",
                        "        _callTokensReceived(operator, address(0), account, amount, userData, operatorData, requireReceptionAck);"
                    ],
                    "del": [
                        "        _callTokensReceived(operator, address(0), account, amount, userData, operatorData, true);"
                    ]
                }
            }
        ],
        " * `ERC20Permit`: add a `_useNonce` to enable further usage of ERC712 signatures. ([#2565](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2565))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2565": {
                    "add": [
                        "                _useNonce(owner),",
                        "    function nonces(address owner) public view virtual override returns (uint256) {",
                        "    /**",
                        "     * @dev \"Consume a nonce\": return the current value and increment.",
                        "     */",
                        "    function _useNonce(address owner) internal virtual returns (uint256 current) {",
                        "        Counters.Counter storage nonce = _nonces[owner];",
                        "        current = nonce.current();",
                        "        nonce.increment();",
                        "    }"
                    ],
                    "del": [
                        "                _nonces[owner].current(),",
                        "        _nonces[owner].increment();",
                        "    function nonces(address owner) public view override returns (uint256) {"
                    ]
                }
            }
        ],
        " * `SignatureChecker`: add a signature verification library that supports both EOA and ERC1271 compliant contracts as signers. ([#2532](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2532))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2532": {
                    "add": [
                        "/**",
                        " * @dev Interface of the ERC1271 standard signature validation method for",
                        " * contracts as defined in https://eips.ethereum.org/EIPS/eip-1271[ERC-1271].",
                        " */",
                        "interface IERC1271 {",
                        "  /**",
                        "   * @dev Should return whether the signature provided is valid for the provided data",
                        "   * @param hash      Hash of the data to be signed",
                        "   * @param signature Signature byte array associated with _data",
                        "   */",
                        "  function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);",
                        "}",
                        "contract ERC1271WalletMock is Ownable, IERC1271 {",
                        "    constructor(address originalOwner) {",
                        "        transferOwnership(originalOwner);",
                        "    }",
                        "    function isValidSignature(bytes32 hash, bytes memory signature) public view override returns (bytes4 magicValue) {",
                        "        return ECDSA.recover(hash, signature) == owner() ? this.isValidSignature.selector : bytes4(0);",
                        "    }",
                        "}",
                        "contract SignatureCheckerMock {",
                        "    using SignatureChecker for address;",
                        "    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) public view returns (bool) {",
                        "        return signer.isValidSignatureNow(hash, signature);",
                        "    }",
                        "}",
                        "/**",
                        " * @dev Signature verification helper: Provide a single mechanism to verify both private-key (EOA) ECDSA signature and",
                        " * ERC1271 contract sigantures. Using this instead of ECDSA.recover in your contract will make them compatible with",
                        " * smart contract wallets such as Argent and Gnosis.",
                        " *",
                        " * Note: unlike ECDSA signatures, contract signature's are revocable, and the outcome of this function can thus change",
                        " * through time. It could return true at block N and false at block N+1 (or the opposite).",
                        " */",
                        "library SignatureChecker {",
                        "    function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal view returns (bool) {",
                        "        if (Address.isContract(signer)) {",
                        "            try IERC1271(signer).isValidSignature(hash, signature) returns (bytes4 magicValue) {",
                        "                return magicValue == IERC1271(signer).isValidSignature.selector;",
                        "            } catch {",
                        "                return false;",
                        "            }",
                        "        } else {",
                        "            return ECDSA.recover(hash, signature) == signer;",
                        "        }",
                        "    }",
                        "}"
                    ],
                    "del": []
                }
            }
        ],
        " * `AccessControl`: add a `onlyRole` modifier to restrict specific function to callers bearing a specific role. ([#2609](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2609))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2609": {
                    "add": [
                        "    /**",
                        "     * @dev Modifier that checks that an account has a specific role. Reverts",
                        "     * with a standardized message including the required role.",
                        "     *",
                        "     * The format of the revert reason is given by the following regular expression:",
                        "     *",
                        "     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/",
                        "     */",
                        "    modifier onlyRole(bytes32 role) {",
                        "        _checkRole(role, _msgSender());",
                        "        _;",
                        "    }",
                        "    /**",
                        "     * @dev Revert with a standard message if `account` is missing `role`.",
                        "     *",
                        "     * The format of the revert reason is given by the following regular expression:",
                        "     *",
                        "     *  /^AccessControl: account (0x[0-9a-f]{20}) is missing role (0x[0-9a-f]{32})$/",
                        "     */",
                        "    function _checkRole(bytes32 role, address account) internal view {",
                        "        if(!hasRole(role, account)) {",
                        "            revert(string(abi.encodePacked(",
                        "                \"AccessControl: account \",",
                        "                Strings.toHexString(uint160(account), 20),",
                        "                \" is missing role \",",
                        "                Strings.toHexString(uint256(role), 32)",
                        "            )));",
                        "        }",
                        "    }",
                        "    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {",
                        "    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {",
                        "    modifier onlyRoleOrOpenRole(bytes32 role) {",
                        "        if (!hasRole(role, address(0))) {",
                        "            _checkRole(role, _msgSender());",
                        "        }",
                        "    function execute(address target, uint256 value, bytes calldata data, bytes32 predecessor, bytes32 salt) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {",
                        "    function executeBatch(address[] calldata targets, uint256[] calldata values, bytes[] calldata datas, bytes32 predecessor, bytes32 salt) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {",
                        "    function senderProtected(bytes32 roleId) public onlyRole(roleId) {}",
                        "    function senderProtected(bytes32 roleId) public onlyRole(roleId) {}"
                    ],
                    "del": [
                        "    function grantRole(bytes32 role, address account) public virtual override {",
                        "        require(hasRole(getRoleAdmin(role), _msgSender()), \"AccessControl: sender must be an admin to grant\");",
                        "    function revokeRole(bytes32 role, address account) public virtual override {",
                        "        require(hasRole(getRoleAdmin(role), _msgSender()), \"AccessControl: sender must be an admin to revoke\");",
                        "    modifier onlyRole(bytes32 role) {",
                        "        require(hasRole(role, _msgSender()) || hasRole(role, address(0)), \"TimelockController: sender requires permission\");",
                        "    function execute(address target, uint256 value, bytes calldata data, bytes32 predecessor, bytes32 salt) public payable virtual onlyRole(EXECUTOR_ROLE) {",
                        "    function executeBatch(address[] calldata targets, uint256[] calldata values, bytes[] calldata datas, bytes32 predecessor, bytes32 salt) public payable virtual onlyRole(EXECUTOR_ROLE) {"
                    ]
                }
            }
        ],
        " * UUPS Proxies: add `UUPSUpgradeable` to implement the UUPS proxy pattern together with `EIP1967Proxy`. ([#2542](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2542))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2542": {
                    "add": [
                        "contract StorageSlotMock {",
                        "    using StorageSlot for bytes32;",
                        "    function setBoolean(bytes32 slot, bool value) public { slot.getBooleanSlot().value = value; }",
                        "    function setAddress(bytes32 slot, address value) public { slot.getAddressSlot().value = value; }",
                        "    function setBytes32(bytes32 slot, bytes32 value) public { slot.getBytes32Slot().value = value; }",
                        "    function setUint256(bytes32 slot, uint256 value) public { slot.getUint256Slot().value = value; }",
                        "    function getBoolean(bytes32 slot) public view returns (bool) { return slot.getBooleanSlot().value; }",
                        "    function getAddress(bytes32 slot) public view returns (address) { return slot.getAddressSlot().value; }",
                        "    function getBytes32(bytes32 slot) public view returns (bytes32) { return slot.getBytes32Slot().value; }",
                        "    function getUint256(bytes32 slot) public view returns (uint256) { return slot.getUint256Slot().value; }",
                        "}",
                        "contract UUPSUpgradeableMock is CountersImpl, UUPSUpgradeable {",
                        "    function _authorizeUpgrade(address) internal virtual override {}",
                        "}",
                        "contract UUPSUpgradeableUnsafeMock is UUPSUpgradeableMock {",
                        "    function upgradeTo(address newImplementation) external virtual override {",
                        "        ERC1967Upgrade._upgradeToAndCall(newImplementation, bytes(\"\"), false);",
                        "    }",
                        "    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual override {",
                        "        ERC1967Upgrade._upgradeToAndCall(newImplementation, data, false);",
                        "    }",
                        "}",
                        "contract UUPSUpgradeableBrokenMock is UUPSUpgradeableMock {",
                        "    function upgradeTo(address) external virtual override {",
                        "    }",
                        "    function upgradeToAndCall(address, bytes memory) external payable virtual override {",
                        "    }",
                        "}",
                        "contract ERC1967Proxy is Proxy, ERC1967Upgrade {",
                        "        _upgradeToAndCall(_logic, _data, false);",
                        "        return ERC1967Storage._getImplementation();",
                        "/**",
                        " * @dev This abstract contract provides setters and getters for the different",
                        " * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] storage slots.",
                        " */",
                        "abstract contract ERC1967Storage {",
                        "    /**",
                        "     * @dev Storage slot with the address of the current implementation.",
                        "     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is",
                        "     * validated in the constructor.",
                        "     */",
                        "    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;",
                        "    /**",
                        "     * @dev Returns the current implementation address.",
                        "     */",
                        "    function _getImplementation() internal view returns (address) {",
                        "        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;",
                        "    }",
                        "    /**",
                        "     * @dev Stores a new address in the EIP1967 implementation slot.",
                        "     */",
                        "    function _setImplementation(address newImplementation) internal {",
                        "        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");",
                        "        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;",
                        "    }",
                        "    /**",
                        "     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.",
                        "     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.",
                        "     */",
                        "    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;",
                        "    /**",
                        "     * @dev Returns the current beacon.",
                        "     */",
                        "    function _getBeacon() internal view returns (address) {",
                        "        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;",
                        "    }",
                        "    /**",
                        "     * @dev Stores a new beacon in the EIP1967 beacon slot.",
                        "     */",
                        "    function _setBeacon(address newBeacon) internal {",
                        "        require(",
                        "            Address.isContract(newBeacon),",
                        "            \"ERC1967: new beacon is not a contract\"",
                        "        );",
                        "        require(",
                        "            Address.isContract(IBeacon(newBeacon).implementation()),",
                        "            \"ERC1967: beacon implementation is not a contract\"",
                        "        );",
                        "        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;",
                        "    }",
                        "    /**",
                        "     * @dev Storage slot with the admin of the contract.",
                        "     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is",
                        "     * validated in the constructor.",
                        "     */",
                        "    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;",
                        "    /**",
                        "     * @dev Returns the current admin.",
                        "     */",
                        "    function _getAdmin() internal view returns (address) {",
                        "        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;",
                        "    }",
                        "    /**",
                        "     * @dev Stores a new address in the EIP1967 admin slot.",
                        "     */",
                        "    function _setAdmin(address newAdmin) internal {",
                        "        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");",
                        "        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;",
                        "    }",
                        "}",
                        "/**",
                        " * @dev This abstract contract provides event emitting update functions for",
                        " * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.",
                        " *",
                        " * @custom:oz-upgrades-unsafe-allow delegatecall",
                        " */",
                        "abstract contract ERC1967Upgrade is ERC1967Storage {",
                        "    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;",
                        "    /**",
                        "     * @dev Emitted when the implementation is upgraded.",
                        "     */",
                        "    event Upgraded(address indexed implementation);",
                        "    /**",
                        "     * @dev Emitted when the beacon is upgraded.",
                        "     */",
                        "    event BeaconUpgraded(address indexed beacon);",
                        "    /**",
                        "     * @dev Emitted when the admin account has changed.",
                        "     */",
                        "    event AdminChanged(address previousAdmin, address newAdmin);",
                        "    /**",
                        "     * @dev Perform implementation upgrade",
                        "     *",
                        "     * Emits an {Upgraded} event.",
                        "     */",
                        "    function _upgradeTo(address newImplementation) internal {",
                        "        _setImplementation(newImplementation);",
                        "        emit Upgraded(newImplementation);",
                        "    }",
                        "    /**",
                        "     * @dev Perform implementation upgrade with additional setup call.",
                        "     *",
                        "     * Emits an {Upgraded} event.",
                        "     */",
                        "    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {",
                        "        _setImplementation(newImplementation);",
                        "        emit Upgraded(newImplementation);",
                        "        if (data.length > 0 || forceCall) {",
                        "            Address.functionDelegateCall(newImplementation, data);",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.",
                        "     *",
                        "     * Emits an {Upgraded} event.",
                        "     */",
                        "    function _upgradeToAndCallSecure(address newImplementation, bytes memory data, bool forceCall) internal {",
                        "        address oldImplementation = _getImplementation();",
                        "        _setImplementation(newImplementation);",
                        "        if (data.length > 0 || forceCall) {",
                        "            Address.functionDelegateCall(newImplementation, data);",
                        "        }",
                        "        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);",
                        "        if (!rollbackTesting.value) {",
                        "            rollbackTesting.value = true;",
                        "            Address.functionDelegateCall(",
                        "                newImplementation,",
                        "                abi.encodeWithSignature(",
                        "                    \"upgradeTo(address)\",",
                        "                    oldImplementation",
                        "                )",
                        "            );",
                        "            rollbackTesting.value = false;",
                        "            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");",
                        "            _setImplementation(newImplementation);",
                        "            emit Upgraded(newImplementation);",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does",
                        "     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).",
                        "     *",
                        "     * Emits a {BeaconUpgraded} event.",
                        "     */",
                        "    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {",
                        "        _setBeacon(newBeacon);",
                        "        emit BeaconUpgraded(newBeacon);",
                        "        if (data.length > 0 || forceCall) {",
                        "            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Changes the admin of the proxy.",
                        "     *",
                        "     * Emits an {AdminChanged} event.",
                        "     */",
                        "    function _changeAdmin(address newAdmin) internal {",
                        "        emit AdminChanged(_getAdmin(), newAdmin);",
                        "        _setAdmin(newAdmin);",
                        "    }",
                        "}",
                        "/**",
                        " * @dev Base contract for building openzeppelin-upgrades compatible implementations for the {ERC1967Proxy}. It includes",
                        " * publicly available upgrade functions that are called by the plugin and by the secure upgrade mechanism to verify",
                        " * continuation of the upgradability.",
                        " *",
                        " * The {_authorizeUpgrade} function MUST be overridden to include access restriction to the upgrade mechanism.",
                        " */",
                        "abstract contract UUPSUpgradeable is ERC1967Upgrade {",
                        "    function upgradeTo(address newImplementation) external virtual {",
                        "        _authorizeUpgrade(newImplementation);",
                        "        _upgradeToAndCallSecure(newImplementation, bytes(\"\"), false);",
                        "    }",
                        "    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual {",
                        "        _authorizeUpgrade(newImplementation);",
                        "        _upgradeToAndCallSecure(newImplementation, data, true);",
                        "    }",
                        "    function _authorizeUpgrade(address newImplementation) internal virtual;",
                        "}",
                        "contract BeaconProxy is Proxy, ERC1967Upgrade {",
                        "        _upgradeBeaconToAndCall(beacon, data, false);",
                        "    function _beacon() internal view virtual returns (address) {",
                        "        return _getBeacon();",
                        "        return IBeacon(_getBeacon()).implementation();",
                        "     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.",
                        "        _upgradeBeaconToAndCall(beacon, data, false);",
                        "     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.",
                        "        _changeAdmin(admin_);",
                        "        if (msg.sender == _getAdmin()) {",
                        "        admin_ = _getAdmin();",
                        "        _changeAdmin(newAdmin);",
                        "    function upgradeTo(address newImplementation) external ifAdmin {",
                        "        _upgradeToAndCall(newImplementation, bytes(\"\"), false);",
                        "    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {",
                        "        _upgradeToAndCall(newImplementation, data, true);",
                        "    function _admin() internal view virtual returns (address) {",
                        "        return _getAdmin();",
                        "        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");",
                        " * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.",
                        "/**",
                        " * @dev Library for reading and writing primitive types to specific storage slots.",
                        " *",
                        " * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.",
                        " * This library helps with reading and writing to such slots without the need for inline assembly.",
                        " *",
                        " * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.",
                        " *",
                        " * Example usage to set ERC1967 implementation slot:",
                        " * ```",
                        " * contract ERC1967 {",
                        " *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;",
                        " *",
                        " *     function _getImplementation() internal view returns (address) {",
                        " *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;",
                        " *     }",
                        " *",
                        " *     function _setImplementation(address newImplementation) internal {",
                        " *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");",
                        " *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;",
                        " *     }",
                        " * }",
                        " * ```",
                        " *",
                        " * Available since v4.1.0 for `address`, `bool`, `bytes32`, and `uint256`.",
                        " */",
                        "library StorageSlot {",
                        "    struct AddressSlot {",
                        "        address value;",
                        "    }",
                        "    struct BooleanSlot {",
                        "        bool value;",
                        "    }",
                        "    struct Bytes32Slot {",
                        "        bytes32 value;",
                        "    }",
                        "    struct Uint256Slot {",
                        "        uint256 value;",
                        "    }",
                        "    /**",
                        "     * @dev Returns an `AddressSlot` with member `value` located at `slot`.",
                        "     */",
                        "    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {",
                        "        assembly {",
                        "            r.slot := slot",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.",
                        "     */",
                        "    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {",
                        "        assembly {",
                        "            r.slot := slot",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.",
                        "     */",
                        "    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {",
                        "        assembly {",
                        "            r.slot := slot",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.",
                        "     */",
                        "    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {",
                        "        assembly {",
                        "            r.slot := slot",
                        "        }",
                        "    }",
                        "}"
                    ],
                    "del": [
                        " *",
                        " * Upgradeability is only provided internally through {_upgradeTo}. For an externally upgradeable proxy see",
                        " * {TransparentUpgradeableProxy}.",
                        "contract ERC1967Proxy is Proxy {",
                        "        _setImplementation(_logic);",
                        "        if(_data.length > 0) {",
                        "            Address.functionDelegateCall(_logic, _data);",
                        "        }",
                        "    /**",
                        "     * @dev Emitted when the implementation is upgraded.",
                        "     */",
                        "    event Upgraded(address indexed implementation);",
                        "    /**",
                        "     * @dev Storage slot with the address of the current implementation.",
                        "     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is",
                        "     * validated in the constructor.",
                        "     */",
                        "    bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;",
                        "        bytes32 slot = _IMPLEMENTATION_SLOT;",
                        "        assembly {",
                        "            impl := sload(slot)",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Upgrades the proxy to a new implementation.",
                        "     *",
                        "     * Emits an {Upgraded} event.",
                        "     */",
                        "    function _upgradeTo(address newImplementation) internal virtual {",
                        "        _setImplementation(newImplementation);",
                        "        emit Upgraded(newImplementation);",
                        "    }",
                        "    /**",
                        "     * @dev Stores a new address in the EIP1967 implementation slot.",
                        "     */",
                        "    function _setImplementation(address newImplementation) private {",
                        "        require(Address.isContract(newImplementation), \"ERC1967Proxy: new implementation is not a contract\");",
                        "        bytes32 slot = _IMPLEMENTATION_SLOT;",
                        "        assembly {",
                        "            sstore(slot, newImplementation)",
                        "        }",
                        "contract BeaconProxy is Proxy {",
                        "    /**",
                        "     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.",
                        "     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.",
                        "     */",
                        "    bytes32 private constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;",
                        "        _setBeacon(beacon, data);",
                        "    function _beacon() internal view virtual returns (address beacon) {",
                        "        bytes32 slot = _BEACON_SLOT;",
                        "        assembly {",
                        "            beacon := sload(slot)",
                        "        }",
                        "        return IBeacon(_beacon()).implementation();",
                        "     * @dev Changes the proxy to use a new beacon.",
                        "        require(",
                        "            Address.isContract(beacon),",
                        "            \"BeaconProxy: beacon is not a contract\"",
                        "        );",
                        "        require(",
                        "            Address.isContract(IBeacon(beacon).implementation()),",
                        "            \"BeaconProxy: beacon implementation is not a contract\"",
                        "        );",
                        "        bytes32 slot = _BEACON_SLOT;",
                        "        assembly {",
                        "            sstore(slot, beacon)",
                        "        }",
                        "        if (data.length > 0) {",
                        "            Address.functionDelegateCall(_implementation(), data, \"BeaconProxy: function call failed\");",
                        "        }",
                        "     * optionally initialized with `_data` as explained in {UpgradeableProxy-constructor}.",
                        "        _setAdmin(admin_);",
                        "    /**",
                        "     * @dev Emitted when the admin account has changed.",
                        "     */",
                        "    event AdminChanged(address previousAdmin, address newAdmin);",
                        "    /**",
                        "     * @dev Storage slot with the admin of the contract.",
                        "     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is",
                        "     * validated in the constructor.",
                        "     */",
                        "    bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;",
                        "        if (msg.sender == _admin()) {",
                        "        admin_ = _admin();",
                        "        require(newAdmin != address(0), \"TransparentUpgradeableProxy: new admin is the zero address\");",
                        "        emit AdminChanged(_admin(), newAdmin);",
                        "        _setAdmin(newAdmin);",
                        "    function upgradeTo(address newImplementation) external virtual ifAdmin {",
                        "        _upgradeTo(newImplementation);",
                        "    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable virtual ifAdmin {",
                        "        _upgradeTo(newImplementation);",
                        "        Address.functionDelegateCall(newImplementation, data);",
                        "    function _admin() internal view virtual returns (address adm) {",
                        "        bytes32 slot = _ADMIN_SLOT;",
                        "        assembly {",
                        "            adm := sload(slot)",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Stores a new address in the EIP1967 admin slot.",
                        "     */",
                        "    function _setAdmin(address newAdmin) private {",
                        "        bytes32 slot = _ADMIN_SLOT;",
                        "        assembly {",
                        "            sstore(slot, newAdmin)",
                        "        }",
                        "        require(msg.sender != _admin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");",
                        " * possible by providing the encoded function call as the `_data` argument to {UpgradeableProxy-constructor}."
                    ]
                }
            }
        ]
    },
    "4.0.0": {
        " * `Context`: making `_msgData` return `bytes calldata` instead of `bytes memory` ([#2492](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2492))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2492": {
                    "add": [
                        "    function _msgSender() internal view virtual override returns (address msgSender) {",
                        "        if (msg.sender == getHubAddr()) {",
                        "            assembly { msgSender := shr(96, calldataload(sub(calldatasize(), 20))) }",
                        "            return msg.sender;",
                        "    function _msgData() internal view virtual override returns (bytes calldata) {",
                        "        if (msg.sender == getHubAddr()) {",
                        "            return msg.data[:msg.data.length - 20];",
                        "            return msg.data;",
                        "    function _msgData() internal override(Context, GSNRecipient) view virtual returns (bytes calldata) {",
                        "    function _msgData() internal view virtual returns (bytes calldata) {"
                    ],
                    "del": [
                        "    function _msgSender() internal view virtual override returns (address) {",
                        "        if (msg.sender != getHubAddr()) {",
                        "            return msg.sender;",
                        "            return _getRelayedCallSender();",
                        "    function _msgData() internal view virtual override returns (bytes memory) {",
                        "        if (msg.sender != getHubAddr()) {",
                        "            return msg.data;",
                        "            return _getRelayedCallData();",
                        "    function _getRelayedCallSender() private pure returns (address result) {",
                        "        bytes memory array = msg.data;",
                        "        uint256 index = msg.data.length;",
                        "        assembly {",
                        "            result := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)",
                        "        }",
                        "        return result;",
                        "    }",
                        "    function _getRelayedCallData() private pure returns (bytes memory) {",
                        "        uint256 actualDataLength = msg.data.length - 20;",
                        "        bytes memory actualData = new bytes(actualDataLength);",
                        "        for (uint256 i = 0; i < actualDataLength; ++i) {",
                        "            actualData[i] = msg.data[i];",
                        "        }",
                        "        return actualData;",
                        "    }",
                        "    function _msgData() internal override(Context, GSNRecipient) view virtual returns (bytes memory) {",
                        "    function _msgData() internal view virtual returns (bytes memory) {"
                    ]
                }
            }
        ],
        " * `ERC20`: removed the `_setDecimals` function and the storage slot associated to decimals. ([#2502](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2502))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2502": {
                    "add": [
                        "    uint8 immutable private _decimals;",
                        "    constructor (string memory name_, string memory symbol_, uint8 decimals_) ERC20(name_, symbol_) {",
                        "        _decimals = decimals_;",
                        "    }",
                        "    function decimals() public view virtual override returns (uint8) {",
                        "        return _decimals;",
                        "     * @dev Sets the values for {name} and {symbol}.",
                        "     * The defaut value of {decimals} is 18. To select a different value for",
                        "     * {decimals} you should overload it.",
                        "     * Ether and Wei. This is the value {ERC20} uses, unless this function is",
                        "     * overloaded;",
                        "        return 18;"
                    ],
                    "del": [
                        "    constructor (string memory name, string memory symbol, uint8 decimals) ERC20(name, symbol) {",
                        "        _setupDecimals(decimals);",
                        "    uint8 private _decimals;",
                        "     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with",
                        "     * a default value of 18.",
                        "     * To select a different value for {decimals}, use {_setupDecimals}.",
                        "        _decimals = 18;",
                        "     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is",
                        "     * called.",
                        "        return _decimals;",
                        "    /**",
                        "     * @dev Sets {decimals} to a value other than the default one of 18.",
                        "     *",
                        "     * WARNING: This function should only be called from the constructor. Most",
                        "     * applications that interact with token contracts will not expect",
                        "     * {decimals} to ever change, and may work incorrectly if it does.",
                        "     */",
                        "    function _setupDecimals(uint8 decimals_) internal virtual {",
                        "        _decimals = decimals_;",
                        "    }"
                    ]
                }
            }
        ],
        " * `EnumerableMap`: change implementation to optimize for `key \u2192 value` lookups instead of enumeration. ([#2518](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2518))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2518": {
                    "add": [
                        "    using EnumerableSet for EnumerableSet.Bytes32Set;",
                        "        EnumerableSet.Bytes32Set _keys;",
                        "        mapping (bytes32 => bytes32) _values;",
                        "        map._values[key] = value;",
                        "        return map._keys.add(key);",
                        "        delete map._values[key];",
                        "        return map._keys.remove(key);",
                        "        return map._keys.contains(key);",
                        "        return map._keys.length();",
                        "        bytes32 key = map._keys.at(index);",
                        "        return (key, map._values[key]);",
                        "        bytes32 value = map._values[key];",
                        "        if (value == bytes32(0)) {",
                        "            return (_contains(map, key), bytes32(0));",
                        "        } else {",
                        "            return (true, value);",
                        "        }",
                        "        bytes32 value = map._values[key];",
                        "        require(value != 0 || _contains(map, key), \"EnumerableMap: nonexistent key\");",
                        "        return value;",
                        "        bytes32 value = map._values[key];",
                        "        require(value != 0 || _contains(map, key), errorMessage);",
                        "        return value;"
                    ],
                    "del": [
                        "    struct MapEntry {",
                        "        bytes32 _key;",
                        "        bytes32 _value;",
                        "    }",
                        "        MapEntry[] _entries;",
                        "        mapping (bytes32 => uint256) _indexes;",
                        "        uint256 keyIndex = map._indexes[key];",
                        "            map._entries.push(MapEntry({ _key: key, _value: value }));",
                        "            map._indexes[key] = map._entries.length;",
                        "            return true;",
                        "        } else {",
                        "            map._entries[keyIndex - 1]._value = value;",
                        "            return false;",
                        "        }",
                        "        uint256 keyIndex = map._indexes[key];",
                        "            uint256 toDeleteIndex = keyIndex - 1;",
                        "            uint256 lastIndex = map._entries.length - 1;",
                        "            MapEntry storage lastEntry = map._entries[lastIndex];",
                        "            map._entries[toDeleteIndex] = lastEntry;",
                        "            map._entries.pop();",
                        "            delete map._indexes[key];",
                        "            return true;",
                        "        } else {",
                        "            return false;",
                        "        }",
                        "        return map._indexes[key] != 0;",
                        "        return map._entries.length;",
                        "        require(map._entries.length > index, \"EnumerableMap: index out of bounds\");",
                        "        MapEntry storage entry = map._entries[index];",
                        "        return (entry._key, entry._value);",
                        "        uint256 keyIndex = map._indexes[key];",
                        "        uint256 keyIndex = map._indexes[key];",
                        "        uint256 keyIndex = map._indexes[key];"
                    ]
                }
            }
        ],
        " * `GSN`: deprecate GSNv1 support in favor of upcoming support for GSNv2. ([#2521](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2521))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2521": {
                    "add": [
                        " * manner, since when dealing with meta-transactions the account sending and"
                    ],
                    "del": [
                        "/**",
                        " * @dev Base GSN recipient contract: includes the {IRelayRecipient} interface",
                        " * and enables GSN support on all contracts in the inheritance tree.",
                        " *",
                        " * TIP: This contract is abstract. The functions {IRelayRecipient-acceptRelayedCall},",
                        " *  {_preRelayedCall}, and {_postRelayedCall} are not implemented and must be",
                        " * provided by derived contracts. See the",
                        " * xref:ROOT:gsn-strategies.adoc#gsn-strategies[GSN strategies] for more",
                        " * information on how to use the pre-built {GSNRecipientSignature} and",
                        " * {GSNRecipientERC20Fee}, or how to write your own.",
                        " */",
                        "abstract contract GSNRecipient is IRelayRecipient, Context {",
                        "    address private _relayHub = 0xD216153c06E857cD7f72665E0aF1d7D82172F494;",
                        "    uint256 constant private _RELAYED_CALL_ACCEPTED = 0;",
                        "    uint256 constant private _RELAYED_CALL_REJECTED = 11;",
                        "    uint256 constant internal _POST_RELAYED_CALL_MAX_GAS = 100000;",
                        "    /**",
                        "     * @dev Emitted when a contract changes its {IRelayHub} contract to a new one.",
                        "     */",
                        "    event RelayHubChanged(address indexed oldRelayHub, address indexed newRelayHub);",
                        "    /**",
                        "     * @dev Returns the address of the {IRelayHub} contract for this recipient.",
                        "     */",
                        "    function getHubAddr() public view virtual override returns (address) {",
                        "        return _relayHub;",
                        "    }",
                        "    /**",
                        "     * @dev Switches to a new {IRelayHub} instance. This method is added for future-proofing: there's no reason to not",
                        "     * use the default instance.",
                        "     *",
                        "     * IMPORTANT: After upgrading, the {GSNRecipient} will no longer be able to receive relayed calls from the old",
                        "     * {IRelayHub} instance. Additionally, all funds should be previously withdrawn via {_withdrawDeposits}.",
                        "     */",
                        "    function _upgradeRelayHub(address newRelayHub) internal virtual {",
                        "        address currentRelayHub = _relayHub;",
                        "        require(newRelayHub != address(0), \"GSNRecipient: new RelayHub is the zero address\");",
                        "        require(newRelayHub != currentRelayHub, \"GSNRecipient: new RelayHub is the current one\");",
                        "        emit RelayHubChanged(currentRelayHub, newRelayHub);",
                        "        _relayHub = newRelayHub;",
                        "    }",
                        "    /**",
                        "     * @dev Returns the version string of the {IRelayHub} for which this recipient implementation was built. If",
                        "     * {_upgradeRelayHub} is used, the new {IRelayHub} instance should be compatible with this version.",
                        "     */",
                        "    function relayHubVersion() public view virtual returns (string memory) {",
                        "        return \"1.0.0\";",
                        "    }",
                        "    /**",
                        "     * @dev Withdraws the recipient's deposits in `RelayHub`.",
                        "     *",
                        "     * Derived contracts should expose this in an external interface with proper access control.",
                        "     */",
                        "    function _withdrawDeposits(uint256 amount, address payable payee) internal virtual {",
                        "        IRelayHub(getHubAddr()).withdraw(amount, payee);",
                        "    }",
                        "    /**",
                        "     * @dev Replacement for msg.sender. Returns the actual sender of a transaction: msg.sender for regular transactions,",
                        "     * and the end-user for GSN relayed calls (where msg.sender is actually `RelayHub`).",
                        "     *",
                        "     * IMPORTANT: Contracts derived from {GSNRecipient} should never use `msg.sender`, and use {_msgSender} instead.",
                        "     */",
                        "    function _msgSender() internal view virtual override returns (address msgSender) {",
                        "        if (msg.sender == getHubAddr()) {",
                        "            assembly { msgSender := shr(96, calldataload(sub(calldatasize(), 20))) }",
                        "        } else {",
                        "            return msg.sender;",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Replacement for msg.data. Returns the actual calldata of a transaction: msg.data for regular transactions,",
                        "     * and a reduced version for GSN relayed calls (where msg.data contains additional information).",
                        "     *",
                        "     * IMPORTANT: Contracts derived from {GSNRecipient} should never use `msg.data`, and use {_msgData} instead.",
                        "     */",
                        "    function _msgData() internal view virtual override returns (bytes calldata) {",
                        "        if (msg.sender == getHubAddr()) {",
                        "            return msg.data[:msg.data.length - 20];",
                        "        } else {",
                        "            return msg.data;",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev See `IRelayRecipient.preRelayedCall`.",
                        "     *",
                        "     * This function should not be overridden directly, use `_preRelayedCall` instead.",
                        "     *",
                        "     * * Requirements:",
                        "     *",
                        "     * - the caller must be the `RelayHub` contract.",
                        "     */",
                        "    function preRelayedCall(bytes memory context) public virtual override returns (bytes32) {",
                        "        require(msg.sender == getHubAddr(), \"GSNRecipient: caller is not RelayHub\");",
                        "        return _preRelayedCall(context);",
                        "    }",
                        "    /**",
                        "     * @dev See `IRelayRecipient.preRelayedCall`.",
                        "     *",
                        "     * Called by `GSNRecipient.preRelayedCall`, which asserts the caller is the `RelayHub` contract. Derived contracts",
                        "     * must implement this function with any relayed-call preprocessing they may wish to do.",
                        "     *",
                        "     */",
                        "    function _preRelayedCall(bytes memory context) internal virtual returns (bytes32);",
                        "    /**",
                        "     * @dev See `IRelayRecipient.postRelayedCall`.",
                        "     *",
                        "     * This function should not be overridden directly, use `_postRelayedCall` instead.",
                        "     *",
                        "     * * Requirements:",
                        "     *",
                        "     * - the caller must be the `RelayHub` contract.",
                        "     */",
                        "    function postRelayedCall(bytes memory context, bool success, uint256 actualCharge, bytes32 preRetVal) public virtual override {",
                        "        require(msg.sender == getHubAddr(), \"GSNRecipient: caller is not RelayHub\");",
                        "        _postRelayedCall(context, success, actualCharge, preRetVal);",
                        "    }",
                        "    /**",
                        "     * @dev See `IRelayRecipient.postRelayedCall`.",
                        "     *",
                        "     * Called by `GSNRecipient.postRelayedCall`, which asserts the caller is the `RelayHub` contract. Derived contracts",
                        "     * must implement this function with any relayed-call postprocessing they may wish to do.",
                        "     *",
                        "     */",
                        "    function _postRelayedCall(bytes memory context, bool success, uint256 actualCharge, bytes32 preRetVal) internal virtual;",
                        "    /**",
                        "     * @dev Return this in acceptRelayedCall to proceed with the execution of a relayed call. Note that this contract",
                        "     * will be charged a fee by RelayHub",
                        "     */",
                        "    function _approveRelayedCall() internal pure virtual returns (uint256, bytes memory) {",
                        "        return _approveRelayedCall(\"\");",
                        "    }",
                        "    /**",
                        "     * @dev See `GSNRecipient._approveRelayedCall`.",
                        "     *",
                        "     * This overload forwards `context` to _preRelayedCall and _postRelayedCall.",
                        "     */",
                        "    function _approveRelayedCall(bytes memory context) internal pure virtual returns (uint256, bytes memory) {",
                        "        return (_RELAYED_CALL_ACCEPTED, context);",
                        "    }",
                        "    /**",
                        "     * @dev Return this in acceptRelayedCall to impede execution of a relayed call. No fees will be charged.",
                        "     */",
                        "    function _rejectRelayedCall(uint256 errorCode) internal pure virtual returns (uint256, bytes memory) {",
                        "        return (_RELAYED_CALL_REJECTED + errorCode, \"\");",
                        "    }",
                        "    /*",
                        "     * @dev Calculates how much RelayHub will charge a recipient for using `gas` at a `gasPrice`, given a relayer's",
                        "     * `serviceFee`.",
                        "     */",
                        "    function _computeCharge(uint256 gas, uint256 gasPrice, uint256 serviceFee) internal pure virtual returns (uint256) {",
                        "        return (gas * gasPrice * (100 + serviceFee)) / 100;",
                        "    }",
                        "}",
                        "/**",
                        " * @dev A xref:ROOT:gsn-strategies.adoc#gsn-strategies[GSN strategy] that charges transaction fees in a special purpose ERC20",
                        " * token, which we refer to as the gas payment token. The amount charged is exactly the amount of Ether charged to the",
                        " * recipient. This means that the token is essentially pegged to the value of Ether.",
                        " *",
                        " * The distribution strategy of the gas payment token to users is not defined by this contract. It's a mintable token",
                        " * whose only minter is the recipient, so the strategy must be implemented in a derived contract, making use of the",
                        " * internal {_mint} function.",
                        " */",
                        "contract GSNRecipientERC20Fee is GSNRecipient {",
                        "    using SafeERC20 for __unstable__ERC20Owned;",
                        "    enum GSNRecipientERC20FeeErrorCodes {",
                        "        INSUFFICIENT_BALANCE",
                        "    }",
                        "    __unstable__ERC20Owned private _token;",
                        "    /**",
                        "     * @dev The arguments to the constructor are the details that the gas payment token will have: `name` and `symbol`. `decimals` is hard-coded to 18.",
                        "     */",
                        "    constructor(string memory name, string memory symbol) {",
                        "        _token = new __unstable__ERC20Owned(name, symbol);",
                        "    }",
                        "    /**",
                        "     * @dev Returns the gas payment token.",
                        "     */",
                        "    function token() public view virtual returns (__unstable__ERC20Owned) {",
                        "        return _token;",
                        "    }",
                        "    /**",
                        "     * @dev Internal function that mints the gas payment token. Derived contracts should expose this function in their public API, with proper access control mechanisms.",
                        "     */",
                        "    function _mint(address account, uint256 amount) internal virtual {",
                        "        token().mint(account, amount);",
                        "    }",
                        "    /**",
                        "     * @dev Ensures that only users with enough gas payment token balance can have transactions relayed through the GSN.",
                        "     */",
                        "    function acceptRelayedCall(",
                        "        address,",
                        "        address from,",
                        "        bytes memory,",
                        "        uint256 transactionFee,",
                        "        uint256 gasPrice,",
                        "        uint256,",
                        "        uint256,",
                        "        bytes memory,",
                        "        uint256 maxPossibleCharge",
                        "    )",
                        "        public",
                        "        view",
                        "        virtual",
                        "        override",
                        "        returns (uint256, bytes memory)",
                        "    {",
                        "        if (token().balanceOf(from) < maxPossibleCharge) {",
                        "            return _rejectRelayedCall(uint256(GSNRecipientERC20FeeErrorCodes.INSUFFICIENT_BALANCE));",
                        "        }",
                        "        return _approveRelayedCall(abi.encode(from, maxPossibleCharge, transactionFee, gasPrice));",
                        "    }",
                        "    /**",
                        "     * @dev Implements the precharge to the user. The maximum possible charge (depending on gas limit, gas price, and",
                        "     * fee) will be deducted from the user balance of gas payment token. Note that this is an overestimation of the",
                        "     * actual charge, necessary because we cannot predict how much gas the execution will actually need. The remainder",
                        "     * is returned to the user in {_postRelayedCall}.",
                        "     */",
                        "    function _preRelayedCall(bytes memory context) internal virtual override returns (bytes32) {",
                        "        (address from, uint256 maxPossibleCharge) = abi.decode(context, (address, uint256));",
                        "        token().safeTransferFrom(from, address(this), maxPossibleCharge);",
                        "        return 0;",
                        "    }",
                        "    /**",
                        "     * @dev Returns to the user the extra amount that was previously charged, once the actual execution cost is known.",
                        "     */",
                        "    function _postRelayedCall(bytes memory context, bool, uint256 actualCharge, bytes32) internal virtual override {",
                        "        (address from, uint256 maxPossibleCharge, uint256 transactionFee, uint256 gasPrice) =",
                        "            abi.decode(context, (address, uint256, uint256, uint256));",
                        "        uint256 overestimation = _computeCharge(_POST_RELAYED_CALL_MAX_GAS - 10000, gasPrice, transactionFee);",
                        "        actualCharge = actualCharge - overestimation;",
                        "        token().safeTransfer(from, maxPossibleCharge - actualCharge);",
                        "    }",
                        "}",
                        "/**",
                        " * @title __unstable__ERC20Owned",
                        " * @dev An ERC20 token owned by another contract, which has minting permissions and can use transferFrom to receive",
                        " * anyone's tokens. This contract is an internal helper for GSNRecipientERC20Fee, and should not be used",
                        " * outside of this context.",
                        " */",
                        "contract __unstable__ERC20Owned is ERC20, Ownable {",
                        "    uint256 private constant _UINT256_MAX = 2**256 - 1;",
                        "    constructor(string memory name, string memory symbol) ERC20(name, symbol) { }",
                        "    function mint(address account, uint256 amount) public virtual onlyOwner {",
                        "        _mint(account, amount);",
                        "    }",
                        "    function allowance(address tokenOwner, address spender) public view virtual override returns (uint256) {",
                        "        if (spender == owner()) {",
                        "            return _UINT256_MAX;",
                        "        } else {",
                        "            return super.allowance(tokenOwner, spender);",
                        "        }",
                        "    }",
                        "    function _approve(address tokenOwner, address spender, uint256 value) internal virtual override {",
                        "        if (spender == owner()) {",
                        "            return;",
                        "        } else {",
                        "            super._approve(tokenOwner, spender, value);",
                        "        }",
                        "    }",
                        "    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {",
                        "        if (recipient == owner()) {",
                        "            _transfer(sender, recipient, amount);",
                        "            return true;",
                        "        } else {",
                        "            return super.transferFrom(sender, recipient, amount);",
                        "        }",
                        "    }",
                        "}",
                        "/**",
                        " * @dev A xref:ROOT:gsn-strategies.adoc#gsn-strategies[GSN strategy] that allows relayed transactions through when they are",
                        " * accompanied by the signature of a trusted signer. The intent is for this signature to be generated by a server that",
                        " * performs validations off-chain. Note that nothing is charged to the user in this scheme. Thus, the server should make",
                        " * sure to account for this in their economic and threat model.",
                        " */",
                        "contract GSNRecipientSignature is GSNRecipient {",
                        "    using ECDSA for bytes32;",
                        "    address private _trustedSigner;",
                        "    enum GSNRecipientSignatureErrorCodes {",
                        "        INVALID_SIGNER",
                        "    }",
                        "    /**",
                        "     * @dev Sets the trusted signer that is going to be producing signatures to approve relayed calls.",
                        "     */",
                        "    constructor(address trustedSigner) {",
                        "        require(trustedSigner != address(0), \"GSNRecipientSignature: trusted signer is the zero address\");",
                        "        _trustedSigner = trustedSigner;",
                        "    }",
                        "    /**",
                        "     * @dev Ensures that only transactions with a trusted signature can be relayed through the GSN.",
                        "     */",
                        "    function acceptRelayedCall(",
                        "        address relay,",
                        "        address from,",
                        "        bytes memory encodedFunction,",
                        "        uint256 transactionFee,",
                        "        uint256 gasPrice,",
                        "        uint256 gasLimit,",
                        "        uint256 nonce,",
                        "        bytes memory approvalData,",
                        "        uint256",
                        "    )",
                        "        public",
                        "        view",
                        "        virtual",
                        "        override",
                        "        returns (uint256, bytes memory)",
                        "    {",
                        "        bytes memory blob = abi.encodePacked(",
                        "            relay,",
                        "            from,",
                        "            encodedFunction,",
                        "            transactionFee,",
                        "            gasPrice,",
                        "            gasLimit,",
                        "        );",
                        "        if (keccak256(blob).toEthSignedMessageHash().recover(approvalData) == _trustedSigner) {",
                        "            return _approveRelayedCall();",
                        "        } else {",
                        "            return _rejectRelayedCall(uint256(GSNRecipientSignatureErrorCodes.INVALID_SIGNER));",
                        "        }",
                        "    }",
                        "    function _preRelayedCall(bytes memory) internal virtual override returns (bytes32) { }",
                        "    function _postRelayedCall(bytes memory, bool, uint256, bytes32) internal virtual override { }",
                        "}",
                        "/**",
                        " * @dev Interface for `RelayHub`, the core contract of the GSN. Users should not need to interact with this contract",
                        " * directly.",
                        " *",
                        " * See the https://github.com/OpenZeppelin/openzeppelin-gsn-helpers[OpenZeppelin GSN helpers] for more information on",
                        " * how to deploy an instance of `RelayHub` on your local test network.",
                        " */",
                        "interface IRelayHub {",
                        "    /**",
                        "     * @dev Adds stake to a relay and sets its `unstakeDelay`. If the relay does not exist, it is created, and the caller",
                        "     * of this function becomes its owner. If the relay already exists, only the owner can call this function. A relay",
                        "     * cannot be its own owner.",
                        "     *",
                        "     * All Ether in this function call will be added to the relay's stake.",
                        "     * Its unstake delay will be assigned to `unstakeDelay`, but the new value must be greater or equal to the current one.",
                        "     *",
                        "     * Emits a {Staked} event.",
                        "     */",
                        "    function stake(address relayaddr, uint256 unstakeDelay) external payable;",
                        "    /**",
                        "     * @dev Emitted when a relay's stake or unstakeDelay are increased",
                        "     */",
                        "    event Staked(address indexed relay, uint256 stake, uint256 unstakeDelay);",
                        "    /**",
                        "     * @dev Registers the caller as a relay.",
                        "     * The relay must be staked for, and not be a contract (i.e. this function must be called directly from an EOA).",
                        "     *",
                        "     * This function can be called multiple times, emitting new {RelayAdded} events. Note that the received",
                        "     * `transactionFee` is not enforced by {relayCall}.",
                        "     *",
                        "     * Emits a {RelayAdded} event.",
                        "     */",
                        "    function registerRelay(uint256 transactionFee, string calldata url) external;",
                        "    /**",
                        "     * @dev Emitted when a relay is registered or re-registered. Looking at these events (and filtering out",
                        "     * {RelayRemoved} events) lets a client discover the list of available relays.",
                        "     */",
                        "    event RelayAdded(address indexed relay, address indexed owner, uint256 transactionFee, uint256 stake, uint256 unstakeDelay, string url);",
                        "    /**",
                        "     * @dev Removes (deregisters) a relay. Unregistered (but staked for) relays can also be removed.",
                        "     *",
                        "     * Can only be called by the owner of the relay. After the relay's `unstakeDelay` has elapsed, {unstake} will be",
                        "     * callable.",
                        "     *",
                        "     * Emits a {RelayRemoved} event.",
                        "     */",
                        "    function removeRelayByOwner(address relay) external;",
                        "    /**",
                        "     * @dev Emitted when a relay is removed (deregistered). `unstakeTime` is the time when unstake will be callable.",
                        "     */",
                        "    event RelayRemoved(address indexed relay, uint256 unstakeTime);",
                        "    /** Deletes the relay from the system, and gives back its stake to the owner.",
                        "     *",
                        "     * Can only be called by the relay owner, after `unstakeDelay` has elapsed since {removeRelayByOwner} was called.",
                        "     *",
                        "     * Emits an {Unstaked} event.",
                        "     */",
                        "    function unstake(address relay) external;",
                        "    /**",
                        "     * @dev Emitted when a relay is unstaked for, including the returned stake.",
                        "     */",
                        "    event Unstaked(address indexed relay, uint256 stake);",
                        "    enum RelayState {",
                        "    }",
                        "    /**",
                        "     * @dev Returns a relay's status. Note that relays can be deleted when unstaked or penalized, causing this function",
                        "     * to return an empty entry.",
                        "     */",
                        "    function getRelay(address relay) external view returns (uint256 totalStake, uint256 unstakeDelay, uint256 unstakeTime, address payable owner, RelayState state);",
                        "    /**",
                        "     * @dev Deposits Ether for a contract, so that it can receive (and pay for) relayed transactions.",
                        "     *",
                        "     * Unused balance can only be withdrawn by the contract itself, by calling {withdraw}.",
                        "     *",
                        "     * Emits a {Deposited} event.",
                        "     */",
                        "    function depositFor(address target) external payable;",
                        "    /**",
                        "     * @dev Emitted when {depositFor} is called, including the amount and account that was funded.",
                        "     */",
                        "    event Deposited(address indexed recipient, address indexed from, uint256 amount);",
                        "    /**",
                        "     * @dev Returns an account's deposits. These can be either a contract's funds, or a relay owner's revenue.",
                        "     */",
                        "    function balanceOf(address target) external view returns (uint256);",
                        "    /**",
                        "     * Withdraws from an account's balance, sending it back to it. Relay owners call this to retrieve their revenue, and",
                        "     * contracts can use it to reduce their funding.",
                        "     *",
                        "     * Emits a {Withdrawn} event.",
                        "     */",
                        "    function withdraw(uint256 amount, address payable dest) external;",
                        "    /**",
                        "     * @dev Emitted when an account withdraws funds from `RelayHub`.",
                        "     */",
                        "    event Withdrawn(address indexed account, address indexed dest, uint256 amount);",
                        "    /**",
                        "     * @dev Checks if the `RelayHub` will accept a relayed operation.",
                        "     * Multiple things must be true for this to happen:",
                        "     *  - all arguments must be signed for by the sender (`from`)",
                        "     *  - the sender's nonce must be the current one",
                        "     *  - the recipient must accept this transaction (via {acceptRelayedCall})",
                        "     *",
                        "     * Returns a `PreconditionCheck` value (`OK` when the transaction can be relayed), or a recipient-specific error",
                        "     * code if it returns one in {acceptRelayedCall}.",
                        "     */",
                        "    function canRelay(",
                        "        address relay,",
                        "        address from,",
                        "        address to,",
                        "        bytes calldata encodedFunction,",
                        "        uint256 transactionFee,",
                        "        uint256 gasPrice,",
                        "        uint256 gasLimit,",
                        "        uint256 nonce,",
                        "        bytes calldata signature,",
                        "        bytes calldata approvalData",
                        "    ) external view returns (uint256 status, bytes memory recipientContext);",
                        "    enum PreconditionCheck {",
                        "    }",
                        "    /**",
                        "     * @dev Relays a transaction.",
                        "     *",
                        "     * For this to succeed, multiple conditions must be met:",
                        "     *  - {canRelay} must `return PreconditionCheck.OK`",
                        "     *  - the sender must be a registered relay",
                        "     *  - the transaction's gas price must be larger or equal to the one that was requested by the sender",
                        "     *  - the transaction must have enough gas to not run out of gas if all internal transactions (calls to the",
                        "     * recipient) use all gas available to them",
                        "     *  - the recipient must have enough balance to pay the relay for the worst-case scenario (i.e. when all gas is",
                        "     * spent)",
                        "     *",
                        "     * If all conditions are met, the call will be relayed and the recipient charged. {preRelayedCall}, the encoded",
                        "     * function and {postRelayedCall} will be called in that order.",
                        "     *",
                        "     * Parameters:",
                        "     *  - `from`: the client originating the request",
                        "     *  - `to`: the target {IRelayRecipient} contract",
                        "     *  - `encodedFunction`: the function call to relay, including data",
                        "     *  - `transactionFee`: fee (%) the relay takes over actual gas cost",
                        "     *  - `gasPrice`: gas price the client is willing to pay",
                        "     *  - `gasLimit`: gas to forward when calling the encoded function",
                        "     *  - `nonce`: client's nonce",
                        "     *  - `signature`: client's signature over all previous params, plus the relay and RelayHub addresses",
                        "     *  - `approvalData`: dapp-specific data forwarded to {acceptRelayedCall}. This value is *not* verified by the",
                        "     * `RelayHub`, but it still can be used for e.g. a signature.",
                        "     *",
                        "     * Emits a {TransactionRelayed} event.",
                        "     */",
                        "    function relayCall(",
                        "        address from,",
                        "        address to,",
                        "        bytes calldata encodedFunction,",
                        "        uint256 transactionFee,",
                        "        uint256 gasPrice,",
                        "        uint256 gasLimit,",
                        "        uint256 nonce,",
                        "        bytes calldata signature,",
                        "        bytes calldata approvalData",
                        "    ) external;",
                        "    /**",
                        "     * @dev Emitted when an attempt to relay a call failed.",
                        "     *",
                        "     * This can happen due to incorrect {relayCall} arguments, or the recipient not accepting the relayed call. The",
                        "     * actual relayed call was not executed, and the recipient not charged.",
                        "     *",
                        "     * The `reason` parameter contains an error code: values 1-10 correspond to `PreconditionCheck` entries, and values",
                        "     * over 10 are custom recipient error codes returned from {acceptRelayedCall}.",
                        "     */",
                        "    event CanRelayFailed(address indexed relay, address indexed from, address indexed to, bytes4 selector, uint256 reason);",
                        "    /**",
                        "     * @dev Emitted when a transaction is relayed.",
                        "     * Useful when monitoring a relay's operation and relayed calls to a contract",
                        "     *",
                        "     * Note that the actual encoded function might be reverted: this is indicated in the `status` parameter.",
                        "     *",
                        "     * `charge` is the Ether value deducted from the recipient's balance, paid to the relay's owner.",
                        "     */",
                        "    event TransactionRelayed(address indexed relay, address indexed from, address indexed to, bytes4 selector, RelayCallStatus status, uint256 charge);",
                        "    enum RelayCallStatus {",
                        "    }",
                        "    /**",
                        "     * @dev Returns how much gas should be forwarded to a call to {relayCall}, in order to relay a transaction that will",
                        "     * spend up to `relayedCallStipend` gas.",
                        "     */",
                        "    function requiredGas(uint256 relayedCallStipend) external view returns (uint256);",
                        "    /**",
                        "     * @dev Returns the maximum recipient charge, given the amount of gas forwarded, gas price and relay fee.",
                        "     */",
                        "    function maxPossibleCharge(uint256 relayedCallStipend, uint256 gasPrice, uint256 transactionFee) external view returns (uint256);",
                        "    /**",
                        "     * @dev Penalize a relay that signed two transactions using the same nonce (making only the first one valid) and",
                        "     * different data (gas price, gas limit, etc. may be different).",
                        "     *",
                        "     * The (unsigned) transaction data and signature for both transactions must be provided.",
                        "     */",
                        "    function penalizeRepeatedNonce(bytes calldata unsignedTx1, bytes calldata signature1, bytes calldata unsignedTx2, bytes calldata signature2) external;",
                        "    /**",
                        "     * @dev Penalize a relay that sent a transaction that didn't target ``RelayHub``'s {registerRelay} or {relayCall}.",
                        "     */",
                        "    function penalizeIllegalTransaction(bytes calldata unsignedTx, bytes calldata signature) external;",
                        "    /**",
                        "     * @dev Emitted when a relay is penalized.",
                        "     */",
                        "    event Penalized(address indexed relay, address sender, uint256 amount);",
                        "    /**",
                        "     * @dev Returns an account's nonce in `RelayHub`.",
                        "     */",
                        "    function getNonce(address from) external view returns (uint256);",
                        "}",
                        "/**",
                        " * @dev Base interface for a contract that will be called via the GSN from {IRelayHub}.",
                        " *",
                        " * TIP: You don't need to write an implementation yourself! Inherit from {GSNRecipient} instead.",
                        " */",
                        "interface IRelayRecipient {",
                        "    /**",
                        "     * @dev Returns the address of the {IRelayHub} instance this recipient interacts with.",
                        "     */",
                        "    function getHubAddr() external view returns (address);",
                        "    /**",
                        "     * @dev Called by {IRelayHub} to validate if this recipient accepts being charged for a relayed call. Note that the",
                        "     * recipient will be charged regardless of the execution result of the relayed call (i.e. if it reverts or not).",
                        "     *",
                        "     * The relay request was originated by `from` and will be served by `relay`. `encodedFunction` is the relayed call",
                        "     * calldata, so its first four bytes are the function selector. The relayed call will be forwarded `gasLimit` gas,",
                        "     * and the transaction executed with a gas price of at least `gasPrice`. ``relay``'s fee is `transactionFee`, and the",
                        "     * recipient will be charged at most `maxPossibleCharge` (in wei). `nonce` is the sender's (`from`) nonce for",
                        "     * replay attack protection in {IRelayHub}, and `approvalData` is a optional parameter that can be used to hold a signature",
                        "     * over all or some of the previous values.",
                        "     *",
                        "     * Returns a tuple, where the first value is used to indicate approval (0) or rejection (custom non-zero error code,",
                        "     * values 1 to 10 are reserved) and the second one is data to be passed to the other {IRelayRecipient} functions.",
                        "     *",
                        "     * {acceptRelayedCall} is called with 50k gas: if it runs out during execution, the request will be considered",
                        "     * rejected. A regular revert will also trigger a rejection.",
                        "     */",
                        "    function acceptRelayedCall(",
                        "        address relay,",
                        "        address from,",
                        "        bytes calldata encodedFunction,",
                        "        uint256 transactionFee,",
                        "        uint256 gasPrice,",
                        "        uint256 gasLimit,",
                        "        uint256 nonce,",
                        "        bytes calldata approvalData,",
                        "        uint256 maxPossibleCharge",
                        "    )",
                        "        external",
                        "        view",
                        "        returns (uint256, bytes memory);",
                        "    /**",
                        "     * @dev Called by {IRelayHub} on approved relay call requests, before the relayed call is executed. This allows to e.g.",
                        "     * pre-charge the sender of the transaction.",
                        "     *",
                        "     * `context` is the second value returned in the tuple by {acceptRelayedCall}.",
                        "     *",
                        "     * Returns a value to be passed to {postRelayedCall}.",
                        "     *",
                        "     * {preRelayedCall} is called with 100k gas: if it runs out during execution or otherwise reverts, the relayed call",
                        "     * will not be executed, but the recipient will still be charged for the transaction's cost.",
                        "     */",
                        "    function preRelayedCall(bytes calldata context) external returns (bytes32);",
                        "    /**",
                        "     * @dev Called by {IRelayHub} on approved relay call requests, after the relayed call is executed. This allows to e.g.",
                        "     * charge the user for the relayed call costs, return any overcharges from {preRelayedCall}, or perform",
                        "     * contract-specific bookkeeping.",
                        "     *",
                        "     * `context` is the second value returned in the tuple by {acceptRelayedCall}. `success` is the execution status of",
                        "     * the relayed call. `actualCharge` is an estimate of how much the recipient will be charged for the transaction,",
                        "     * not including any gas used by {postRelayedCall} itself. `preRetVal` is {preRelayedCall}'s return value.",
                        "     *",
                        "     *",
                        "     * {postRelayedCall} is called with 100k gas: if it runs out during execution or otherwise reverts, the relayed call",
                        "     * and the call to {preRelayedCall} will be reverted retroactively, but the recipient will still be charged for the",
                        "     * transaction's cost.",
                        "     */",
                        "    function postRelayedCall(bytes calldata context, bool success, uint256 actualCharge, bytes32 preRetVal) external;",
                        "}",
                        "/**",
                        " * @title ERC721GSNRecipientMock",
                        " * A simple ERC721 mock that has GSN support enabled",
                        " */",
                        "contract ERC721GSNRecipientMock is ERC721, GSNRecipient, GSNRecipientSignature {",
                        "    constructor(string memory name, string memory symbol, address trustedSigner)",
                        "        ERC721(name, symbol)",
                        "        GSNRecipientSignature(trustedSigner)",
                        "    { }",
                        "    function mint(uint256 tokenId) public {",
                        "        _mint(_msgSender(), tokenId);",
                        "    }",
                        "    function _msgSender() internal view override(Context, GSNRecipient) returns (address) {",
                        "        return GSNRecipient._msgSender();",
                        "    }",
                        "    function _msgData() internal view override(Context, GSNRecipient) returns (bytes memory) {",
                        "        return GSNRecipient._msgData();",
                        "    }",
                        "}",
                        "contract GSNRecipientERC20FeeMock is GSNRecipient, GSNRecipientERC20Fee {",
                        "    constructor(string memory name, string memory symbol) GSNRecipientERC20Fee(name, symbol) { }",
                        "    function mint(address account, uint256 amount) public {",
                        "        _mint(account, amount);",
                        "    }",
                        "    event MockFunctionCalled(uint256 senderBalance);",
                        "    function mockFunction() public {",
                        "        emit MockFunctionCalled(token().balanceOf(_msgSender()));",
                        "    }",
                        "}",
                        "contract GSNRecipientMock is ContextMock, GSNRecipient {",
                        "    function withdrawDeposits(uint256 amount, address payable payee) public {",
                        "        _withdrawDeposits(amount, payee);",
                        "    }",
                        "    function acceptRelayedCall(address, address, bytes calldata, uint256, uint256, uint256, uint256, bytes calldata, uint256)",
                        "        external",
                        "        pure",
                        "        override",
                        "        returns (uint256, bytes memory)",
                        "    {",
                        "        return (0, \"\");",
                        "    }",
                        "    function _preRelayedCall(bytes memory) internal override returns (bytes32) { }",
                        "    function _postRelayedCall(bytes memory, bool, uint256, bytes32) internal override { }",
                        "    function upgradeRelayHub(address newRelayHub) public {",
                        "        return _upgradeRelayHub(newRelayHub);",
                        "    }",
                        "    function _msgSender() internal override(Context, GSNRecipient) view virtual returns (address) {",
                        "        return GSNRecipient._msgSender();",
                        "    }",
                        "    function _msgData() internal override(Context, GSNRecipient) view virtual returns (bytes calldata) {",
                        "        return GSNRecipient._msgData();",
                        "    }",
                        "}",
                        "contract GSNRecipientSignatureMock is GSNRecipient, GSNRecipientSignature {",
                        "    constructor(address trustedSigner) GSNRecipientSignature(trustedSigner) { }",
                        "    event MockFunctionCalled();",
                        "    function mockFunction() public {",
                        "        emit MockFunctionCalled();",
                        "    }",
                        "}",
                        " * manner, since when dealing with GSN meta-transactions the account sending and"
                    ]
                }
            }
        ],
        " * `ERC165`: remove uses of storage in the base ERC165 implementation. ERC165 based contracts now use storage-less virtual functions. Old behavior remains available in the `ERC165Storage` extension. ([#2505](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2505))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2505": {
                    "add": [
                        " * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check",
                        " * for the additional interface id that will be supported. For example:",
                        " *",
                        " * ```solidity",
                        " * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {",
                        " *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);",
                        " * }",
                        " * ```",
                        " *",
                        " * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.",
                        "        return interfaceId == type(IERC165).interfaceId;",
                        "/**",
                        " * @dev Storage based implementation of the {IERC165} interface.",
                        " *",
                        " * Contracts may inherit from this and call {_registerInterface} to declare",
                        " * their support of an interface.",
                        " */",
                        "abstract contract ERC165Storage is ERC165 {",
                        "    /**",
                        "     * @dev Mapping of interface ids to whether or not it's supported.",
                        "     */",
                        "    mapping(bytes4 => bool) private _supportedInterfaces;",
                        "    /**",
                        "     * @dev See {IERC165-supportsInterface}.",
                        "     */",
                        "    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {",
                        "        return super.supportsInterface(interfaceId) || _supportedInterfaces[interfaceId];",
                        "    }",
                        "    /**",
                        "     * @dev Registers the contract as an implementer of the interface defined by",
                        "     * `interfaceId`. Support of the actual ERC165 interface is automatic and",
                        "     * registering its interface id is not required.",
                        "     *",
                        "     * See {IERC165-supportsInterface}.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).",
                        "     */",
                        "    function _registerInterface(bytes4 interfaceId) internal virtual {",
                        "        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");",
                        "        _supportedInterfaces[interfaceId] = true;",
                        "    }",
                        "}",
                        "contract ERC1155ReceiverMock is IERC1155Receiver, ERC165 {",
                        "contract ERC165StorageMock is ERC165Storage {",
                        "    function registerInterface(bytes4 interfaceId) public {",
                        "        _registerInterface(interfaceId);",
                        "    }",
                        "}",
                        "    }",
                        "    /**",
                        "     * @dev See {IERC165-supportsInterface}.",
                        "     */",
                        "    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {",
                        "        return interfaceId == type(IERC1155).interfaceId",
                        "            || interfaceId == type(IERC1155MetadataURI).interfaceId",
                        "            || super.supportsInterface(interfaceId);",
                        "    /**",
                        "     * @dev See {IERC165-supportsInterface}.",
                        "     */",
                        "    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {",
                        "        return interfaceId == type(IERC1155Receiver).interfaceId",
                        "            || super.supportsInterface(interfaceId);",
                        "    }",
                        "    /**",
                        "     * @dev See {IERC165-supportsInterface}.",
                        "     */",
                        "    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {",
                        "        return interfaceId == type(IERC721).interfaceId",
                        "            || interfaceId == type(IERC721Metadata).interfaceId",
                        "            || interfaceId == type(IERC721Enumerable).interfaceId",
                        "            || super.supportsInterface(interfaceId);"
                    ],
                    "del": [
                        " * Contracts may inherit from this and call {_registerInterface} to declare",
                        " * their support of an interface.",
                        "    /**",
                        "     * @dev Mapping of interface ids to whether or not it's supported.",
                        "     */",
                        "    mapping(bytes4 => bool) private _supportedInterfaces;",
                        "    constructor () {",
                        "        _registerInterface(type(IERC165).interfaceId);",
                        "    }",
                        "     *",
                        "     * Time complexity O(1), guaranteed to always use less than 30 000 gas.",
                        "        return _supportedInterfaces[interfaceId];",
                        "    }",
                        "    /**",
                        "     * @dev Registers the contract as an implementer of the interface defined by",
                        "     * `interfaceId`. Support of the actual ERC165 interface is automatic and",
                        "     * registering its interface id is not required.",
                        "     *",
                        "     * See {IERC165-supportsInterface}.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - `interfaceId` cannot be the ERC165 invalid interface (`0xffffffff`).",
                        "     */",
                        "    function _registerInterface(bytes4 interfaceId) internal virtual {",
                        "        require(interfaceId != 0xffffffff, \"ERC165: invalid interface id\");",
                        "        _supportedInterfaces[interfaceId] = true;",
                        "contract ERC1155ReceiverMock is IERC1155Receiver, ERC165Mock {",
                        "    function registerInterface(bytes4 interfaceId) public {",
                        "        _registerInterface(interfaceId);",
                        "    }",
                        "        _registerInterface(type(IERC1155).interfaceId);",
                        "        _registerInterface(type(IERC1155MetadataURI).interfaceId);",
                        "    constructor() {",
                        "        _registerInterface(type(IERC1155Receiver).interfaceId);",
                        "        _registerInterface(type(IERC721).interfaceId);",
                        "        _registerInterface(type(IERC721Metadata).interfaceId);",
                        "        _registerInterface(type(IERC721Enumerable).interfaceId);"
                    ]
                }
            }
        ],
        " * `Initializable`: make initializer check stricter during construction. ([#2531](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2531))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2531": {
                    "add": [
                        "        require(_initializing || !_initialized, \"Initializable: contract is already initialized\");"
                    ],
                    "del": [
                        "        require(_initializing || _isConstructor() || !_initialized, \"Initializable: contract is already initialized\");",
                        "    function _isConstructor() private view returns (bool) {",
                        "        return !Address.isContract(address(this));",
                        "    }"
                    ]
                }
            }
        ],
        " * `ERC721`: remove enumerability of tokens from the base implementation. This feature is now provided separately through the `ERC721Enumerable` extension. ([#2511](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2511))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2511": {
                    "add": [
                        "/**",
                        " * @title ERC721Mock",
                        " * This mock just provides a public safeMint, mint, and burn functions for testing purposes",
                        " */",
                        "contract ERC721EnumerableMock is ERC721Enumerable {",
                        "    string private _baseTokenURI;",
                        "    constructor (string memory name, string memory symbol) ERC721(name, symbol) { }",
                        "    function _baseURI() internal view virtual override returns (string memory) {",
                        "        return _baseTokenURI;",
                        "    }",
                        "    function setBaseURI(string calldata newBaseTokenURI) public {",
                        "        _baseTokenURI = newBaseTokenURI;",
                        "    }",
                        "    function baseURI() public view returns (string memory) {",
                        "        return _baseURI();",
                        "    }",
                        "    function mint(address to, uint256 tokenId) public {",
                        "        _mint(to, tokenId);",
                        "    }",
                        "    function safeMint(address to, uint256 tokenId) public {",
                        "        _safeMint(to, tokenId);",
                        "    }",
                        "    function safeMint(address to, uint256 tokenId, bytes memory _data) public {",
                        "        _safeMint(to, tokenId, _data);",
                        "    }",
                        "    function burn(uint256 tokenId) public {",
                        "        _burn(tokenId);",
                        "    }",
                        "}",
                        "    string private _baseTokenURI;",
                        "    function _baseURI() internal view virtual override returns (string memory) {",
                        "        return _baseTokenURI;",
                        "    function setBaseURI(string calldata newBaseTokenURI) public {",
                        "        _baseTokenURI = newBaseTokenURI;",
                        "    function baseURI() public view returns (string memory) {",
                        "        return _baseURI();",
                        "    }",
                        "    function exists(uint256 tokenId) public view returns (bool) {",
                        "        return _exists(tokenId);",
                        "contract ERC721PresetMinterPauserAutoId is Context, AccessControl, ERC721Enumerable, ERC721Burnable, ERC721Pausable {",
                        "    string private _baseTokenURI;",
                        "    constructor(string memory name, string memory symbol, string memory baseTokenURI) ERC721(name, symbol) {",
                        "        _baseTokenURI = baseTokenURI;",
                        "    }",
                        "    function _baseURI() internal view virtual override returns (string memory) {",
                        "        return _baseTokenURI;",
                        "    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override(ERC721, ERC721Enumerable, ERC721Pausable) {",
                        "    /**",
                        "     * @dev See {IERC165-supportsInterface}.",
                        "     */",
                        "    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC721Enumerable) returns (bool) {",
                        "        return super.supportsInterface(interfaceId);",
                        "    }",
                        " * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including",
                        " * the Metadata extension, but not including the Enumerable extension, which is available separately as",
                        " * {ERC721Enumerable}.",
                        "contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {",
                        "    mapping (uint256 => address) private _owners;",
                        "    mapping (address => uint256) private _balances;",
                        "    mapping (uint256 => address) private _tokenApprovals;",
                        "    mapping (address => mapping (address => bool)) private _operatorApprovals;",
                        "        return _balances[owner];",
                        "        address owner = _owners[tokenId];",
                        "        require(owner != address(0), \"ERC721: owner query for nonexistent token\");",
                        "        return owner;",
                        "        string memory baseURI = _baseURI();",
                        "        return bytes(baseURI).length > 0",
                        "            ? string(abi.encodePacked(baseURI, tokenId.toString()))",
                        "            : '';",
                        "     * @dev Base URI for computing {tokenURI}. Empty by default, can be overriden",
                        "     * in child contracts.",
                        "    function _baseURI() internal view virtual returns (string memory) {",
                        "        return \"\";",
                        "        return _owners[tokenId] != address(0);",
                        "        _balances[to] += 1;",
                        "        _owners[tokenId] = to;",
                        "        address owner = ERC721.ownerOf(tokenId);",
                        "        _balances[owner] -= 1;",
                        "        delete _owners[tokenId];",
                        "        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");",
                        "        _balances[from] -= 1;",
                        "        _balances[to] += 1;",
                        "        _owners[tokenId] = to;",
                        "     * @dev Approve `to` to operate on `tokenId`",
                        "     * Emits a {Approval} event.",
                        "    function _approve(address to, uint256 tokenId) internal virtual {",
                        "        _tokenApprovals[tokenId] = to;",
                        "        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);",
                        "/**",
                        " * @dev This implements an optional extension of {ERC721} defined in the EIP that adds",
                        " * enumerability of all the token ids in the contract as well as all token ids owned by each",
                        " * account.",
                        " */",
                        "abstract contract ERC721Enumerable is ERC721, IERC721Enumerable {",
                        "    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;",
                        "    mapping(uint256 => uint256) private _ownedTokensIndex;",
                        "    uint256[] private _allTokens;",
                        "    mapping(uint256 => uint256) private _allTokensIndex;",
                        "    /**",
                        "     * @dev See {IERC165-supportsInterface}.",
                        "     */",
                        "    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {",
                        "        return interfaceId == type(IERC721Enumerable).interfaceId",
                        "            || super.supportsInterface(interfaceId);",
                        "    }",
                        "    /**",
                        "     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.",
                        "     */",
                        "    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {",
                        "        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");",
                        "        return _ownedTokens[owner][index];",
                        "    }",
                        "    /**",
                        "     * @dev See {IERC721Enumerable-totalSupply}.",
                        "     */",
                        "    function totalSupply() public view virtual override returns (uint256) {",
                        "        return _allTokens.length;",
                        "    }",
                        "    /**",
                        "     * @dev See {IERC721Enumerable-tokenByIndex}.",
                        "     */",
                        "    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {",
                        "        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");",
                        "        return _allTokens[index];",
                        "    }",
                        "    /**",
                        "     * @dev Hook that is called before any token transfer. This includes minting",
                        "     * and burning.",
                        "     *",
                        "     * Calling conditions:",
                        "     *",
                        "     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be",
                        "     * transferred to `to`.",
                        "     * - When `from` is zero, `tokenId` will be minted for `to`.",
                        "     * - When `to` is zero, ``from``'s `tokenId` will be burned.",
                        "     * - `from` cannot be the zero address.",
                        "     * - `to` cannot be the zero address.",
                        "     *",
                        "     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].",
                        "     */",
                        "    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override {",
                        "        super._beforeTokenTransfer(from, to, tokenId);",
                        "        if (from == address(0)) {",
                        "            _addTokenToAllTokensEnumeration(tokenId);",
                        "        } else if (from != to) {",
                        "            _removeTokenFromOwnerEnumeration(from, tokenId);",
                        "        }",
                        "        if (to == address(0)) {",
                        "            _removeTokenFromAllTokensEnumeration(tokenId);",
                        "        } else if (to != from) {",
                        "            _addTokenToOwnerEnumeration(to, tokenId);",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Private function to add a token to this extension's ownership-tracking data structures.",
                        "     * @param to address representing the new owner of the given token ID",
                        "     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address",
                        "     */",
                        "    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {",
                        "        uint256 length = ERC721.balanceOf(to);",
                        "        _ownedTokens[to][length] = tokenId;",
                        "        _ownedTokensIndex[tokenId] = length;",
                        "    }",
                        "    /**",
                        "     * @dev Private function to add a token to this extension's token tracking data structures.",
                        "     * @param tokenId uint256 ID of the token to be added to the tokens list",
                        "     */",
                        "    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {",
                        "        _allTokensIndex[tokenId] = _allTokens.length;",
                        "        _allTokens.push(tokenId);",
                        "    }",
                        "    /**",
                        "     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that",
                        "     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for",
                        "     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).",
                        "     * This has O(1) time complexity, but alters the order of the _ownedTokens array.",
                        "     * @param from address representing the previous owner of the given token ID",
                        "     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address",
                        "     */",
                        "    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {",
                        "        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;",
                        "        uint256 tokenIndex = _ownedTokensIndex[tokenId];",
                        "        if (tokenIndex != lastTokenIndex) {",
                        "            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];",
                        "        }",
                        "        delete _ownedTokensIndex[tokenId];",
                        "        delete _ownedTokens[from][lastTokenIndex];",
                        "    }",
                        "    /**",
                        "     * @dev Private function to remove a token from this extension's token tracking data structures.",
                        "     * This has O(1) time complexity, but alters the order of the _allTokens array.",
                        "     * @param tokenId uint256 ID of the token to be removed from the tokens list",
                        "     */",
                        "    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {",
                        "        uint256 lastTokenIndex = _allTokens.length - 1;",
                        "        uint256 tokenIndex = _allTokensIndex[tokenId];",
                        "        uint256 lastTokenId = _allTokens[lastTokenIndex];",
                        "        delete _allTokensIndex[tokenId];",
                        "        _allTokens.pop();",
                        "    }",
                        "}"
                    ],
                    "del": [
                        "    function exists(uint256 tokenId) public view returns (bool) {",
                        "        return _exists(tokenId);",
                        "    function setTokenURI(uint256 tokenId, string memory uri) public {",
                        "        _setTokenURI(tokenId, uri);",
                        "    function setBaseURI(string memory baseURI) public {",
                        "        _setBaseURI(baseURI);",
                        "contract ERC721PresetMinterPauserAutoId is Context, AccessControl, ERC721Burnable, ERC721Pausable {",
                        "    constructor(string memory name, string memory symbol, string memory baseURI) ERC721(name, symbol) {",
                        "        _setBaseURI(baseURI);",
                        "    function _beforeTokenTransfer(address from, address to, uint256 tokenId) internal virtual override(ERC721, ERC721Pausable) {",
                        " * @title ERC721 Non-Fungible Token Standard basic implementation",
                        " * @dev see https://eips.ethereum.org/EIPS/eip-721",
                        "contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Enumerable {",
                        "    using EnumerableSet for EnumerableSet.UintSet;",
                        "    using EnumerableMap for EnumerableMap.UintToAddressMap;",
                        "    mapping (address => EnumerableSet.UintSet) private _holderTokens;",
                        "    EnumerableMap.UintToAddressMap private _tokenOwners;",
                        "    mapping (uint256 => address) private _tokenApprovals;",
                        "    mapping (address => mapping (address => bool)) private _operatorApprovals;",
                        "    mapping (uint256 => string) private _tokenURIs;",
                        "    string private _baseURI;",
                        "            || interfaceId == type(IERC721Enumerable).interfaceId",
                        "        return _holderTokens[owner].length();",
                        "        return _tokenOwners.get(tokenId, \"ERC721: owner query for nonexistent token\");",
                        "        string memory _tokenURI = _tokenURIs[tokenId];",
                        "        string memory base = baseURI();",
                        "        if (bytes(base).length == 0) {",
                        "            return _tokenURI;",
                        "        }",
                        "        if (bytes(_tokenURI).length > 0) {",
                        "            return string(abi.encodePacked(base, _tokenURI));",
                        "        }",
                        "        return string(abi.encodePacked(base, tokenId.toString()));",
                        "    * @dev Returns the base URI set via {_setBaseURI}. This will be",
                        "    * automatically added as a prefix in {tokenURI} to each token's URI, or",
                        "    * to the token ID if no specific URI is set for that token ID.",
                        "    */",
                        "    function baseURI() public view virtual returns (string memory) {",
                        "        return _baseURI;",
                        "    }",
                        "    /**",
                        "     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.",
                        "    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {",
                        "        return _holderTokens[owner].at(index);",
                        "    }",
                        "    /**",
                        "     * @dev See {IERC721Enumerable-totalSupply}.",
                        "     */",
                        "    function totalSupply() public view virtual override returns (uint256) {",
                        "        return _tokenOwners.length();",
                        "    }",
                        "    /**",
                        "     * @dev See {IERC721Enumerable-tokenByIndex}.",
                        "     */",
                        "    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {",
                        "        (uint256 tokenId, ) = _tokenOwners.at(index);",
                        "        return tokenId;",
                        "        return _tokenOwners.contains(tokenId);",
                        "        _holderTokens[to].add(tokenId);",
                        "        _tokenOwners.set(tokenId, to);",
                        "        if (bytes(_tokenURIs[tokenId]).length != 0) {",
                        "            delete _tokenURIs[tokenId];",
                        "        }",
                        "        _holderTokens[owner].remove(tokenId);",
                        "        _tokenOwners.remove(tokenId);",
                        "        _holderTokens[from].remove(tokenId);",
                        "        _holderTokens[to].add(tokenId);",
                        "        _tokenOwners.set(tokenId, to);",
                        "     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.",
                        "     * Requirements:",
                        "     *",
                        "     * - `tokenId` must exist.",
                        "    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {",
                        "        require(_exists(tokenId), \"ERC721Metadata: URI set of nonexistent token\");",
                        "        _tokenURIs[tokenId] = _tokenURI;",
                        "    }",
                        "    /**",
                        "     * @dev Internal function to set the base URI for all token IDs. It is",
                        "     * automatically added as a prefix to the value returned in {tokenURI},",
                        "     * or to the token ID if {tokenURI} is empty.",
                        "     */",
                        "    function _setBaseURI(string memory baseURI_) internal virtual {",
                        "        _baseURI = baseURI_;",
                        "    function _approve(address to, uint256 tokenId) private {",
                        "        _tokenApprovals[tokenId] = to;",
                        "    }"
                    ]
                }
            }
        ],
        " * Meta Transactions: add `ERC2771Context` and a `MinimalForwarder` for meta-transactions. ([#2508](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2508))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2508": {
                    "add": [
                        "     * produces hash corresponding to the one signed with the",
                        "     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]",
                        "     * JSON-RPC method as part of EIP-191.",
                        "    /**",
                        "     * @dev Returns an Ethereum Signed Typed Data, created from a",
                        "     * `domainSeparator` and a `structHash`. This produces hash corresponding",
                        "     * to the one signed with the",
                        "     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]",
                        "     * JSON-RPC method as part of EIP-712.",
                        "     *",
                        "     * See {recover}.",
                        "     */",
                        "    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {",
                        "        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));",
                        "    }",
                        "        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);",
                        "/*",
                        " * @dev Context variant with ERC2771 support.",
                        " */",
                        "abstract contract ERC2771Context is Context {",
                        "    address immutable _trustedForwarder;",
                        "    constructor(address trustedForwarder) {",
                        "        _trustedForwarder = trustedForwarder;",
                        "    }",
                        "    function isTrustedForwarder(address forwarder) public view virtual returns(bool) {",
                        "        return forwarder == _trustedForwarder;",
                        "    }",
                        "    function _msgSender() internal view virtual override returns (address sender) {",
                        "        if (isTrustedForwarder(msg.sender)) {",
                        "            assembly { sender := shr(96, calldataload(sub(calldatasize(), 20))) }",
                        "        } else {",
                        "            return super._msgSender();",
                        "        }",
                        "    }",
                        "    function _msgData() internal view virtual override returns (bytes calldata) {",
                        "        if (isTrustedForwarder(msg.sender)) {",
                        "            return msg.data[:msg.data.length-20];",
                        "        } else {",
                        "            return super._msgData();",
                        "        }",
                        "    }",
                        "}",
                        "/*",
                        " * @dev Simple minimal forwarder to be used together with an ERC2771 compatible contract. See {ERC2771Context}.",
                        " */",
                        "contract MinimalForwarder is EIP712 {",
                        "    using ECDSA for bytes32;",
                        "    struct ForwardRequest {",
                        "        address from;",
                        "        address to;",
                        "        uint256 value;",
                        "        uint256 gas;",
                        "        uint256 nonce;",
                        "        bytes data;",
                        "    }",
                        "    bytes32 private constant TYPEHASH = keccak256(\"ForwardRequest(address from,address to,uint256 value,uint256 gas,uint256 nonce,bytes data)\");",
                        "    mapping(address => uint256) private _nonces;",
                        "    constructor() EIP712(\"MinimalForwarder\", \"0.0.1\") {}",
                        "    function getNonce(address from) public view returns (uint256) {",
                        "        return _nonces[from];",
                        "    }",
                        "    function verify(ForwardRequest calldata req, bytes calldata signature) public view returns (bool) {",
                        "        address signer = _hashTypedDataV4(keccak256(abi.encode(",
                        "            TYPEHASH,",
                        "            req.from,",
                        "            req.to,",
                        "            req.value,",
                        "            req.gas,",
                        "            req.nonce,",
                        "            keccak256(req.data)",
                        "        ))).recover(signature);",
                        "        return _nonces[req.from] == req.nonce && signer == req.from;",
                        "    }",
                        "    function execute(ForwardRequest calldata req, bytes calldata signature) public payable returns (bool, bytes memory) {",
                        "        require(verify(req, signature), \"MinimalForwarder: signature does not match request\");",
                        "        _nonces[req.from] = req.nonce + 1;",
                        "        (bool success, bytes memory returndata) = req.to.call{gas: req.gas, value: req.value}(abi.encodePacked(req.data, req.from));",
                        "        assert(gasleft() > req.gas / 63);",
                        "        return (success, returndata);",
                        "    }",
                        "}",
                        "contract ERC2771ContextMock is ContextMock, ERC2771Context {",
                        "    constructor(address trustedForwarder) ERC2771Context(trustedForwarder) {}",
                        "    function _msgSender() internal override(Context, ERC2771Context) view virtual returns (address) {",
                        "        return ERC2771Context._msgSender();",
                        "    }",
                        "    function _msgData() internal override(Context, ERC2771Context) view virtual returns (bytes calldata) {",
                        "        return ERC2771Context._msgData();",
                        "    }",
                        "}"
                    ],
                    "del": [
                        "     * replicates the behavior of the",
                        "     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]",
                        "     * JSON-RPC method.",
                        "        return keccak256(abi.encodePacked(\"\\x19\\x01\", _domainSeparatorV4(), structHash));"
                    ]
                }
            }
        ],
        " * `ERC20Capped`: optimize gas usage by enforcing the check directly in `_mint`. ([#2524](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2524))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2524": {
                    "add": [
                        "     * @dev See {ERC20-_mint}.",
                        "    function _mint(address account, uint256 amount) internal virtual override {",
                        "        require(ERC20.totalSupply() + amount <= cap(), \"ERC20Capped: cap exceeded\");",
                        "        super._mint(account, amount);"
                    ],
                    "del": [
                        "     * @dev See {ERC20-_beforeTokenTransfer}.",
                        "     *",
                        "     * Requirements:",
                        "     *",
                        "     * - minted tokens must not cause the total supply to go over the cap.",
                        "    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {",
                        "        super._beforeTokenTransfer(from, to, amount);",
                        "            require(totalSupply() + amount <= cap(), \"ERC20Capped: cap exceeded\");",
                        "        }"
                    ]
                }
            }
        ],
        " * `AccessControl`: added ERC165 interface detection. ([#2562](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2562))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2562": {
                    "add": [
                        "/**",
                        " * @dev External interface of AccessControl declared to support ERC165 detection.",
                        " */",
                        "interface IAccessControl {",
                        "    function hasRole(bytes32 role, address account) external view returns (bool);",
                        "    function getRoleAdmin(bytes32 role) external view returns (bytes32);",
                        "    function grantRole(bytes32 role, address account) external;",
                        "    function revokeRole(bytes32 role, address account) external;",
                        "    function renounceRole(bytes32 role, address account) external;",
                        "}",
                        "abstract contract AccessControl is Context, IAccessControl, ERC165 {",
                        "    /**",
                        "     * @dev See {IERC165-supportsInterface}.",
                        "     */",
                        "    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {",
                        "        return interfaceId == type(IAccessControl).interfaceId",
                        "            || super.supportsInterface(interfaceId);",
                        "    }",
                        "    function hasRole(bytes32 role, address account) public view override returns (bool) {",
                        "    function getRoleAdmin(bytes32 role) public view override returns (bytes32) {",
                        "    function grantRole(bytes32 role, address account) public virtual override {",
                        "    function revokeRole(bytes32 role, address account) public virtual override {",
                        "    function renounceRole(bytes32 role, address account) public virtual override {",
                        "/**",
                        " * @dev External interface of AccessControlEnumerable declared to support ERC165 detection.",
                        " */",
                        "interface IAccessControlEnumerable {",
                        "    function getRoleMember(bytes32 role, uint256 index) external view returns (address);",
                        "    function getRoleMemberCount(bytes32 role) external view returns (uint256);",
                        "}",
                        "abstract contract AccessControlEnumerable is IAccessControlEnumerable, AccessControl {",
                        "    /**",
                        "     * @dev See {IERC165-supportsInterface}.",
                        "     */",
                        "    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {",
                        "        return interfaceId == type(IAccessControlEnumerable).interfaceId",
                        "            || super.supportsInterface(interfaceId);",
                        "    }",
                        "    function getRoleMember(bytes32 role, uint256 index) public view override returns (address) {",
                        "    function getRoleMemberCount(bytes32 role) public view override returns (uint256) {",
                        "    /**",
                        "     * @dev See {IERC165-supportsInterface}.",
                        "     */",
                        "    function supportsInterface(bytes4 interfaceId) public view virtual override(AccessControlEnumerable, ERC1155) returns (bool) {",
                        "        return super.supportsInterface(interfaceId);",
                        "    }",
                        "    function supportsInterface(bytes4 interfaceId) public view virtual override(AccessControlEnumerable, ERC721, ERC721Enumerable) returns (bool) {"
                    ],
                    "del": [
                        "abstract contract AccessControl is Context {",
                        "    function hasRole(bytes32 role, address account) public view returns (bool) {",
                        "    function getRoleAdmin(bytes32 role) public view returns (bytes32) {",
                        "    function grantRole(bytes32 role, address account) public virtual {",
                        "    function revokeRole(bytes32 role, address account) public virtual {",
                        "    function renounceRole(bytes32 role, address account) public virtual {",
                        "abstract contract AccessControlEnumerable is AccessControl {",
                        "    function getRoleMember(bytes32 role, uint256 index) public view returns (address) {",
                        "    function getRoleMemberCount(bytes32 role) public view returns (uint256) {",
                        "    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC721Enumerable) returns (bool) {"
                    ]
                }
            }
        ]
    },
    "4.0.0-beta.0": {},
    "3.4.0": {
        "### Security Fixes\r": [],
        " * `ERC777`: fix potential reentrancy issues for custom extensions to `ERC777`. ([#2483](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2483))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2483": {
                    "add": [
                        "    event BeforeTokenTransfer();",
                        "    function _beforeTokenTransfer(address, address, address, uint256) internal override {",
                        "        emit BeforeTokenTransfer();",
                        "    }",
                        "    event BeforeTokenTransfer();",
                        "        _beforeTokenTransfer(operator, from, address(0), amount);"
                    ],
                    "del": [
                        "        _beforeTokenTransfer(operator, from, address(0), amount);"
                    ]
                }
            }
        ],
        "If you're using our implementation of ERC777 from version 3.3.0 or earlier, and you define a custom `_beforeTokenTransfer` function that writes to a storage variable, you may be vulnerable to a reentrancy attack. If you're affected and would like assistance please write to security@openzeppelin.com. [Read more in the pull request.](https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2483)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2483": {
                    "add": [
                        "    event BeforeTokenTransfer();",
                        "    function _beforeTokenTransfer(address, address, address, uint256) internal override {",
                        "        emit BeforeTokenTransfer();",
                        "    }",
                        "    event BeforeTokenTransfer();",
                        "        _beforeTokenTransfer(operator, from, address(0), amount);"
                    ],
                    "del": [
                        "        _beforeTokenTransfer(operator, from, address(0), amount);"
                    ]
                }
            }
        ]
    },
    "3.3.0": {},
    "3.2.1-solc-0.7": {
        "This is a special release for Solidity 0.7 that gets rid of a warning in `ERC777` using one of the new features of the language. (#2327)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/232": {
                    "add": [],
                    "del": []
                }
            }
        ]
    },
    "3.2.0": {},
    "3.1.0": {
        "The low-level `call` primitive can be hard to use correctly and is often considered unsafe. With the addition of [`sendValue`](https://docs.openzeppelin.com/contracts/3.x/api/utils#Address-sendValue-address-payable-uint256-) in Contracts and `try-catch` in Solidity, there's only a few scenarios in which `call` is still needed, the most troublesome one being forwarding calls.\r": [],
        "## Using `SafeMath` on Small Signed Integers\r": []
    },
    "3.0.1": {
        "This is a small bugfix release, addressing an issue that allowed for some `internal` functions in ERC777 to be called with the zero address as one of their arguments.\r": [],
        "This was reported in https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2208, fixed in https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2212 for the v2.5 branch, and ported to the v3.0 branch in https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2213.": []
    },
    "2.5.1": {
        "This is a small bugfix release, addressing an issue that allowed for some `internal` functions in ERC777 to be called with the zero address as one of their arguments.\r": [],
        "This was reported in https://github.com/OpenZeppelin/openzeppelin-contracts/issues/2208 and fixed in https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2212.": []
    },
    "3.0.0": {
        "Among other things, this release features the **migration to Solidity v0.6**, as well as a **revamped access control system**, **streamlined token contracts**, and new libraries for **enumerable mappings**.\r": [],
        " * `AccessControl` was designed [with help from the community](https://forum.openzeppelin.com/t/redesigning-accesscontrol-for-the-openzeppelin-contracts/2177) and has replaced `Roles` contracts (such as `MinterRole` and `PauserRole`), which were removed.\r": [],
        " * Crowdsales were removed: we'll continue to provide support for security issues on the v2.5 release, but will not bring them over to v3.0.\r": [],
        "## Revamped Access Control\r": [],
        "The v3.0 release introduces `AccessControl`, a one-stop-shop for all authorization needs. It lets you easily define multiple **roles with different permissions**, as well as **which accounts are allowed to grant and revoke** each role. It also boosts transparency by enabling **enumeration of all privileged accounts** in a system.\r": [],
        "`AccessControl` was designed with a security-first mindset, [receiving input from a wide array of users](https://forum.openzeppelin.com/t/redesigning-accesscontrol-for-the-openzeppelin-contracts/2177) and incorporating best practices in the field. Head to [our Access Control guide](https://docs.openzeppelin.com/contracts/3.x/access-control#role-based-access-control) for more information!\r": [],
        "## Migrating From OpenZeppelin Contracts v2.5\r": [],
        "If you're using the `ERC20` or `ERC721` tokens however, you'll have to remove all references to optional extensions (`ERC20Detailed`, `ERC721Enumerable`, etc.) - these have been included in the base contracts.\r": [],
        "For example, the `_beforeTokenTransfer` hook in ERC20, ERC721 and ERC777 makes it very easy to add additional checks or actions to execute whenever tokens are transferred, minted or burned, regardless of what prompted it.\r": [],
        "// Tokens can only be transferred, minted or burned if the contract is not paused\r": [],
        "        internal virtual override \r": [],
        "        require(!paused(), \"ERC20Pausable: token transfer while paused\");\r": []
    },
    "3.0.0-beta.0": {
        "This is the main item in [Contract's roadmap](https://forum.openzeppelin.com/t/openzeppelin-contracts-roadmap-for-january-march-2020/2175), featuring the **migration to Solidity v0.6**.\r": [],
        " * Roles contracts (such as `MinterRole` and `PauserRole`) were removed: we're [redesigning our Access Control solution](https://forum.openzeppelin.com/t/redesigning-accesscontrol-for-the-openzeppelin-contracts/2177) and will have a better version of these in the v3.0 release.\r": [],
        " * Crowdsales were removed: we'll continue to provide support for security issues on the v2.5 release, but will not bring them over to v3.0.\r": [],
        "## Migrating From OpenZeppelin Contracts v2.5\r": [],
        "function _msgSender() internal view override(Context, GSNRecipient) returns (address payable) {\r": [],
        "For example, the `_beforeTokenTransfer` hook in ERC20, ERC721 and ERC777 makes it very easy to add additional checks or actions to execute whenever tokens are transferred, minted or burned, regardless of what prompted it.\r": [],
        "// Tokens can only be transferred, minted or burned if the contract is not paused\r": [],
        "        internal virtual override \r": [],
        "        require(!paused(), \"ERC20Pausable: token transfer while paused\");\r": []
    },
    "2.5.0": {
        "  -  **`Create2`**: a simple library for using the [CREATE2 opcode](https://eips.ethereum.org/EIPS/eip-1014), allowing for deployment and pre-computation of addresses when using it.\r": [],
        "  - **`ERC721Metadata.baseURI`**: a neat extension for _massive_ gas savings when the token URIs share a prefix, like `https://my.cool.app/token/<id>`\r": []
    },
    "2.4.0": {},
    "2.3.0": {
        "Some more things are included in this release such as an implementation of ERC1820, and a fix for a bug in `PostDeliveryCrowdsale`. Take a look at the [changelog](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/CHANGELOG.md#230-2019-05-27)!\r": [
            "https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/CHANGELOG.md#230-2019-05-27"
        ],
        "Some more things are included in this release such as an implementation of ERC1820, and a fix for a bug in `PostDeliveryCrowdsale`. Take a look at [the changelog](https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/CHANGELOG.md#230-2019-05-27)!": [
            "https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/CHANGELOG.md#230-2019-05-27"
        ]
    },
    "2.3.0-rc.3": {},
    "2.3.0-rc.0": {},
    "2.2.0": {
        "This minor release includes a way to store token balances and supply so that they can be later queried in a gas-efficient manner :bookmark:, allows safe interaction with some old, non-compliant tokens :lock:, prevents user errors when using ECDSA signatures :memo: (the magic behind metatransactions! :sparkles:), and provides multiple minor additions and improvements to the API.\r": [],
        "* `ERC20Snapshot`: this variant allows for snapshots to be created on demand, storing the current token balances and total supply so that they can be later retrieved in a gas-efficient manner and e.g. calculate dividends at a past time. ([#1617](https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1617))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1617": {
                    "add": [
                        "/**",
                        " * @title ERC20 token with snapshots.",
                        " * inspired by Jordi Baylina's MiniMeToken to record historical balances",
                        " * Snapshots store a value at the time a snapshot is taken (and a new snapshot id created), and the corresponding",
                        " * snapshot id. Each account has individual snapshots taken on demand, as does the token's total supply.",
                        " * @author Validity Labs AG <info@validitylabs.org>",
                        " */",
                        "contract ERC20Snapshot is ERC20 {",
                        "    using SafeMath for uint256;",
                        "    using Arrays for uint256[];",
                        "    using Counters for Counters.Counter;",
                        "    struct Snapshots {",
                        "        uint256[] ids;",
                        "        uint256[] values;",
                        "    }",
                        "    mapping (address => Snapshots) private _accountBalanceSnapshots;",
                        "    Snapshots private _totalSupplySnaphots;",
                        "    Counters.Counter private _currentSnapshotId;",
                        "    event Snapshot(uint256 id);",
                        "    function snapshot() public returns (uint256) {",
                        "        _currentSnapshotId.increment();",
                        "        uint256 currentId = _currentSnapshotId.current();",
                        "        emit Snapshot(currentId);",
                        "        return currentId;",
                        "    }",
                        "    function balanceOfAt(address account, uint256 snapshotId) public view returns (uint256) {",
                        "        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);",
                        "        return snapshotted ? value : balanceOf(account);",
                        "    }",
                        "    function totalSupplyAt(uint256 snapshotId) public view returns(uint256) {",
                        "        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnaphots);",
                        "        return snapshotted ? value : totalSupply();",
                        "    }",
                        "    function _transfer(address from, address to, uint256 value) internal {",
                        "        _updateAccountSnapshot(from);",
                        "        _updateAccountSnapshot(to);",
                        "        super._transfer(from, to, value);",
                        "    }",
                        "    function _mint(address account, uint256 value) internal {",
                        "        _updateAccountSnapshot(account);",
                        "        _updateTotalSupplySnapshot();",
                        "        super._mint(account, value);",
                        "    }",
                        "    function _burn(address account, uint256 value) internal {",
                        "        _updateAccountSnapshot(account);",
                        "        _updateTotalSupplySnapshot();",
                        "        super._burn(account, value);",
                        "    }",
                        "    //",
                        "    function _valueAt(uint256 snapshotId, Snapshots storage snapshots)",
                        "        private view returns (bool, uint256)",
                        "    {",
                        "        require(snapshotId > 0);",
                        "        require(snapshotId <= _currentSnapshotId.current());",
                        "        uint256 index = snapshots.ids.findUpperBound(snapshotId);",
                        "        if (index == snapshots.ids.length) {",
                        "            return (false, 0);",
                        "        } else {",
                        "            return (true, snapshots.values[index]);",
                        "        }",
                        "    }",
                        "    function _updateAccountSnapshot(address account) private {",
                        "        _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));",
                        "    }",
                        "    function _updateTotalSupplySnapshot() private {",
                        "        _updateSnapshot(_totalSupplySnaphots, totalSupply());",
                        "    }",
                        "    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {",
                        "        uint256 currentId = _currentSnapshotId.current();",
                        "        if (_lastSnapshotId(snapshots.ids) < currentId) {",
                        "            snapshots.ids.push(currentId);",
                        "            snapshots.values.push(currentValue);",
                        "        }",
                        "    }",
                        "    function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {",
                        "        if (ids.length == 0) {",
                        "            return 0;",
                        "        } else {",
                        "            return ids[ids.length - 1];",
                        "        }",
                        "    }",
                        "}",
                        "contract ERC20SnapshotMock is ERC20Snapshot {",
                        "    constructor(address initialAccount, uint256 initialBalance) public {",
                        "        _mint(initialAccount, initialBalance);",
                        "    }",
                        "    function mint(address account, uint256 amount) public {",
                        "        _mint(account, amount);",
                        "    }",
                        "    function burn(address account, uint256 amount) public {",
                        "        _burn(account, amount);",
                        "    }",
                        "}"
                    ],
                    "del": []
                }
            }
        ],
        " * `SafeERC20`: the `ERC20` standard requires that all function calls (e.g. `transfer`, `approve`, etc.) return a boolean value indicating success. However, they are multiple widely used tokens out there that return no such value: they simply `revert` when encountering an error condition. Since Solidity v0.4.22, special code was needed to interact with this non-compliant tokens: now, all of `SafeERC20` can be used to safely call both compliant and non-compliant tokens, without the developer having to worry about it. ([#1655](https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1655))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1655": {
                    "add": [
                        "contract ERC20ReturnFalseMock {",
                        "contract ERC20ReturnTrueMock {",
                        "contract ERC20NoReturnMock {",
                        "    mapping (address => uint256) private _allowances;",
                        "    uint256 private _dummy;",
                        "    function transfer(address, uint256) public {",
                        "        _dummy = 0;",
                        "    function transferFrom(address, address, uint256) public {",
                        "        _dummy = 0;",
                        "    function approve(address, uint256) public {",
                        "        _dummy = 0;",
                        "    function setAllowance(uint256 allowance_) public {",
                        "        _allowances[msg.sender] = allowance_;",
                        "    function allowance(address owner, address) public view returns (uint256) {",
                        "        return _allowances[owner];",
                        "}",
                        "contract SafeERC20Wrapper {",
                        "    using SafeERC20 for IERC20;",
                        "    IERC20 private _token;",
                        "    constructor (IERC20 token) public {",
                        "        _token = token;",
                        "    function transfer() public {",
                        "        _token.safeTransfer(address(0), 0);",
                        "    function transferFrom() public {",
                        "        _token.safeTransferFrom(address(0), address(0), 0);",
                        "    function approve(uint256 amount) public {",
                        "        _token.safeApprove(address(0), amount);",
                        "    function increaseAllowance(uint256 amount) public {",
                        "        _token.safeIncreaseAllowance(address(0), amount);",
                        "    function decreaseAllowance(uint256 amount) public {",
                        "        _token.safeDecreaseAllowance(address(0), amount);",
                        "        ERC20ReturnTrueMock(address(_token)).setAllowance(allowance_);",
                        "        return _token.allowance(address(0), address(0));",
                        " * @dev Wrappers around ERC20 operations that throw on failure (when the token",
                        " * contract returns false). Tokens that return no value (and instead revert or",
                        " * throw on failure) are also supported, non-reverting calls are assumed to be",
                        " * successful.",
                        "        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));",
                        "        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));",
                        "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));",
                        "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));",
                        "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));",
                        "    }",
                        "    /**",
                        "     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement",
                        "     * on the return value: the return value is optional (but if data is returned, it must equal true).",
                        "     * @param token The token targeted by the call.",
                        "     * @param data The call data (encoded using abi.encode or one of its variants).",
                        "     */",
                        "    function callOptionalReturn(IERC20 token, bytes memory data) private {",
                        "        (bool success, bytes memory returndata) = address(token).call(data);",
                        "        require(success);",
                        "        if (returndata.length > 0) {",
                        "            require(abi.decode(returndata, (bool)));",
                        "        }"
                    ],
                    "del": [
                        "contract ERC20FailingMock {",
                        "contract ERC20SucceedingMock {",
                        "contract SafeERC20Helper {",
                        "    using SafeERC20 for IERC20;",
                        "    IERC20 private _failing;",
                        "    IERC20 private _succeeding;",
                        "    constructor () public {",
                        "        _failing = IERC20(address(new ERC20FailingMock()));",
                        "        _succeeding = IERC20(address(new ERC20SucceedingMock()));",
                        "    function doFailingTransfer() public {",
                        "        _failing.safeTransfer(address(0), 0);",
                        "    function doFailingTransferFrom() public {",
                        "        _failing.safeTransferFrom(address(0), address(0), 0);",
                        "    function doFailingApprove() public {",
                        "        _failing.safeApprove(address(0), 0);",
                        "    function doFailingIncreaseAllowance() public {",
                        "        _failing.safeIncreaseAllowance(address(0), 0);",
                        "    function doFailingDecreaseAllowance() public {",
                        "        _failing.safeDecreaseAllowance(address(0), 0);",
                        "    function doSucceedingTransfer() public {",
                        "        _succeeding.safeTransfer(address(0), 0);",
                        "    function doSucceedingTransferFrom() public {",
                        "        _succeeding.safeTransferFrom(address(0), address(0), 0);",
                        "    function doSucceedingApprove(uint256 amount) public {",
                        "        _succeeding.safeApprove(address(0), amount);",
                        "    function doSucceedingIncreaseAllowance(uint256 amount) public {",
                        "        _succeeding.safeIncreaseAllowance(address(0), amount);",
                        "    function doSucceedingDecreaseAllowance(uint256 amount) public {",
                        "        _succeeding.safeDecreaseAllowance(address(0), amount);",
                        "        ERC20SucceedingMock(address(_succeeding)).setAllowance(allowance_);",
                        "        return _succeeding.allowance(address(0), address(0));",
                        " * @dev Wrappers around ERC20 operations that throw on failure.",
                        "        require(token.transfer(to, value));",
                        "        require(token.transferFrom(from, to, value));",
                        "        require(token.approve(spender, value));",
                        "        require(token.approve(spender, newAllowance));",
                        "        require(token.approve(spender, newAllowance));"
                    ]
                }
            }
        ],
        "* `TimedCrowdsale`: an internal `_extendTime(uint256 newClosingTime)` function was added (with a corresponding `TimedCrowdsaleExtended(uint256 prevClosingTime, uint256 newClosingTime)` event) allowing for users to safely develop mechanisms to extend the durations of unclosed crowdsales. Note that due to it being internal, there's no out-of-the-box way to do it: this feature is opt-in and must be explicitly invoked by users.\r": [],
        "* `ECDSA`: `recover` no longer accepts malleable signatures (those using upper-range values for `s`, or 0/1 for `v`). This helps prevent multiple issues when using signatures as unique identifiers. Read more about common ECDSA issues [here](https://yondon.blog/2019/01/01/how-not-to-use-ecdsa/). ([#1622](https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1622))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1622": {
                    "add": [
                        "        bytes32 r;",
                        "        bytes32 s;",
                        "        uint8 v;",
                        "        //",
                        "        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {",
                        "            return address(0);",
                        "            return address(0);",
                        "        return ecrecover(hash, v, r, s);"
                    ],
                    "del": [
                        "        bytes32 r;",
                        "        bytes32 s;",
                        "        uint8 v;",
                        "        if (v < 27) {",
                        "            v += 27;",
                        "            return (address(0));",
                        "        } else {",
                        "            return ecrecover(hash, v, r, s);"
                    ]
                }
            }
        ],
        " * `ERC721`'s transfers are now more gas efficient due to removal of unnecessary `SafeMath` calls. ([#1610](https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1610))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1610": {
                    "add": [
                        " * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number",
                        " * of elements in a mapping, issuing ERC721 ids, or counting request ids",
                        " * Include with `using Counter for Counter.Counter;`",
                        " * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the SafeMath",
                        " * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never",
                        " * directly accessed.",
                        "    using SafeMath for uint256;",
                        "    }",
                        "    function current(Counter storage counter) internal view returns (uint256) {",
                        "        return counter._value;",
                        "    }",
                        "    function increment(Counter storage counter) internal {",
                        "        counter._value += 1;",
                        "    function decrement(Counter storage counter) internal {",
                        "        counter._value = counter._value.sub(1);",
                        "    Counters.Counter private _counter;",
                        "    function current() public view returns (uint256) {",
                        "        return _counter.current();",
                        "    }",
                        "    function increment() public {",
                        "        _counter.increment();",
                        "    }",
                        "    function decrement() public {",
                        "        _counter.decrement();",
                        "    using Counters for Counters.Counter;",
                        "    mapping (address => Counters.Counter) private _ownedTokensCount;",
                        "        return _ownedTokensCount[owner].current();",
                        "        _ownedTokensCount[to].increment();",
                        "        _ownedTokensCount[owner].decrement();",
                        "        _ownedTokensCount[from].decrement();",
                        "        _ownedTokensCount[to].increment();"
                    ],
                    "del": [
                        " * @dev Provides an incrementing uint256 id acquired by the `Counter#next` getter.",
                        " * Use this for issuing ERC721 ids or keeping track of request ids, anything you want, really.",
                        " * Include with `using Counters` for Counters.Counter;`",
                        " * @notice Does not allow an Id of 0, which is popularly used to signify a null state in solidity.",
                        " * Does not protect from overflows, but if you have 2^256 ids, you have other problems.",
                        " * (But actually, it's generally impossible to increment a counter this many times, energy wise",
                        " * so it's not something you have to worry about.)",
                        "    function next(Counter storage index) internal returns (uint256) {",
                        "        index.current += 1;",
                        "        return index.current;",
                        "    uint256 public theId;",
                        "    mapping(string => Counters.Counter) private _counters;",
                        "    function doThing(string memory key) public returns (uint256) {",
                        "        theId = _counters[key].next();",
                        "        return theId;",
                        "    mapping (address => uint256) private _ownedTokensCount;",
                        "        return _ownedTokensCount[owner];",
                        "        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);",
                        "        _ownedTokensCount[owner] = _ownedTokensCount[owner].sub(1);",
                        "        _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);",
                        "        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);"
                    ]
                }
            }
        ],
        "### Bugfixes:\r": [],
        " * (minor) `SafeERC20`: `safeApprove` wasn't properly checking for a zero allowance when attempting to set a non-zero allowance. This bug was reported independently by @nikeshnazareth. Thanks a lot! ([#1647](https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1647))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1647": {
                    "add": [
                        "    mapping (address => uint256) private _allowances;",
                        "        _allowances[msg.sender] = allowance_;",
                        "    function allowance(address owner, address) public view returns (uint256) {",
                        "        return _allowances[owner];",
                        "        require((value == 0) || (token.allowance(address(this), spender) == 0));"
                    ],
                    "del": [
                        "    uint256 private _allowance;",
                        "        _allowance = allowance_;",
                        "    function allowance(address, address) public view returns (uint256) {",
                        "        return _allowance;",
                        "        require((value == 0) || (token.allowance(msg.sender, spender) == 0));"
                    ]
                }
            }
        ]
    },
    "2.2.0-rc.1": {
        "This minor release includes a way to store token balances and supply so that they can be later queried in a gas-efficient manner :bookmark:, allows safe interaction with some old, non-compliant tokens :lock:, prevents user errors when using ECDSA signatures :memo: (the magic behind metatransactions! :sparkles:), and provides multiple minor additions and improvements to the API.\r": [],
        "* `ERC20Snapshot`: this variant allows for snapshots to be created on demand, storing the current token balances and total supply so that they can be later retrieved in a gas-efficient manner and e.g. calculate dividends at a past time. ([#1617](https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1617))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1617": {
                    "add": [
                        "/**",
                        " * @title ERC20 token with snapshots.",
                        " * inspired by Jordi Baylina's MiniMeToken to record historical balances",
                        " * Snapshots store a value at the time a snapshot is taken (and a new snapshot id created), and the corresponding",
                        " * snapshot id. Each account has individual snapshots taken on demand, as does the token's total supply.",
                        " * @author Validity Labs AG <info@validitylabs.org>",
                        " */",
                        "contract ERC20Snapshot is ERC20 {",
                        "    using SafeMath for uint256;",
                        "    using Arrays for uint256[];",
                        "    using Counters for Counters.Counter;",
                        "    struct Snapshots {",
                        "        uint256[] ids;",
                        "        uint256[] values;",
                        "    }",
                        "    mapping (address => Snapshots) private _accountBalanceSnapshots;",
                        "    Snapshots private _totalSupplySnaphots;",
                        "    Counters.Counter private _currentSnapshotId;",
                        "    event Snapshot(uint256 id);",
                        "    function snapshot() public returns (uint256) {",
                        "        _currentSnapshotId.increment();",
                        "        uint256 currentId = _currentSnapshotId.current();",
                        "        emit Snapshot(currentId);",
                        "        return currentId;",
                        "    }",
                        "    function balanceOfAt(address account, uint256 snapshotId) public view returns (uint256) {",
                        "        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _accountBalanceSnapshots[account]);",
                        "        return snapshotted ? value : balanceOf(account);",
                        "    }",
                        "    function totalSupplyAt(uint256 snapshotId) public view returns(uint256) {",
                        "        (bool snapshotted, uint256 value) = _valueAt(snapshotId, _totalSupplySnaphots);",
                        "        return snapshotted ? value : totalSupply();",
                        "    }",
                        "    function _transfer(address from, address to, uint256 value) internal {",
                        "        _updateAccountSnapshot(from);",
                        "        _updateAccountSnapshot(to);",
                        "        super._transfer(from, to, value);",
                        "    }",
                        "    function _mint(address account, uint256 value) internal {",
                        "        _updateAccountSnapshot(account);",
                        "        _updateTotalSupplySnapshot();",
                        "        super._mint(account, value);",
                        "    }",
                        "    function _burn(address account, uint256 value) internal {",
                        "        _updateAccountSnapshot(account);",
                        "        _updateTotalSupplySnapshot();",
                        "        super._burn(account, value);",
                        "    }",
                        "    //",
                        "    function _valueAt(uint256 snapshotId, Snapshots storage snapshots)",
                        "        private view returns (bool, uint256)",
                        "    {",
                        "        require(snapshotId > 0);",
                        "        require(snapshotId <= _currentSnapshotId.current());",
                        "        uint256 index = snapshots.ids.findUpperBound(snapshotId);",
                        "        if (index == snapshots.ids.length) {",
                        "            return (false, 0);",
                        "        } else {",
                        "            return (true, snapshots.values[index]);",
                        "        }",
                        "    }",
                        "    function _updateAccountSnapshot(address account) private {",
                        "        _updateSnapshot(_accountBalanceSnapshots[account], balanceOf(account));",
                        "    }",
                        "    function _updateTotalSupplySnapshot() private {",
                        "        _updateSnapshot(_totalSupplySnaphots, totalSupply());",
                        "    }",
                        "    function _updateSnapshot(Snapshots storage snapshots, uint256 currentValue) private {",
                        "        uint256 currentId = _currentSnapshotId.current();",
                        "        if (_lastSnapshotId(snapshots.ids) < currentId) {",
                        "            snapshots.ids.push(currentId);",
                        "            snapshots.values.push(currentValue);",
                        "        }",
                        "    }",
                        "    function _lastSnapshotId(uint256[] storage ids) private view returns (uint256) {",
                        "        if (ids.length == 0) {",
                        "            return 0;",
                        "        } else {",
                        "            return ids[ids.length - 1];",
                        "        }",
                        "    }",
                        "}",
                        "contract ERC20SnapshotMock is ERC20Snapshot {",
                        "    constructor(address initialAccount, uint256 initialBalance) public {",
                        "        _mint(initialAccount, initialBalance);",
                        "    }",
                        "    function mint(address account, uint256 amount) public {",
                        "        _mint(account, amount);",
                        "    }",
                        "    function burn(address account, uint256 amount) public {",
                        "        _burn(account, amount);",
                        "    }",
                        "}"
                    ],
                    "del": []
                }
            }
        ],
        " * `SafeERC20`: the `ERC20` standard requires that all function calls (e.g. `transfer`, `approve`, etc.) return a boolean value indicating success. However, they are multiple widely used tokens out there that return no such value: they simply `revert` when encountering an error condition. Since Solidity v0.4.22, special code was needed to interact with this non-compliant tokens: now, all of `SafeERC20` can be used to safely call both compliant and non-compliant tokens, without the developer having to worry about it. ([#1655](https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1655))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1655": {
                    "add": [
                        "contract ERC20ReturnFalseMock {",
                        "contract ERC20ReturnTrueMock {",
                        "contract ERC20NoReturnMock {",
                        "    mapping (address => uint256) private _allowances;",
                        "    uint256 private _dummy;",
                        "    function transfer(address, uint256) public {",
                        "        _dummy = 0;",
                        "    function transferFrom(address, address, uint256) public {",
                        "        _dummy = 0;",
                        "    function approve(address, uint256) public {",
                        "        _dummy = 0;",
                        "    function setAllowance(uint256 allowance_) public {",
                        "        _allowances[msg.sender] = allowance_;",
                        "    function allowance(address owner, address) public view returns (uint256) {",
                        "        return _allowances[owner];",
                        "}",
                        "contract SafeERC20Wrapper {",
                        "    using SafeERC20 for IERC20;",
                        "    IERC20 private _token;",
                        "    constructor (IERC20 token) public {",
                        "        _token = token;",
                        "    function transfer() public {",
                        "        _token.safeTransfer(address(0), 0);",
                        "    function transferFrom() public {",
                        "        _token.safeTransferFrom(address(0), address(0), 0);",
                        "    function approve(uint256 amount) public {",
                        "        _token.safeApprove(address(0), amount);",
                        "    function increaseAllowance(uint256 amount) public {",
                        "        _token.safeIncreaseAllowance(address(0), amount);",
                        "    function decreaseAllowance(uint256 amount) public {",
                        "        _token.safeDecreaseAllowance(address(0), amount);",
                        "        ERC20ReturnTrueMock(address(_token)).setAllowance(allowance_);",
                        "        return _token.allowance(address(0), address(0));",
                        " * @dev Wrappers around ERC20 operations that throw on failure (when the token",
                        " * contract returns false). Tokens that return no value (and instead revert or",
                        " * throw on failure) are also supported, non-reverting calls are assumed to be",
                        " * successful.",
                        "        callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));",
                        "        callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));",
                        "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));",
                        "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));",
                        "        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));",
                        "    }",
                        "    /**",
                        "     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement",
                        "     * on the return value: the return value is optional (but if data is returned, it must equal true).",
                        "     * @param token The token targeted by the call.",
                        "     * @param data The call data (encoded using abi.encode or one of its variants).",
                        "     */",
                        "    function callOptionalReturn(IERC20 token, bytes memory data) private {",
                        "        (bool success, bytes memory returndata) = address(token).call(data);",
                        "        require(success);",
                        "        if (returndata.length > 0) {",
                        "            require(abi.decode(returndata, (bool)));",
                        "        }"
                    ],
                    "del": [
                        "contract ERC20FailingMock {",
                        "contract ERC20SucceedingMock {",
                        "contract SafeERC20Helper {",
                        "    using SafeERC20 for IERC20;",
                        "    IERC20 private _failing;",
                        "    IERC20 private _succeeding;",
                        "    constructor () public {",
                        "        _failing = IERC20(address(new ERC20FailingMock()));",
                        "        _succeeding = IERC20(address(new ERC20SucceedingMock()));",
                        "    function doFailingTransfer() public {",
                        "        _failing.safeTransfer(address(0), 0);",
                        "    function doFailingTransferFrom() public {",
                        "        _failing.safeTransferFrom(address(0), address(0), 0);",
                        "    function doFailingApprove() public {",
                        "        _failing.safeApprove(address(0), 0);",
                        "    function doFailingIncreaseAllowance() public {",
                        "        _failing.safeIncreaseAllowance(address(0), 0);",
                        "    function doFailingDecreaseAllowance() public {",
                        "        _failing.safeDecreaseAllowance(address(0), 0);",
                        "    function doSucceedingTransfer() public {",
                        "        _succeeding.safeTransfer(address(0), 0);",
                        "    function doSucceedingTransferFrom() public {",
                        "        _succeeding.safeTransferFrom(address(0), address(0), 0);",
                        "    function doSucceedingApprove(uint256 amount) public {",
                        "        _succeeding.safeApprove(address(0), amount);",
                        "    function doSucceedingIncreaseAllowance(uint256 amount) public {",
                        "        _succeeding.safeIncreaseAllowance(address(0), amount);",
                        "    function doSucceedingDecreaseAllowance(uint256 amount) public {",
                        "        _succeeding.safeDecreaseAllowance(address(0), amount);",
                        "        ERC20SucceedingMock(address(_succeeding)).setAllowance(allowance_);",
                        "        return _succeeding.allowance(address(0), address(0));",
                        " * @dev Wrappers around ERC20 operations that throw on failure.",
                        "        require(token.transfer(to, value));",
                        "        require(token.transferFrom(from, to, value));",
                        "        require(token.approve(spender, value));",
                        "        require(token.approve(spender, newAllowance));",
                        "        require(token.approve(spender, newAllowance));"
                    ]
                }
            }
        ],
        "* `TimedCrowdsale`: an internal `_extendTime(uint256 newClosingTime)` function was added (with a corresponding `TimedCrowdsaleExtended(uint256 prevClosingTime, uint256 newClosingTime)` event) allowing for users to safely develop mechanisms to extend the durations of unclosed crowdsales. Note that due to it being internal, there's no out-of-the-box way to do it: this feature is opt-in and must be explicitly invoked by users.\r": [],
        "* `ECDSA`: `recover` no longer accepts malleable signatures (those using upper-range values for `s`, or 0/1 for `v`). This helps prevent multiple issues when using signatures as unique identifiers. Read more about common ECDSA issues [here](https://yondon.blog/2019/01/01/how-not-to-use-ecdsa/). ([#1622](https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1622))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1622": {
                    "add": [
                        "        bytes32 r;",
                        "        bytes32 s;",
                        "        uint8 v;",
                        "        //",
                        "        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {",
                        "            return address(0);",
                        "            return address(0);",
                        "        return ecrecover(hash, v, r, s);"
                    ],
                    "del": [
                        "        bytes32 r;",
                        "        bytes32 s;",
                        "        uint8 v;",
                        "        if (v < 27) {",
                        "            v += 27;",
                        "            return (address(0));",
                        "        } else {",
                        "            return ecrecover(hash, v, r, s);"
                    ]
                }
            }
        ],
        " * `ERC721`'s transfers are now more gas efficient due to removal of unnecessary `SafeMath` calls. ([#1610](https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1610))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1610": {
                    "add": [
                        " * @dev Provides counters that can only be incremented or decremented by one. This can be used e.g. to track the number",
                        " * of elements in a mapping, issuing ERC721 ids, or counting request ids",
                        " * Include with `using Counter for Counter.Counter;`",
                        " * Since it is not possible to overflow a 256 bit integer with increments of one, `increment` can skip the SafeMath",
                        " * overflow check, thereby saving gas. This does assume however correct usage, in that the underlying `_value` is never",
                        " * directly accessed.",
                        "    using SafeMath for uint256;",
                        "    }",
                        "    function current(Counter storage counter) internal view returns (uint256) {",
                        "        return counter._value;",
                        "    }",
                        "    function increment(Counter storage counter) internal {",
                        "        counter._value += 1;",
                        "    function decrement(Counter storage counter) internal {",
                        "        counter._value = counter._value.sub(1);",
                        "    Counters.Counter private _counter;",
                        "    function current() public view returns (uint256) {",
                        "        return _counter.current();",
                        "    }",
                        "    function increment() public {",
                        "        _counter.increment();",
                        "    }",
                        "    function decrement() public {",
                        "        _counter.decrement();",
                        "    using Counters for Counters.Counter;",
                        "    mapping (address => Counters.Counter) private _ownedTokensCount;",
                        "        return _ownedTokensCount[owner].current();",
                        "        _ownedTokensCount[to].increment();",
                        "        _ownedTokensCount[owner].decrement();",
                        "        _ownedTokensCount[from].decrement();",
                        "        _ownedTokensCount[to].increment();"
                    ],
                    "del": [
                        " * @dev Provides an incrementing uint256 id acquired by the `Counter#next` getter.",
                        " * Use this for issuing ERC721 ids or keeping track of request ids, anything you want, really.",
                        " * Include with `using Counters` for Counters.Counter;`",
                        " * @notice Does not allow an Id of 0, which is popularly used to signify a null state in solidity.",
                        " * Does not protect from overflows, but if you have 2^256 ids, you have other problems.",
                        " * (But actually, it's generally impossible to increment a counter this many times, energy wise",
                        " * so it's not something you have to worry about.)",
                        "    function next(Counter storage index) internal returns (uint256) {",
                        "        index.current += 1;",
                        "        return index.current;",
                        "    uint256 public theId;",
                        "    mapping(string => Counters.Counter) private _counters;",
                        "    function doThing(string memory key) public returns (uint256) {",
                        "        theId = _counters[key].next();",
                        "        return theId;",
                        "    mapping (address => uint256) private _ownedTokensCount;",
                        "        return _ownedTokensCount[owner];",
                        "        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);",
                        "        _ownedTokensCount[owner] = _ownedTokensCount[owner].sub(1);",
                        "        _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);",
                        "        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);"
                    ]
                }
            }
        ],
        "### Bugfixes:\r": [],
        " * (minor) `SafeERC20`: `safeApprove` wasn't properly checking for a zero allowance when attempting to set a non-zero allowance. This bug was reported independently by @nikeshnazareth. Thanks a lot! ([#1647](https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1647))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1647": {
                    "add": [
                        "    mapping (address => uint256) private _allowances;",
                        "        _allowances[msg.sender] = allowance_;",
                        "    function allowance(address owner, address) public view returns (uint256) {",
                        "        return _allowances[owner];",
                        "        require((value == 0) || (token.allowance(address(this), spender) == 0));"
                    ],
                    "del": [
                        "    uint256 private _allowance;",
                        "        _allowance = allowance_;",
                        "    function allowance(address, address) public view returns (uint256) {",
                        "        return _allowance;",
                        "        require((value == 0) || (token.allowance(msg.sender, spender) == 0));"
                    ]
                }
            }
        ]
    },
    "2.1.3": {
        "### Bugfix release :bug: :wrench: \r": [],
        "A minor issue with `SafeERC20.safeApprove` was identified and reported independently by @nikeshnazareth (thanks once again!), this release contains the correspondig fix: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1647.\r": [],
        "These independent reviews are a great way to keep our code secure and correct: we'll be making a push for a properly funded bug bounty during these next weeks to continue encouraging them. Stay tuned!": []
    },
    "2.0.1": {
        "### Bugfix release :bug: :wrench: \r": [],
        "This is a backport of the 2.1.3 bugfix release for the 2.0.x line, which features Solidity v0.4.25 support: if you're still using OpenZeppelin v2.0.0, you can upgrade to this version instead of migrating to v2.1 and Solidity v0.5.": []
    },
    "2.1.2": {},
    "2.1.1": {
        " * Added `WhitelistCrowdsale`, a crowdsale where only whitelisted accounts (`WhitelistedRole`) can purchase tokens. Adding or removing accounts from the whitelist is done by whitelister admins (`WhitelistAdminRole`). Similar to the pre-2.0 `WhitelistedCrowdsale`. ([#1525](https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1525), [#1589](https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1589))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1525": {
                    "add": [
                        "/**",
                        " * @title WhitelistedRole",
                        " * @dev Whitelisted accounts have been approved by a Whitelister to perform certain actions (e.g. participate in a",
                        " * crowdsale). This role is special in that the only accounts that can add it are Whitelisters (who can also remove it),",
                        " * and not Whitelisteds themselves.",
                        " */",
                        "contract WhitelistedRole is WhitelisterRole {",
                        "    using Roles for Roles.Role;",
                        "    event WhitelistedAdded(address indexed account);",
                        "    event WhitelistedRemoved(address indexed account);",
                        "    Roles.Role private _whitelisteds;",
                        "    modifier onlyWhitelisted() {",
                        "        require(isWhitelisted(msg.sender));",
                        "        _;",
                        "    }",
                        "    function isWhitelisted(address account) public view returns (bool) {",
                        "        return _whitelisteds.has(account);",
                        "    }",
                        "    function addWhitelisted(address account) public onlyWhitelister {",
                        "        _addWhitelisted(account);",
                        "    }",
                        "    function removeWhitelisted(address account) public onlyWhitelister {",
                        "        _removeWhitelisted(account);",
                        "    }",
                        "    function renounceWhitelisted() public {",
                        "        _removeWhitelisted(msg.sender);",
                        "    }",
                        "    function _addWhitelisted(address account) internal {",
                        "        _whitelisteds.add(account);",
                        "        emit WhitelistedAdded(account);",
                        "    }",
                        "    function _removeWhitelisted(address account) internal {",
                        "        _whitelisteds.remove(account);",
                        "        emit WhitelistedRemoved(account);",
                        "    }",
                        "}",
                        "/**",
                        " * @title WhitelisterRole",
                        " * @dev Whitelisters are responsible for assigning and removing Whitelisted accounts.",
                        " */",
                        "contract WhitelisterRole {",
                        "    using Roles for Roles.Role;",
                        "    event WhitelisterAdded(address indexed account);",
                        "    event WhitelisterRemoved(address indexed account);",
                        "    Roles.Role private _whitelisters;",
                        "    constructor () internal {",
                        "        _addWhitelister(msg.sender);",
                        "    }",
                        "    modifier onlyWhitelister() {",
                        "        require(isWhitelister(msg.sender));",
                        "        _;",
                        "    }",
                        "    function isWhitelister(address account) public view returns (bool) {",
                        "        return _whitelisters.has(account);",
                        "    }",
                        "    function addWhitelister(address account) public onlyWhitelister {",
                        "        _addWhitelister(account);",
                        "    }",
                        "    function renounceWhitelister() public {",
                        "        _removeWhitelister(msg.sender);",
                        "    }",
                        "    function _addWhitelister(address account) internal {",
                        "        _whitelisters.add(account);",
                        "        emit WhitelisterAdded(account);",
                        "    }",
                        "    function _removeWhitelister(address account) internal {",
                        "        _whitelisters.remove(account);",
                        "        emit WhitelisterRemoved(account);",
                        "    }",
                        "}",
                        "/**",
                        " * @title WhitelistCrowdsale",
                        " * @dev Crowdsale in which only whitelisted users can contribute.",
                        " */",
                        "contract WhitelistCrowdsale is WhitelistedRole, Crowdsale {",
                        "    /**",
                        "    * @dev Extend parent behavior requiring beneficiary to be whitelisted. Note that no",
                        "    * restriction is imposed on the account sending the transaction.",
                        "    * @param _beneficiary Token beneficiary",
                        "    * @param _weiAmount Amount of wei contributed",
                        "    */",
                        "    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal view {",
                        "        require(isWhitelisted(_beneficiary));",
                        "        super._preValidatePurchase(_beneficiary, _weiAmount);",
                        "    }",
                        "}",
                        "contract WhitelistCrowdsaleImpl is Crowdsale, WhitelistCrowdsale {",
                        "    constructor (uint256 _rate, address _wallet, IERC20 _token) Crowdsale(_rate, _wallet, _token) public {}",
                        "}",
                        "contract WhitelistedRoleMock is WhitelistedRole {",
                        "    function onlyWhitelistedMock() public view onlyWhitelisted {",
                        "    }",
                        "}",
                        "contract WhitelisterRoleMock is WhitelisterRole {",
                        "    function removeWhitelister(address account) public {",
                        "        _removeWhitelister(account);",
                        "    }",
                        "    function onlyWhitelisterMock() public view onlyWhitelister {",
                        "    }",
                        "    function _removeWhitelister(address account) internal {",
                        "        super._removeWhitelister(account);",
                        "    }",
                        "}"
                    ],
                    "del": []
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1589": {
                    "add": [
                        "/**",
                        " * @title WhitelistAdminRole",
                        " * @dev WhitelistAdmins are responsible for assigning and removing Whitelisted accounts.",
                        " */",
                        "contract WhitelistAdminRole {",
                        "    using Roles for Roles.Role;",
                        "    event WhitelistAdminAdded(address indexed account);",
                        "    event WhitelistAdminRemoved(address indexed account);",
                        "    Roles.Role private _whitelistAdmins;",
                        "    constructor () internal {",
                        "        _addWhitelistAdmin(msg.sender);",
                        "    }",
                        "    modifier onlyWhitelistAdmin() {",
                        "        require(isWhitelistAdmin(msg.sender));",
                        "        _;",
                        "    }",
                        "    function isWhitelistAdmin(address account) public view returns (bool) {",
                        "        return _whitelistAdmins.has(account);",
                        "    }",
                        "    function addWhitelistAdmin(address account) public onlyWhitelistAdmin {",
                        "        _addWhitelistAdmin(account);",
                        "    }",
                        "    function renounceWhitelistAdmin() public {",
                        "        _removeWhitelistAdmin(msg.sender);",
                        "    }",
                        "    function _addWhitelistAdmin(address account) internal {",
                        "        _whitelistAdmins.add(account);",
                        "        emit WhitelistAdminAdded(account);",
                        "    }",
                        "    function _removeWhitelistAdmin(address account) internal {",
                        "        _whitelistAdmins.remove(account);",
                        "        emit WhitelistAdminRemoved(account);",
                        "    }",
                        "}",
                        " * @dev Whitelisted accounts have been approved by a WhitelistAdmin to perform certain actions (e.g. participate in a",
                        " * crowdsale). This role is special in that the only accounts that can add it are WhitelistAdmins (who can also remove",
                        " * it), and not Whitelisteds themselves.",
                        "contract WhitelistedRole is WhitelistAdminRole {",
                        "    function addWhitelisted(address account) public onlyWhitelistAdmin {",
                        "    function removeWhitelisted(address account) public onlyWhitelistAdmin {",
                        "contract WhitelistAdminRoleMock is WhitelistAdminRole {",
                        "    function removeWhitelistAdmin(address account) public {",
                        "        _removeWhitelistAdmin(account);",
                        "    }",
                        "    function onlyWhitelistAdminMock() public view onlyWhitelistAdmin {",
                        "    }",
                        "    function _removeWhitelistAdmin(address account) internal {",
                        "        super._removeWhitelistAdmin(account);",
                        "    }",
                        "}"
                    ],
                    "del": [
                        " * @dev Whitelisted accounts have been approved by a Whitelister to perform certain actions (e.g. participate in a",
                        " * crowdsale). This role is special in that the only accounts that can add it are Whitelisters (who can also remove it),",
                        " * and not Whitelisteds themselves.",
                        "contract WhitelistedRole is WhitelisterRole {",
                        "    function addWhitelisted(address account) public onlyWhitelister {",
                        "    function removeWhitelisted(address account) public onlyWhitelister {",
                        "/**",
                        " * @title WhitelisterRole",
                        " * @dev Whitelisters are responsible for assigning and removing Whitelisted accounts.",
                        " */",
                        "contract WhitelisterRole {",
                        "    using Roles for Roles.Role;",
                        "    event WhitelisterAdded(address indexed account);",
                        "    event WhitelisterRemoved(address indexed account);",
                        "    Roles.Role private _whitelisters;",
                        "    constructor () internal {",
                        "        _addWhitelister(msg.sender);",
                        "    }",
                        "    modifier onlyWhitelister() {",
                        "        require(isWhitelister(msg.sender));",
                        "        _;",
                        "    }",
                        "    function isWhitelister(address account) public view returns (bool) {",
                        "        return _whitelisters.has(account);",
                        "    }",
                        "    function addWhitelister(address account) public onlyWhitelister {",
                        "        _addWhitelister(account);",
                        "    }",
                        "    function renounceWhitelister() public {",
                        "        _removeWhitelister(msg.sender);",
                        "    }",
                        "    function _addWhitelister(address account) internal {",
                        "        _whitelisters.add(account);",
                        "        emit WhitelisterAdded(account);",
                        "    }",
                        "    function _removeWhitelister(address account) internal {",
                        "        _whitelisters.remove(account);",
                        "        emit WhitelisterRemoved(account);",
                        "    }",
                        "}",
                        "contract WhitelisterRoleMock is WhitelisterRole {",
                        "    function removeWhitelister(address account) public {",
                        "        _removeWhitelister(account);",
                        "    }",
                        "    function onlyWhitelisterMock() public view onlyWhitelister {",
                        "    }",
                        "    function _removeWhitelister(address account) internal {",
                        "        super._removeWhitelister(account);",
                        "    }",
                        "}"
                    ]
                }
            }
        ],
        " * `ERC20` and `ERC721` are now more gas efficient due to removed redundant `SSTORE`s and `require`s. ([#1409](https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1409) and [#1549](https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1549))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1409": {
                    "add": [],
                    "del": [
                        "    require(value <= _allowed[from][msg.sender]);",
                        "    require(value <= _balances[from]);",
                        "    require(value <= _balances[account]);"
                    ]
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1549": {
                    "add": [
                        " * checking token existence, removal of a token from an address",
                        "    function burn(address owner, uint256 tokenId) public {",
                        "        _burn(owner, tokenId);",
                        "    }",
                        "        require(!_exists(tokenId));",
                        "        _tokenOwner[tokenId] = to;",
                        "        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);",
                        "        require(ownerOf(tokenId) == owner);",
                        "        _ownedTokensCount[owner] = _ownedTokensCount[owner].sub(1);",
                        "        _tokenOwner[tokenId] = address(0);",
                        "    ",
                        "        _addTokenToOwnerEnumeration(to, tokenId);",
                        "        _addTokenToAllTokensEnumeration(tokenId);",
                        "        _removeTokenFromOwnerEnumeration(owner, tokenId);",
                        "        _ownedTokensIndex[tokenId] = 0;",
                        "        _removeTokenFromAllTokensEnumeration(tokenId);",
                        "        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;",
                        "        _ownedTokens[to].push(tokenId);",
                        "    }",
                        "    /**",
                        "     * @dev Private function to add a token to this extension's token tracking data structures.",
                        "     * @param tokenId uint256 ID of the token to be added to the tokens list",
                        "     */",
                        "    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {",
                        "        _allTokensIndex[tokenId] = _allTokens.length;",
                        "        _allTokens.push(tokenId);",
                        "        if (tokenIndex != lastTokenIndex) {",
                        "            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Private function to remove a token from this extension's token tracking data structures.",
                        "     * This has O(1) time complexity, but alters the order of the _allTokens array.",
                        "     * @param tokenId uint256 ID of the token to be removed from the tokens list",
                        "     */",
                        "    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {",
                        "        uint256 lastTokenIndex = _allTokens.length.sub(1);",
                        "        uint256 tokenIndex = _allTokensIndex[tokenId];",
                        "        uint256 lastTokenId = _allTokens[lastTokenIndex];",
                        "        _allTokens.length--;",
                        "        _allTokensIndex[tokenId] = 0;"
                    ],
                    "del": [
                        " * checking token existence, removal of a token from an address ",
                        "    function removeTokenFrom(address from, uint256 tokenId) public {",
                        "        _removeTokenFrom(from, tokenId);",
                        "    }",
                        "        _addTokenTo(to, tokenId);",
                        "        _removeTokenFrom(owner, tokenId);",
                        "    /**",
                        "     * @dev Internal function to add a token ID to the list of a given address",
                        "     * Note that this function is left internal to make ERC721Enumerable possible, but is not",
                        "     * intended to be called by custom derived contracts: in particular, it emits no Transfer event.",
                        "     * @param to address representing the new owner of the given token ID",
                        "     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address",
                        "     */",
                        "    function _addTokenTo(address to, uint256 tokenId) internal {",
                        "        require(_tokenOwner[tokenId] == address(0));",
                        "        _tokenOwner[tokenId] = to;",
                        "        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);",
                        "    }",
                        "    /**",
                        "     * @dev Internal function to remove a token ID from the list of a given address",
                        "     * Note that this function is left internal to make ERC721Enumerable possible, but is not",
                        "     * intended to be called by custom derived contracts: in particular, it emits no Transfer event,",
                        "     * and doesn't clear approvals.",
                        "     * @param from address representing the previous owner of the given token ID",
                        "     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address",
                        "     */",
                        "    function _removeTokenFrom(address from, uint256 tokenId) internal {",
                        "        require(ownerOf(tokenId) == from);",
                        "        _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);",
                        "        _tokenOwner[tokenId] = address(0);",
                        "    }",
                        "    /**",
                        "     * @dev Internal function to add a token ID to the list of a given address",
                        "     * This function is internal due to language limitations, see the note in ERC721.sol.",
                        "     * It is not intended to be called by custom derived contracts: in particular, it emits no Transfer event.",
                        "     * @param to address representing the new owner of the given token ID",
                        "     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address",
                        "     */",
                        "    function _addTokenTo(address to, uint256 tokenId) internal {",
                        "        super._addTokenTo(to, tokenId);",
                        "        _addTokenToOwnerEnumeration(to, tokenId);",
                        "    }",
                        "    /**",
                        "     * @dev Internal function to remove a token ID from the list of a given address",
                        "     * This function is internal due to language limitations, see the note in ERC721.sol.",
                        "     * It is not intended to be called by custom derived contracts: in particular, it emits no Transfer event,",
                        "     * and doesn't clear approvals.",
                        "     * @param from address representing the previous owner of the given token ID",
                        "     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address",
                        "     */",
                        "    function _removeTokenFrom(address from, uint256 tokenId) internal {",
                        "        super._removeTokenFrom(from, tokenId);",
                        "        _removeTokenFromOwnerEnumeration(from, tokenId);",
                        "        _ownedTokensIndex[tokenId] = 0;",
                        "    }",
                        "        _allTokensIndex[tokenId] = _allTokens.length;",
                        "        _allTokens.push(tokenId);",
                        "        uint256 tokenIndex = _allTokensIndex[tokenId];",
                        "        uint256 lastTokenIndex = _allTokens.length.sub(1);",
                        "        uint256 lastToken = _allTokens[lastTokenIndex];",
                        "        _allTokens[tokenIndex] = lastToken;",
                        "        _allTokens[lastTokenIndex] = 0;",
                        "        _allTokens.length--;",
                        "        _allTokensIndex[tokenId] = 0;",
                        "        _allTokensIndex[lastToken] = tokenIndex;",
                        "        uint256 newOwnedTokensLength = _ownedTokens[to].push(tokenId);",
                        "        _ownedTokensIndex[tokenId] = newOwnedTokensLength - 1;",
                        "        uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];"
                    ]
                }
            }
        ]
    },
    "2.1.0-rc.2": {},
    "2.1.0-rc.1": {
        " * Added `WhitelistCrowdsale`, a crowdsale where only whitelisted accounts (`WhitelistedRole`) can purchase tokens. Adding or removing accounts from the whitelist is done by whitelisters (`WhitelisterRole`). Similar to the pre-2.0 `WhitelistedCrowdsale`. ([#1525](https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1525))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1525": {
                    "add": [
                        "/**",
                        " * @title WhitelistedRole",
                        " * @dev Whitelisted accounts have been approved by a Whitelister to perform certain actions (e.g. participate in a",
                        " * crowdsale). This role is special in that the only accounts that can add it are Whitelisters (who can also remove it),",
                        " * and not Whitelisteds themselves.",
                        " */",
                        "contract WhitelistedRole is WhitelisterRole {",
                        "    using Roles for Roles.Role;",
                        "    event WhitelistedAdded(address indexed account);",
                        "    event WhitelistedRemoved(address indexed account);",
                        "    Roles.Role private _whitelisteds;",
                        "    modifier onlyWhitelisted() {",
                        "        require(isWhitelisted(msg.sender));",
                        "        _;",
                        "    }",
                        "    function isWhitelisted(address account) public view returns (bool) {",
                        "        return _whitelisteds.has(account);",
                        "    }",
                        "    function addWhitelisted(address account) public onlyWhitelister {",
                        "        _addWhitelisted(account);",
                        "    }",
                        "    function removeWhitelisted(address account) public onlyWhitelister {",
                        "        _removeWhitelisted(account);",
                        "    }",
                        "    function renounceWhitelisted() public {",
                        "        _removeWhitelisted(msg.sender);",
                        "    }",
                        "    function _addWhitelisted(address account) internal {",
                        "        _whitelisteds.add(account);",
                        "        emit WhitelistedAdded(account);",
                        "    }",
                        "    function _removeWhitelisted(address account) internal {",
                        "        _whitelisteds.remove(account);",
                        "        emit WhitelistedRemoved(account);",
                        "    }",
                        "}",
                        "/**",
                        " * @title WhitelisterRole",
                        " * @dev Whitelisters are responsible for assigning and removing Whitelisted accounts.",
                        " */",
                        "contract WhitelisterRole {",
                        "    using Roles for Roles.Role;",
                        "    event WhitelisterAdded(address indexed account);",
                        "    event WhitelisterRemoved(address indexed account);",
                        "    Roles.Role private _whitelisters;",
                        "    constructor () internal {",
                        "        _addWhitelister(msg.sender);",
                        "    }",
                        "    modifier onlyWhitelister() {",
                        "        require(isWhitelister(msg.sender));",
                        "        _;",
                        "    }",
                        "    function isWhitelister(address account) public view returns (bool) {",
                        "        return _whitelisters.has(account);",
                        "    }",
                        "    function addWhitelister(address account) public onlyWhitelister {",
                        "        _addWhitelister(account);",
                        "    }",
                        "    function renounceWhitelister() public {",
                        "        _removeWhitelister(msg.sender);",
                        "    }",
                        "    function _addWhitelister(address account) internal {",
                        "        _whitelisters.add(account);",
                        "        emit WhitelisterAdded(account);",
                        "    }",
                        "    function _removeWhitelister(address account) internal {",
                        "        _whitelisters.remove(account);",
                        "        emit WhitelisterRemoved(account);",
                        "    }",
                        "}",
                        "/**",
                        " * @title WhitelistCrowdsale",
                        " * @dev Crowdsale in which only whitelisted users can contribute.",
                        " */",
                        "contract WhitelistCrowdsale is WhitelistedRole, Crowdsale {",
                        "    /**",
                        "    * @dev Extend parent behavior requiring beneficiary to be whitelisted. Note that no",
                        "    * restriction is imposed on the account sending the transaction.",
                        "    * @param _beneficiary Token beneficiary",
                        "    * @param _weiAmount Amount of wei contributed",
                        "    */",
                        "    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal view {",
                        "        require(isWhitelisted(_beneficiary));",
                        "        super._preValidatePurchase(_beneficiary, _weiAmount);",
                        "    }",
                        "}",
                        "contract WhitelistCrowdsaleImpl is Crowdsale, WhitelistCrowdsale {",
                        "    constructor (uint256 _rate, address _wallet, IERC20 _token) Crowdsale(_rate, _wallet, _token) public {}",
                        "}",
                        "contract WhitelistedRoleMock is WhitelistedRole {",
                        "    function onlyWhitelistedMock() public view onlyWhitelisted {",
                        "    }",
                        "}",
                        "contract WhitelisterRoleMock is WhitelisterRole {",
                        "    function removeWhitelister(address account) public {",
                        "        _removeWhitelister(account);",
                        "    }",
                        "    function onlyWhitelisterMock() public view onlyWhitelister {",
                        "    }",
                        "    function _removeWhitelister(address account) internal {",
                        "        super._removeWhitelister(account);",
                        "    }",
                        "}"
                    ],
                    "del": []
                }
            }
        ],
        " * `SafeMath` now also supports signed integers (`int256`). ([#1559](https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1559))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1559": {
                    "add": [
                        "    int256 constant private INT256_MIN = -2**255;",
                        "    * @dev Multiplies two unsigned integers, reverts on overflow.",
                        "    * @dev Multiplies two signed integers, reverts on overflow.",
                        "    */",
                        "    function mul(int256 a, int256 b) internal pure returns (int256) {",
                        "        if (a == 0) {",
                        "            return 0;",
                        "        }",
                        "        int256 c = a * b;",
                        "        require(c / a == b);",
                        "        return c;",
                        "    }",
                        "    /**",
                        "    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.",
                        "    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.",
                        "    */",
                        "    function div(int256 a, int256 b) internal pure returns (int256) {",
                        "        int256 c = a / b;",
                        "        return c;",
                        "    }",
                        "    /**",
                        "    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).",
                        "    * @dev Subtracts two signed integers, reverts on overflow.",
                        "    */",
                        "    function sub(int256 a, int256 b) internal pure returns (int256) {",
                        "        int256 c = a - b;",
                        "        require((b >= 0 && c <= a) || (b < 0 && c > a));",
                        "        return c;",
                        "    }",
                        "    /**",
                        "    * @dev Adds two unsigned integers, reverts on overflow.",
                        "    * @dev Adds two signed integers, reverts on overflow.",
                        "    */",
                        "    function add(int256 a, int256 b) internal pure returns (int256) {",
                        "        int256 c = a + b;",
                        "        require((b >= 0 && c >= a) || (b < 0 && c < a));",
                        "        return c;",
                        "    }",
                        "    /**",
                        "    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),",
                        "    function mulUints(uint256 a, uint256 b) public pure returns (uint256) {",
                        "    function mulInts(int256 a, int256 b) public pure returns (int256) {",
                        "        return SafeMath.mul(a, b);",
                        "    }",
                        "    function divUints(uint256 a, uint256 b) public pure returns (uint256) {",
                        "        return SafeMath.div(a, b);",
                        "    }",
                        "    function divInts(int256 a, int256 b) public pure returns (int256) {",
                        "    function subUints(uint256 a, uint256 b) public pure returns (uint256) {",
                        "        return SafeMath.sub(a, b);",
                        "    }",
                        "    function subInts(int256 a, int256 b) public pure returns (int256) {",
                        "    function addUints(uint256 a, uint256 b) public pure returns (uint256) {",
                        "        return SafeMath.add(a, b);",
                        "    }",
                        "    function addInts(int256 a, int256 b) public pure returns (int256) {",
                        "    function modUints(uint256 a, uint256 b) public pure returns (uint256) {"
                    ],
                    "del": [
                        "    * @dev Multiplies two numbers, reverts on overflow.",
                        "    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.",
                        "    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).",
                        "    * @dev Adds two numbers, reverts on overflow.",
                        "    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),",
                        "    function mul(uint256 a, uint256 b) public pure returns (uint256) {",
                        "    function div(uint256 a, uint256 b) public pure returns (uint256) {",
                        "    function sub(uint256 a, uint256 b) public pure returns (uint256) {",
                        "    function add(uint256 a, uint256 b) public pure returns (uint256) {",
                        "    function mod(uint256 a, uint256 b) public pure returns (uint256) {"
                    ]
                }
            }
        ],
        " * `ERC20` and `ERC721` are now more gas efficient due to removed redundant `SSTORE`s and `require`s. ([#1409](https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1409) and [#1549](https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1549))\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1409": {
                    "add": [],
                    "del": [
                        "    require(value <= _allowed[from][msg.sender]);",
                        "    require(value <= _balances[from]);",
                        "    require(value <= _balances[account]);"
                    ]
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1549": {
                    "add": [
                        " * checking token existence, removal of a token from an address",
                        "    function burn(address owner, uint256 tokenId) public {",
                        "        _burn(owner, tokenId);",
                        "    }",
                        "        require(!_exists(tokenId));",
                        "        _tokenOwner[tokenId] = to;",
                        "        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);",
                        "        require(ownerOf(tokenId) == owner);",
                        "        _ownedTokensCount[owner] = _ownedTokensCount[owner].sub(1);",
                        "        _tokenOwner[tokenId] = address(0);",
                        "    ",
                        "        _addTokenToOwnerEnumeration(to, tokenId);",
                        "        _addTokenToAllTokensEnumeration(tokenId);",
                        "        _removeTokenFromOwnerEnumeration(owner, tokenId);",
                        "        _ownedTokensIndex[tokenId] = 0;",
                        "        _removeTokenFromAllTokensEnumeration(tokenId);",
                        "        _ownedTokensIndex[tokenId] = _ownedTokens[to].length;",
                        "        _ownedTokens[to].push(tokenId);",
                        "    }",
                        "    /**",
                        "     * @dev Private function to add a token to this extension's token tracking data structures.",
                        "     * @param tokenId uint256 ID of the token to be added to the tokens list",
                        "     */",
                        "    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {",
                        "        _allTokensIndex[tokenId] = _allTokens.length;",
                        "        _allTokens.push(tokenId);",
                        "        if (tokenIndex != lastTokenIndex) {",
                        "            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];",
                        "        }",
                        "    }",
                        "    /**",
                        "     * @dev Private function to remove a token from this extension's token tracking data structures.",
                        "     * This has O(1) time complexity, but alters the order of the _allTokens array.",
                        "     * @param tokenId uint256 ID of the token to be removed from the tokens list",
                        "     */",
                        "    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {",
                        "        uint256 lastTokenIndex = _allTokens.length.sub(1);",
                        "        uint256 tokenIndex = _allTokensIndex[tokenId];",
                        "        uint256 lastTokenId = _allTokens[lastTokenIndex];",
                        "        _allTokens.length--;",
                        "        _allTokensIndex[tokenId] = 0;"
                    ],
                    "del": [
                        " * checking token existence, removal of a token from an address ",
                        "    function removeTokenFrom(address from, uint256 tokenId) public {",
                        "        _removeTokenFrom(from, tokenId);",
                        "    }",
                        "        _addTokenTo(to, tokenId);",
                        "        _removeTokenFrom(owner, tokenId);",
                        "    /**",
                        "     * @dev Internal function to add a token ID to the list of a given address",
                        "     * Note that this function is left internal to make ERC721Enumerable possible, but is not",
                        "     * intended to be called by custom derived contracts: in particular, it emits no Transfer event.",
                        "     * @param to address representing the new owner of the given token ID",
                        "     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address",
                        "     */",
                        "    function _addTokenTo(address to, uint256 tokenId) internal {",
                        "        require(_tokenOwner[tokenId] == address(0));",
                        "        _tokenOwner[tokenId] = to;",
                        "        _ownedTokensCount[to] = _ownedTokensCount[to].add(1);",
                        "    }",
                        "    /**",
                        "     * @dev Internal function to remove a token ID from the list of a given address",
                        "     * Note that this function is left internal to make ERC721Enumerable possible, but is not",
                        "     * intended to be called by custom derived contracts: in particular, it emits no Transfer event,",
                        "     * and doesn't clear approvals.",
                        "     * @param from address representing the previous owner of the given token ID",
                        "     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address",
                        "     */",
                        "    function _removeTokenFrom(address from, uint256 tokenId) internal {",
                        "        require(ownerOf(tokenId) == from);",
                        "        _ownedTokensCount[from] = _ownedTokensCount[from].sub(1);",
                        "        _tokenOwner[tokenId] = address(0);",
                        "    }",
                        "    /**",
                        "     * @dev Internal function to add a token ID to the list of a given address",
                        "     * This function is internal due to language limitations, see the note in ERC721.sol.",
                        "     * It is not intended to be called by custom derived contracts: in particular, it emits no Transfer event.",
                        "     * @param to address representing the new owner of the given token ID",
                        "     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address",
                        "     */",
                        "    function _addTokenTo(address to, uint256 tokenId) internal {",
                        "        super._addTokenTo(to, tokenId);",
                        "        _addTokenToOwnerEnumeration(to, tokenId);",
                        "    }",
                        "    /**",
                        "     * @dev Internal function to remove a token ID from the list of a given address",
                        "     * This function is internal due to language limitations, see the note in ERC721.sol.",
                        "     * It is not intended to be called by custom derived contracts: in particular, it emits no Transfer event,",
                        "     * and doesn't clear approvals.",
                        "     * @param from address representing the previous owner of the given token ID",
                        "     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address",
                        "     */",
                        "    function _removeTokenFrom(address from, uint256 tokenId) internal {",
                        "        super._removeTokenFrom(from, tokenId);",
                        "        _removeTokenFromOwnerEnumeration(from, tokenId);",
                        "        _ownedTokensIndex[tokenId] = 0;",
                        "    }",
                        "        _allTokensIndex[tokenId] = _allTokens.length;",
                        "        _allTokens.push(tokenId);",
                        "        uint256 tokenIndex = _allTokensIndex[tokenId];",
                        "        uint256 lastTokenIndex = _allTokens.length.sub(1);",
                        "        uint256 lastToken = _allTokens[lastTokenIndex];",
                        "        _allTokens[tokenIndex] = lastToken;",
                        "        _allTokens[lastTokenIndex] = 0;",
                        "        _allTokens.length--;",
                        "        _allTokensIndex[tokenId] = 0;",
                        "        _allTokensIndex[lastToken] = tokenIndex;",
                        "        uint256 newOwnedTokensLength = _ownedTokens[to].push(tokenId);",
                        "        _ownedTokensIndex[tokenId] = newOwnedTokensLength - 1;",
                        "        uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];"
                    ]
                }
            }
        ]
    },
    "2.0.0": {
        "The awesome [LevelK](https://www.levelk.io/) team audited our 2.0.0 Release Candidate and they found some severe issues and suggested many improvements. We fixed almost all the issues and notes they reported, leaving only a few minor details for 2.1.0. Check out the [LevelK Audit - OpenZeppelin 2.0 project](https://github.com/OpenZeppelin/openzeppelin-solidity/projects/2) for all the details.\r": [
            "https://github.com/OpenZeppelin/openzeppelin-solidity/projects/2"
        ],
        "https://github.com/OpenZeppelin/openzeppelin-solidity/compare/v1.12.0...v2.0.0\r": [],
        "- `Ownable` contracts have moved to role based access. (#1291, #1302, #1303)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/129": {
                    "add": [],
                    "del": []
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/130": {
                    "add": [],
                    "del": []
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/130": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- All state variables are now `private`, which means that derived contracts cannot access them directly, but have to use getters. This is to increase encapsulation, to be able to reason better about the code. (#1197, #1265, #1267, #1269, #1270, #1268, #1281)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/119": {
                    "add": [
                        "contract DayLimit {",
                        "  function _setDailyLimit(uint _newLimit) internal {",
                        "  function _resetSpentToday() internal {",
                        "  function underLimit(uint _value) internal returns (bool) {",
                        "  function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {",
                        "    _setDailyLimit(_newLimit);",
                        "  }",
                        "  function resetSpentToday() onlymanyowners(sha3(msg.data)) external {",
                        "    _resetSpentToday();",
                        "  }",
                        "  function DayLimitMock(uint _value) DayLimit(_value) {",
                        "  function setDailyLimit(uint _newLimit) external {",
                        "    _setDailyLimit(_newLimit);",
                        "  }",
                        "  function resetSpentToday() external {",
                        "    _resetSpentToday();",
                        "  }"
                    ],
                    "del": [
                        "contract DayLimit is Shareable {",
                        "  function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {",
                        "  function resetSpentToday() onlymanyowners(sha3(msg.data)) external {",
                        "  function underLimit(uint _value) internal onlyOwner returns (bool) {",
                        "  function DayLimitMock(uint _value, address[] _owners, uint _required) DayLimit(_value) Shareable(_owners, _required) {"
                    ]
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/126": {
                    "add": [],
                    "del": []
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/126": {
                    "add": [],
                    "del": []
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/126": {
                    "add": [],
                    "del": []
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/127": {
                    "add": [],
                    "del": []
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/126": {
                    "add": [],
                    "del": []
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/128": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Changed `SafeMath` to use `require` instead of `assert`. (#1187, #1120, interesting discussion!)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/118": {
                    "add": [
                        "\tfunction bid() payable {",
                        "  function bid() external payable {",
                        "  function bid() external payable {",
                        "  function bid() external payable stopInEmergency {"
                    ],
                    "del": [
                        "\tfunction bid() {",
                        "  function bid() external {",
                        "  function bid() external {",
                        "  function bid() external stopInEmergency {"
                    ]
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/112": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Removed restriction on who can release funds in `PullPayments`, `PaymentSplitter`, `PostDeliveryCrowdsale`, `RefundableCrowdsale`. (#1275)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/127": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Optimized `ReentrancyMutex` gas usage. (#1155)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/115": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Made `ERC721.exists` internal. (#1193)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/119": {
                    "add": [
                        "contract DayLimit {",
                        "  function _setDailyLimit(uint _newLimit) internal {",
                        "  function _resetSpentToday() internal {",
                        "  function underLimit(uint _value) internal returns (bool) {",
                        "  function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {",
                        "    _setDailyLimit(_newLimit);",
                        "  }",
                        "  function resetSpentToday() onlymanyowners(sha3(msg.data)) external {",
                        "    _resetSpentToday();",
                        "  }",
                        "  function DayLimitMock(uint _value) DayLimit(_value) {",
                        "  function setDailyLimit(uint _newLimit) external {",
                        "    _setDailyLimit(_newLimit);",
                        "  }",
                        "  function resetSpentToday() external {",
                        "    _resetSpentToday();",
                        "  }"
                    ],
                    "del": [
                        "contract DayLimit is Shareable {",
                        "  function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {",
                        "  function resetSpentToday() onlymanyowners(sha3(msg.data)) external {",
                        "  function underLimit(uint _value) internal onlyOwner returns (bool) {",
                        "  function DayLimitMock(uint _value, address[] _owners, uint _required) DayLimit(_value) Shareable(_owners, _required) {"
                    ]
                }
            }
        ],
        "- Changed preconditions on `PaymentSplitter` constructor arguments. (#1131)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/113": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Fixed `ERC721.getApproved` to be in compliance with spec. (#1256)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/125": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Renamed `ERC20.decreaseApproval` to  `decreaseAllowance`, and changed its semantics slightly to be more secure. (#1293)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/129": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Moved `ReentrancyGuard`, and `Address` to a `utils/` subdirectory. (#1253)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/125": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Removed `Math.min64` and `Math.max64`, left only the `uint256` variants. (#1156)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/115": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Removed `Mint` and `Burn` events from `ERC20Mintable` and `ERC20Burnable`. (#1305)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/130": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Removed a few contracts that we thought were not generally secure enough: `LimitBalance`, `HasNoEther`, `HasNoTokens`, `HasNoContracts`, `NoOwner`, `Destructible`, `TokenDestructible`, `CanReclaimToken`. (#1253, #1254, #1306)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/125": {
                    "add": [],
                    "del": []
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/125": {
                    "add": [],
                    "del": []
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/130": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Removed extensions of `Owable`: `Claimable`, `DelayedClaimable`, `Heritable`. (#1274)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/127": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Improved the `OwnershipTransfer` event and removed `OwnershipRenounced`. (#1397)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/139": {
                    "add": [],
                    "del": [
                        "    if (balances[msg.sender] < _value) {",
                        "      throw;",
                        "    } "
                    ]
                }
            }
        ],
        "- Removed the `BreakInvariantBounty` contract because of a front-running issue. (#1424)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/142": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Improved encapsulation on `ERC165` making the `_supportedInterfaces` map private. (#1379)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/137": {
                    "add": [
                        " * Pausable",
                        "contract Pausable is Ownable {",
                        "contract PausableMock is Pausable {",
                        "  function PausableMock() {"
                    ],
                    "del": [
                        " * Stoppable",
                        "contract Stoppable is Ownable {",
                        "contract StoppableMock is Stoppable {",
                        "  function StoppableMock() {"
                    ]
                }
            }
        ],
        "- Made private the `TokenVesting` functions `_releasableAmount` and `_vestedAmount`. (#1427)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/142": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Made internal the constructors of contracts that should only be used inherited from others. (#1433, #1439)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/143": {
                    "add": [],
                    "del": []
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/143": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Improved the `SafeERC20` allowance handling. (#1407)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/140": {
                    "add": [
                        "  function safeDiv(uint a, uint b) internal returns (uint) {",
                        "    assert(b > 0);",
                        "    uint c = a / b;",
                        "    assert(a == b * c + a % b);",
                        "    return c;",
                        "  }",
                        "  function max64(uint64 a, uint64 b) internal constant returns (uint64) {",
                        "    return a >= b ? a : b;",
                        "  }",
                        "  function min64(uint64 a, uint64 b) internal constant returns (uint64) {",
                        "    return a < b ? a : b;",
                        "  }",
                        "  function max256(uint256 a, uint256 b) internal constant returns (uint256) {",
                        "    return a >= b ? a : b;",
                        "  }",
                        "  function min256(uint256 a, uint256 b) internal constant returns (uint256) {",
                        "    return a < b ? a : b;",
                        "  }",
                        "contract VestedTokenMock is VestedToken {",
                        "  function VestedTokenMock(address initialAccount, uint initialBalance) {",
                        "    balances[initialAccount] = initialBalance;",
                        "    totalSupply = initialBalance;",
                        "  }",
                        "}",
                        "contract VestedToken is StandardToken {",
                        "  struct TokenGrant {",
                        "    address granter;",
                        "    uint256 value;",
                        "    uint64 cliff;",
                        "    uint64 vesting;",
                        "    uint64 start;",
                        "  }",
                        "  mapping (address => TokenGrant[]) public grants;",
                        "  function grantVestedTokens(address _to, uint256 _value, uint64 _start, uint64 _cliff, uint64 _vesting) {",
                        "    if (_cliff < _start) throw;",
                        "    if (_vesting < _start) throw;",
                        "    if (_vesting < _cliff) throw;",
                        "    TokenGrant memory grant = TokenGrant({start: _start, value: _value, cliff: _cliff, vesting: _vesting, granter: msg.sender});",
                        "    grants[_to].push(grant);",
                        "    transfer(_to, _value);",
                        "  }",
                        "  function revokeTokenGrant(address _holder, uint _grantId) {",
                        "    TokenGrant grant = grants[_holder][_grantId];",
                        "    if (grant.granter != msg.sender) throw;",
                        "    uint256 nonVested = nonVestedTokens(grant, uint64(now));",
                        "    delete grants[_holder][_grantId];",
                        "    grants[_holder][_grantId] = grants[_holder][grants[_holder].length - 1];",
                        "    grants[_holder].length -= 1;",
                        "    balances[msg.sender] = safeAdd(balances[msg.sender], nonVested);",
                        "    balances[_holder] = safeSub(balances[_holder], nonVested);",
                        "    Transfer(_holder, msg.sender, nonVested);",
                        "  }",
                        "  function tokenGrantsCount(address _holder) constant returns (uint index) {",
                        "    return grants[_holder].length;",
                        "  }",
                        "  function tokenGrant(address _holder, uint _grantId) constant returns (address granter, uint256 value, uint256 vested, uint64 start, uint64 cliff, uint64 vesting) {",
                        "    TokenGrant grant = grants[_holder][_grantId];",
                        "    granter = grant.granter;",
                        "    value = grant.value;",
                        "    start = grant.start;",
                        "    cliff = grant.cliff;",
                        "    vesting = grant.vesting;",
                        "    vested = vestedTokens(grant, uint64(now));",
                        "  }",
                        "  function vestedTokens(TokenGrant grant, uint64 time) private constant returns (uint256) {",
                        "    return calculateVestedTokens(grant.value, uint256(time), uint256(grant.start), uint256(grant.cliff), uint256(grant.vesting));",
                        "  }",
                        "  function calculateVestedTokens(uint256 tokens, uint256 time, uint256 start, uint256 cliff, uint256 vesting) constant returns (uint256 vestedTokens) {",
                        "    if (time < cliff) return 0;",
                        "    if (time > vesting) return tokens;",
                        "    uint256 cliffTokens = safeDiv(safeMul(tokens, safeSub(cliff, start)), safeSub(vesting, start));",
                        "    vestedTokens = cliffTokens;",
                        "    uint256 vestingTokens = safeSub(tokens, cliffTokens);",
                        "    vestedTokens = safeAdd(vestedTokens, safeDiv(safeMul(vestingTokens, safeSub(time, cliff)), safeSub(vesting, start)));",
                        "  }",
                        "  function nonVestedTokens(TokenGrant grant, uint64 time) private constant returns (uint256) {",
                        "    return safeSub(grant.value, vestedTokens(grant, time));",
                        "  }",
                        "  function lastTokenIsTransferableDate(address holder) constant public returns (uint64 date) {",
                        "    date = uint64(now);",
                        "    uint256 grantIndex = grants[holder].length;",
                        "    for (uint256 i = 0; i < grantIndex; i++) {",
                        "      date = max64(grants[holder][i].vesting, date);",
                        "    }",
                        "  }",
                        "  function transferableTokens(address holder, uint64 time) constant public returns (uint256 nonVested) {",
                        "    uint256 grantIndex = grants[holder].length;",
                        "    for (uint256 i = 0; i < grantIndex; i++) {",
                        "      nonVested = safeAdd(nonVested, nonVestedTokens(grants[holder][i], time));",
                        "    }",
                        "    return safeSub(balances[holder], nonVested);",
                        "  }",
                        "  function transfer(address _to, uint _value) returns (bool success){",
                        "    if (_value > transferableTokens(msg.sender, uint64(now))) throw;",
                        "    return super.transfer(_to, _value);",
                        "  }",
                        "}"
                    ],
                    "del": []
                }
            }
        ],
        "- Made `getCurrentRate` from `IncreasingPriceCrowdsale` return 0 when the crowdsale is not open. (#1442)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/144": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Fixed a reentrancy issue on `FinalizableCrowdsale`. (#1447)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/144": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Fixed how allowance crowdsale checks remaining tokens. (#1449)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/144": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Added the nonReentrant safeguard for buyTokens in the Crowdsale contract. (#1438)": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/143": {
                    "add": [],
                    "del": []
                }
            }
        ]
    },
    "2.0.0-rc.4": {
        "In particular, we decided to remove the `BreakInvariantBounty` contract because of a front-running issue (#1333) that will require a heavy redesign, we added the `nonReentrant` safeguard for `buyTokens` in the `Crowdsale` contract (#1438), we improved the SafeERC20 allowance handling(#1407),  on `TimedCrowdsales` the closing time now must be strictly after the opening time (#1440), we fixed how `AllowanceCrowdsale` checks remaining tokens (#1449), we fixed a reentrancy issue on `FinalizableCrowdsale` (#1447), and improved the `ERC721` implementation (#1450).\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/133": {
                    "add": [],
                    "del": []
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/143": {
                    "add": [],
                    "del": []
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/140": {
                    "add": [
                        "  function safeDiv(uint a, uint b) internal returns (uint) {",
                        "    assert(b > 0);",
                        "    uint c = a / b;",
                        "    assert(a == b * c + a % b);",
                        "    return c;",
                        "  }",
                        "  function max64(uint64 a, uint64 b) internal constant returns (uint64) {",
                        "    return a >= b ? a : b;",
                        "  }",
                        "  function min64(uint64 a, uint64 b) internal constant returns (uint64) {",
                        "    return a < b ? a : b;",
                        "  }",
                        "  function max256(uint256 a, uint256 b) internal constant returns (uint256) {",
                        "    return a >= b ? a : b;",
                        "  }",
                        "  function min256(uint256 a, uint256 b) internal constant returns (uint256) {",
                        "    return a < b ? a : b;",
                        "  }",
                        "contract VestedTokenMock is VestedToken {",
                        "  function VestedTokenMock(address initialAccount, uint initialBalance) {",
                        "    balances[initialAccount] = initialBalance;",
                        "    totalSupply = initialBalance;",
                        "  }",
                        "}",
                        "contract VestedToken is StandardToken {",
                        "  struct TokenGrant {",
                        "    address granter;",
                        "    uint256 value;",
                        "    uint64 cliff;",
                        "    uint64 vesting;",
                        "    uint64 start;",
                        "  }",
                        "  mapping (address => TokenGrant[]) public grants;",
                        "  function grantVestedTokens(address _to, uint256 _value, uint64 _start, uint64 _cliff, uint64 _vesting) {",
                        "    if (_cliff < _start) throw;",
                        "    if (_vesting < _start) throw;",
                        "    if (_vesting < _cliff) throw;",
                        "    TokenGrant memory grant = TokenGrant({start: _start, value: _value, cliff: _cliff, vesting: _vesting, granter: msg.sender});",
                        "    grants[_to].push(grant);",
                        "    transfer(_to, _value);",
                        "  }",
                        "  function revokeTokenGrant(address _holder, uint _grantId) {",
                        "    TokenGrant grant = grants[_holder][_grantId];",
                        "    if (grant.granter != msg.sender) throw;",
                        "    uint256 nonVested = nonVestedTokens(grant, uint64(now));",
                        "    delete grants[_holder][_grantId];",
                        "    grants[_holder][_grantId] = grants[_holder][grants[_holder].length - 1];",
                        "    grants[_holder].length -= 1;",
                        "    balances[msg.sender] = safeAdd(balances[msg.sender], nonVested);",
                        "    balances[_holder] = safeSub(balances[_holder], nonVested);",
                        "    Transfer(_holder, msg.sender, nonVested);",
                        "  }",
                        "  function tokenGrantsCount(address _holder) constant returns (uint index) {",
                        "    return grants[_holder].length;",
                        "  }",
                        "  function tokenGrant(address _holder, uint _grantId) constant returns (address granter, uint256 value, uint256 vested, uint64 start, uint64 cliff, uint64 vesting) {",
                        "    TokenGrant grant = grants[_holder][_grantId];",
                        "    granter = grant.granter;",
                        "    value = grant.value;",
                        "    start = grant.start;",
                        "    cliff = grant.cliff;",
                        "    vesting = grant.vesting;",
                        "    vested = vestedTokens(grant, uint64(now));",
                        "  }",
                        "  function vestedTokens(TokenGrant grant, uint64 time) private constant returns (uint256) {",
                        "    return calculateVestedTokens(grant.value, uint256(time), uint256(grant.start), uint256(grant.cliff), uint256(grant.vesting));",
                        "  }",
                        "  function calculateVestedTokens(uint256 tokens, uint256 time, uint256 start, uint256 cliff, uint256 vesting) constant returns (uint256 vestedTokens) {",
                        "    if (time < cliff) return 0;",
                        "    if (time > vesting) return tokens;",
                        "    uint256 cliffTokens = safeDiv(safeMul(tokens, safeSub(cliff, start)), safeSub(vesting, start));",
                        "    vestedTokens = cliffTokens;",
                        "    uint256 vestingTokens = safeSub(tokens, cliffTokens);",
                        "    vestedTokens = safeAdd(vestedTokens, safeDiv(safeMul(vestingTokens, safeSub(time, cliff)), safeSub(vesting, start)));",
                        "  }",
                        "  function nonVestedTokens(TokenGrant grant, uint64 time) private constant returns (uint256) {",
                        "    return safeSub(grant.value, vestedTokens(grant, time));",
                        "  }",
                        "  function lastTokenIsTransferableDate(address holder) constant public returns (uint64 date) {",
                        "    date = uint64(now);",
                        "    uint256 grantIndex = grants[holder].length;",
                        "    for (uint256 i = 0; i < grantIndex; i++) {",
                        "      date = max64(grants[holder][i].vesting, date);",
                        "    }",
                        "  }",
                        "  function transferableTokens(address holder, uint64 time) constant public returns (uint256 nonVested) {",
                        "    uint256 grantIndex = grants[holder].length;",
                        "    for (uint256 i = 0; i < grantIndex; i++) {",
                        "      nonVested = safeAdd(nonVested, nonVestedTokens(grants[holder][i], time));",
                        "    }",
                        "    return safeSub(balances[holder], nonVested);",
                        "  }",
                        "  function transfer(address _to, uint _value) returns (bool success){",
                        "    if (_value > transferableTokens(msg.sender, uint64(now))) throw;",
                        "    return super.transfer(_to, _value);",
                        "  }",
                        "}"
                    ],
                    "del": []
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/144": {
                    "add": [],
                    "del": []
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/144": {
                    "add": [],
                    "del": []
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/144": {
                    "add": [],
                    "del": []
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/145": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "https://github.com/OpenZeppelin/openzeppelin-solidity/compare/v2.0.0-rc.3...v2.0.0-rc.4": []
    },
    "2.0.0-rc.3": {
        "**Make sure to read the release notes for the [first](https://github.com/OpenZeppelin/openzeppelin-solidity/releases/tag/v2.0.0-rc.1) and [second](https://github.com/OpenZeppelin/openzeppelin-solidity/releases/tag/v2.0.0-rc.2) release candidates!**\r": [
            "https://github.com/OpenZeppelin/openzeppelin-solidity/releases/tag/v2.0.0-rc.1",
            "https://github.com/OpenZeppelin/openzeppelin-solidity/releases/tag/v2.0.0-rc.2"
        ],
        "https://github.com/OpenZeppelin/openzeppelin-solidity/compare/v2.0.0-rc.2...v2.0.0-rc.3": []
    },
    "2.0.0-rc.2": {
        "https://github.com/OpenZeppelin/openzeppelin-solidity/compare/v2.0.0-rc.1...v2.0.0-rc.2": []
    },
    "2.0.0-rc.1": {
        "https://github.com/OpenZeppelin/openzeppelin-solidity/compare/v1.12.0...v2.0.0-rc.1\r": [],
        "- `Ownable` contracts have moved to role based access. (#1291, #1302, #1303)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/129": {
                    "add": [],
                    "del": []
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/130": {
                    "add": [],
                    "del": []
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/130": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- All state variables are now `private`, which means that derived contracts cannot access them directly, but have to use getters. This is to increase encapsulation, to be able to reason better about the code. (#1197, #1265, #1267, #1269, #1270, #1268, #1281)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/119": {
                    "add": [
                        "contract DayLimit {",
                        "  function _setDailyLimit(uint _newLimit) internal {",
                        "  function _resetSpentToday() internal {",
                        "  function underLimit(uint _value) internal returns (bool) {",
                        "  function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {",
                        "    _setDailyLimit(_newLimit);",
                        "  }",
                        "  function resetSpentToday() onlymanyowners(sha3(msg.data)) external {",
                        "    _resetSpentToday();",
                        "  }",
                        "  function DayLimitMock(uint _value) DayLimit(_value) {",
                        "  function setDailyLimit(uint _newLimit) external {",
                        "    _setDailyLimit(_newLimit);",
                        "  }",
                        "  function resetSpentToday() external {",
                        "    _resetSpentToday();",
                        "  }"
                    ],
                    "del": [
                        "contract DayLimit is Shareable {",
                        "  function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {",
                        "  function resetSpentToday() onlymanyowners(sha3(msg.data)) external {",
                        "  function underLimit(uint _value) internal onlyOwner returns (bool) {",
                        "  function DayLimitMock(uint _value, address[] _owners, uint _required) DayLimit(_value) Shareable(_owners, _required) {"
                    ]
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/126": {
                    "add": [],
                    "del": []
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/126": {
                    "add": [],
                    "del": []
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/126": {
                    "add": [],
                    "del": []
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/127": {
                    "add": [],
                    "del": []
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/126": {
                    "add": [],
                    "del": []
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/128": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Changed `SafeMath` to use `require` instead of `assert`. (#1187, #1120, interesting discussion!)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/118": {
                    "add": [
                        "\tfunction bid() payable {",
                        "  function bid() external payable {",
                        "  function bid() external payable {",
                        "  function bid() external payable stopInEmergency {"
                    ],
                    "del": [
                        "\tfunction bid() {",
                        "  function bid() external {",
                        "  function bid() external {",
                        "  function bid() external stopInEmergency {"
                    ]
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/112": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Removed restriction on who can release funds in `PullPayments`, `SplitPayment`, `PostDeliveryCrowdsale`, `RefundableCrowdsale`. (#1275)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/127": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Optimized `ReentrancyMutex` gas usage. (#1155)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/115": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Made `ERC721.exists` internal. (#1193)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/119": {
                    "add": [
                        "contract DayLimit {",
                        "  function _setDailyLimit(uint _newLimit) internal {",
                        "  function _resetSpentToday() internal {",
                        "  function underLimit(uint _value) internal returns (bool) {",
                        "  function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {",
                        "    _setDailyLimit(_newLimit);",
                        "  }",
                        "  function resetSpentToday() onlymanyowners(sha3(msg.data)) external {",
                        "    _resetSpentToday();",
                        "  }",
                        "  function DayLimitMock(uint _value) DayLimit(_value) {",
                        "  function setDailyLimit(uint _newLimit) external {",
                        "    _setDailyLimit(_newLimit);",
                        "  }",
                        "  function resetSpentToday() external {",
                        "    _resetSpentToday();",
                        "  }"
                    ],
                    "del": [
                        "contract DayLimit is Shareable {",
                        "  function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {",
                        "  function resetSpentToday() onlymanyowners(sha3(msg.data)) external {",
                        "  function underLimit(uint _value) internal onlyOwner returns (bool) {",
                        "  function DayLimitMock(uint _value, address[] _owners, uint _required) DayLimit(_value) Shareable(_owners, _required) {"
                    ]
                }
            }
        ],
        "- Changed preconditions on `SplitPayment` constructor arguments. (#1131)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/113": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Fixed `ERC721.getApproved` to be in compliance with spec. (#1256)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/125": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Renamed `ERC20.decreaseApproval` to  `decreaseAllowance`, and changed its semantics slightly to be more secure. (#1293)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/129": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Removed `Math.min64` and `Math.max64`, left only the `uint256` variants. (#1156)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/115": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Removed `Mint` and `Burn` events from `ERC20Mintable` and `ERC20Burnable`. (#1305)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/130": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Removed a few contracts that we thought were not generally secure enough: `LimitBalance`, `HasNoEther`, `HasNoTokens`, `HasNoContracts`, `NoOwner`, `Destructible`, `TokenDestructible`, `CanReclaimToken`. (#1253, #1254, #1306)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/125": {
                    "add": [],
                    "del": []
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/125": {
                    "add": [],
                    "del": []
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/130": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Removed extensions of `Owable`: `Claimable`, `DelayedClaimable`, `Heritable`. (#1274)": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/127": {
                    "add": [],
                    "del": []
                }
            }
        ]
    },
    "1.12.0": {
        "https://github.com/OpenZeppelin/openzeppelin-solidity/compare/v1.11.0...v1.12.0\r": [],
        "- Moved ERC165 interface IDs to interface contracts. (#1070)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/107": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Fixed an inheritance order that was causing some contracts to fail linearization. (#1128)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/112": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Fix `assertRevert` test helper. (#1123)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/112": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Fixes for Solidity 0.5.0. (#1080, #1134)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/108": {
                    "add": [],
                    "del": []
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/113": {
                    "add": [],
                    "del": []
                }
            }
        ]
    },
    "1.12.0-rc.2": {
        "Includes https://github.com/OpenZeppelin/openzeppelin-solidity/pull/1128, which fixes the inheritance order of two crowdsale contracts that was preventing some feature combinations.\r": []
    },
    "1.12.0-rc.1": {},
    "1.11.0": {
        "- :shield: Fixed unchecked token transfer in `Crowdsale`. (#1006)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/100": {
                    "add": [
                        " * Based on https://github.com/ethereum/dapp-bin/blob/master/wallet/wallet.sol",
                        "  function isOwner(address _addr) constant returns (bool) {",
                        "contract ShareableMock is Shareable {",
                        "  uint public count = 0;",
                        "  function ShareableMock(address[] _owners, uint _required) Shareable(_owners, _required) {",
                        "  }",
                        "  function increaseCount(bytes32 action) onlymanyowners(action) {",
                        "    count = count + 1;",
                        "  }",
                        "}"
                    ],
                    "del": [
                        " * Based on https://github.com/ethereum/dapp-bin/blob/master/wallet/wallet.sol ",
                        "  function isOwner(address _addr) returns (bool) {"
                    ]
                }
            }
        ],
        "- :warning: We removed the implementation of ERC827 due to concerns about its security (#1044). The code was moved to [windingtree/erc827](https://github.com/windingtree/erc827).": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/104": {
                    "add": [],
                    "del": []
                }
            }
        ]
    },
    "1.11.0-rc.1": {},
    "1.10.0": {
        "- Added `renounceOwnership` to `Ownable` (https://github.com/OpenZeppelin/openzeppelin-solidity/pull/907)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-solidity/pull/907": {
                    "add": [
                        "  event OwnershipRenounced(address indexed previousOwner);",
                        "  /**",
                        "   * @dev Allows the current owner to relinquish control of the contract.",
                        "   */",
                        "  function renounceOwnership() public onlyOwner {",
                        "    emit OwnershipRenounced(owner);",
                        "    owner = address(0);",
                        "  }"
                    ],
                    "del": []
                }
            }
        ],
        "- Added `Superuser`, an extension of `Ownable` with an emergency mechanism (https://github.com/OpenZeppelin/openzeppelin-solidity/pull/952, https://github.com/OpenZeppelin/openzeppelin-solidity/pull/978)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-solidity/pull/952, https://github.com/OpenZeppelin/openzeppelin-solidity/pull/978": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Added an `Ownable` \"behavior\" to test that your ownable contracts do not break the semantics (https://github.com/OpenZeppelin/openzeppelin-solidity/pull/929)": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-solidity/pull/929": {
                    "add": [],
                    "del": []
                }
            }
        ]
    },
    "1.9.0": {
        "- :policewoman: Removed admin functionality from RBAC (#836)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/83": {
                    "add": [],
                    "del": []
                }
            }
        ]
    },
    "1.8.0": {
        "- \ud83d\udc68\u200d\ud83c\udfeb `ECRecovery` [`recover`](https://github.com/OpenZeppelin/zeppelin-solidity/blob/v1.8.0/contracts/ECRecovery.sol#L17) is now internal (#818)\r": [
            "https://github.com/OpenZeppelin/zeppelin-solidity/blob/v1.8.0/contracts/ECRecovery.sol#L17"
        ]
    },
    "1.7.0": {
        "https://github.com/OpenZeppelin/zeppelin-solidity/compare/v1.6.0...v1.7.0\r": [],
        "   - [`WhitelistedCrowdsale`](https://github.com/OpenZeppelin/zeppelin-solidity/blob/v1.7.0/contracts/crowdsale/validation/WhitelistedCrowdsale.sol)\r": [
            "https://github.com/OpenZeppelin/zeppelin-solidity/blob/v1.7.0/contracts/crowdsale/validation/WhitelistedCrowdsale.sol"
        ],
        "   - [`AllowanceCrowdsale`](https://github.com/OpenZeppelin/zeppelin-solidity/blob/v1.7.0/contracts/crowdsale/emission/AllowanceCrowdsale.sol)\r": [
            "https://github.com/OpenZeppelin/zeppelin-solidity/blob/v1.7.0/contracts/crowdsale/emission/AllowanceCrowdsale.sol"
        ],
        "- :bow_and_arrow: Move token creation outside of `Crowdsale` contract (https://github.com/OpenZeppelin/zeppelin-solidity/pull/690)\r": [
            {
                "https://github.com/OpenZeppelin/zeppelin-solidity/pull/690": {
                    "add": [
                        " * as they arrive. The contract requires a MintableToken that will be",
                        " * minted as contributions arrive, note that the crowdsale contract",
                        " * must be owner of the token in order to be able to mint it.",
                        "  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, MintableToken _token) public {",
                        "    require(_token != address(0));",
                        "    token = _token;",
                        "  function SampleCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, uint256 _goal, uint256 _cap, address _wallet, MintableToken _token) public",
                        "    Crowdsale(_startTime, _endTime, _rate, _wallet, _token)",
                        "    uint256 _cap,",
                        "    MintableToken _token",
                        "    Crowdsale(_startTime, _endTime, _rate, _wallet, _token)",
                        "    address _wallet,",
                        "    MintableToken _token",
                        "    Crowdsale(_startTime, _endTime, _rate, _wallet, _token)",
                        "    uint256 _goal,",
                        "    MintableToken _token",
                        "    Crowdsale(_startTime, _endTime, _rate, _wallet, _token)"
                    ],
                    "del": [
                        " * as they arrive.",
                        "  function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public {",
                        "    token = createTokenContract();",
                        "  function createTokenContract() internal returns (MintableToken) {",
                        "    return new MintableToken();",
                        "  }",
                        "  function SampleCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, uint256 _goal, uint256 _cap, address _wallet) public",
                        "    Crowdsale(_startTime, _endTime, _rate, _wallet)",
                        "  function createTokenContract() internal returns (MintableToken) {",
                        "    return new SampleCrowdsaleToken();",
                        "  }",
                        "    uint256 _cap",
                        "    Crowdsale(_startTime, _endTime, _rate, _wallet)",
                        "    address _wallet",
                        "    Crowdsale(_startTime, _endTime, _rate, _wallet)",
                        "    uint256 _goal",
                        "    Crowdsale(_startTime, _endTime, _rate, _wallet)"
                    ]
                }
            }
        ],
        "- :crown: `Heritable` improvements (https://github.com/OpenZeppelin/zeppelin-solidity/pull/702)\r": [
            {
                "https://github.com/OpenZeppelin/zeppelin-solidity/pull/702": {
                    "add": [
                        "  address private heir_;",
                        "  uint256 private heartbeatTimeout_;",
                        "  uint256 private timeOfDeath_;",
                        "    require(msg.sender == heir_);",
                        "    heir_ = newHeir;",
                        "  }",
                        "  /**",
                        "   * @dev Use these getter functions to access the internal variables in",
                        "   * an inherited contract.",
                        "   */",
                        "  function heir() public view returns(address) {",
                        "    return heir_;",
                        "  }",
                        "  function heartbeatTimeout() public view returns(uint256) {",
                        "    return heartbeatTimeout_;",
                        "  }",
                        "  ",
                        "  function timeOfDeath() public view returns(uint256) {",
                        "    return timeOfDeath_;",
                        "    heir_ = 0;",
                        "    OwnerProclaimedDead(owner, heir_, timeOfDeath_);",
                        "    timeOfDeath_ = block.timestamp;",
                        "    timeOfDeath_ = 0;",
                        "    require(block.timestamp >= timeOfDeath_ + heartbeatTimeout_);",
                        "    OwnershipTransferred(owner, heir_);",
                        "    HeirOwnershipClaimed(owner, heir_);",
                        "    owner = heir_;",
                        "    timeOfDeath_ = 0;",
                        "    heartbeatTimeout_ = newHeartbeatTimeout;",
                        "    return timeOfDeath_ == 0;"
                    ],
                    "del": [
                        "  address public heir;",
                        "  uint256 public heartbeatTimeout;",
                        "  uint256 public timeOfDeath;",
                        "    require(msg.sender == heir);",
                        "    heir = newHeir;",
                        "    heir = 0;",
                        "    OwnerProclaimedDead(owner, heir, timeOfDeath);",
                        "    timeOfDeath = now;",
                        "    timeOfDeath = 0;",
                        "    require(now >= timeOfDeath + heartbeatTimeout);",
                        "    OwnershipTransferred(owner, heir);",
                        "    HeirOwnershipClaimed(owner, heir);",
                        "    owner = heir;",
                        "    timeOfDeath = 0;",
                        "    heartbeatTimeout = newHeartbeatTimeout;",
                        "    return timeOfDeath == 0;"
                    ]
                }
            }
        ]
    },
    "1.6.0": {
        "[v1.5.0...v1.6.0](https://github.com/OpenZeppelin/zeppelin-solidity/compare/v1.5.0...v1.6.0)\r": [
            "https://github.com/OpenZeppelin/zeppelin-solidity/compare/v1.5.0...v1.6.0"
        ],
        "- \ud83c\udd95 Added [`ERC827`](https://github.com/OpenZeppelin/zeppelin-solidity/blob/v1.6.0/contracts/token/ERC827/ERC827Token.sol) token implementation provides `transfer`, `transferFrom` and `approve` methods which additionally perform a call to the recipients (#518)\r": [
            "https://github.com/OpenZeppelin/zeppelin-solidity/blob/v1.6.0/contracts/token/ERC827/ERC827Token.sol"
        ],
        "- \ud83c\udd95 Added [`Heritable`](https://github.com/OpenZeppelin/zeppelin-solidity/blob/v1.6.0/contracts/lifecycle/Heritable.sol), an extension of `Ownable` with a designated heir (#680)\r": [
            "https://github.com/OpenZeppelin/zeppelin-solidity/blob/v1.6.0/contracts/lifecycle/Heritable.sol"
        ]
    },
    "1.5.0": {},
    "1.4.0": {
        "- Made `MintableToken`'s `finishMinting` executable only once. (#505)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/50": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Removed deprecated `claim()` from `TokenTimelock`. (#469)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/46": {
                    "add": [],
                    "del": []
                }
            }
        ]
    },
    "1.3.0": {
        "- Removed `MultisigWallet` in favor of [gnosis/MultiSigWallet](https://github.com/gnosis/MultiSigWallet). (#328)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/32": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Removed the call to `finishMinting` in `FinalizableCrowdsale`. (#364)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/36": {
                    "add": [
                        " * This bounty will pay out if you can cause a {{name}}'s balance",
                        " * to be lower than its totalSupply, which would mean that it doesn't",
                        "    SimpleToken target = new {{name}}();",
                        "  function claim({{name}} target) {",
                        "    if (!target.checkInvariant()) {"
                    ],
                    "del": [
                        " * This bounty will pay out if you can cause a SimpleToken's balance",
                        " * to be lower than its totalSupply, which would mean that it doesn't ",
                        "    SimpleToken target = new SimpleToken();",
                        "  function claim(SimpleToken target) {",
                        "    if (target.totalSupply() == target.balance) {"
                    ]
                }
            }
        ],
        "- Made `approve` pausable in `PausableToken`. (#448)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/44": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Added the `SafeERC20` library for interaction with ERC20 tokens. (#413)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/41": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Added the `MerkleProof` library for merkle proof verification. (#260)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/26": {
                    "add": [
                        "contract Bounty is PullPayment {",
                        "    if (msg.sender == owner) _;",
                        "      _;",
                        " * PullPayment",
                        "contract PullPayment {",
                        "  modifier stopInEmergency { if (!stopped) _; }",
                        "  modifier onlyInEmergency { if (stopped) _; }",
                        "contract BadArrayUse is PullPayment {",
                        "contract GoodArrayUse is PullPayment {",
                        "contract PullPaymentBid is PullPayment {",
                        "contract PullPaymentExample is PullPayment {",
                        "contract StoppableBid is Stoppable, PullPayment {",
                        "    PullPayment() {}"
                    ],
                    "del": [
                        "contract Bounty is PullPaymentCapable {",
                        "    if (msg.sender == owner) _",
                        "      _",
                        " * PullPaymentCapable",
                        "contract PullPaymentCapable {",
                        "  modifier stopInEmergency { if (!stopped) _ }",
                        "  modifier onlyInEmergency { if (stopped) _ }",
                        "contract BadArrayUse is PullPaymentCapable {",
                        "contract GoodArrayUse is PullPaymentCapable {",
                        "contract PullPaymentBid is PullPaymentCapable {",
                        "contract PullPaymentCapableExample is PullPaymentCapable {",
                        "contract StoppableBid is Stoppable, PullPaymentCapable {",
                        "    PullPaymentCapable() {}"
                    ]
                }
            }
        ],
        "- Fixed some small issues in ERC20 compliance. (#345, #405, #446)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/34": {
                    "add": [
                        " * to be lower than its totalSupply, which would mean that it doesn't",
                        "contract Target {",
                        "  function checkInvariant() returns(bool);",
                        "}",
                        "contract BytecodeDeployer {",
                        "    function createFromAddress(address _addr) returns (address){",
                        "      return createFromBytecode(msg.value, getByteCode(_addr));",
                        "    }",
                        "    function getByteCode(address _addr) returns (bytes o_code) {",
                        "      assembly {",
                        "        let size := extcodesize(_addr)",
                        "        o_code := mload(0x40)",
                        "        mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))",
                        "        mstore(o_code, size)",
                        "        extcodecopy(_addr, add(o_code, 0x20), 0, size)",
                        "      }",
                        "    }",
                        "    function createFromBytecode(uint value, bytes bytecode) returns (address result) {",
                        "      assembly {",
                        "          let size := mload(bytecode)",
                        "          result := create(value, add(bytecode, 32), size)",
                        "      }",
                        "    }",
                        "}",
                        "contract Bounty is PullPayment, BytecodeDeployer {",
                        "  Target target;",
                        "  function createTarget(address targetAddress) returns(Target) {",
                        "    target = Target(createFromAddress(targetAddress));",
                        "  function checkInvariant() returns(bool){",
                        "    return target.checkInvariant();",
                        "  }",
                        "  function claim(Target target) {",
                        "    if (!target.checkInvariant()) {",
                        "contract InsecureTargetMock {",
                        "  function checkInvariant() returns(bool){",
                        "    return false;",
                        "  }",
                        "}",
                        "contract SecureTargetMock {",
                        "  function checkInvariant() returns(bool){",
                        "    return true;",
                        "  }",
                        "}"
                    ],
                    "del": [
                        " * to be lower than its totalSupply, which would mean that it doesn't ",
                        "contract Bounty is PullPayment {",
                        "  function createTarget() returns(SimpleToken) {",
                        "    SimpleToken target = new SimpleToken();",
                        "  function claim(SimpleToken target) {",
                        "    if (target.totalSupply() == target.balance) {"
                    ]
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/40": {
                    "add": [],
                    "del": []
                }
            },
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/44": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Fixed a bug in `transferFrom`. (#377)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/37": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Fixed `transferOwnership` to `revert` on failure instead of silently failing. (#323)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/32": {
                    "add": [],
                    "del": []
                }
            }
        ],
        "- Fixed a bug in `TokenTimelock`. (#430)\r": [
            {
                "https://github.com/OpenZeppelin/openzeppelin-contracts/pull/43": {
                    "add": [
                        "/*",
                        " * Bounty",
                        " * This bounty will pay out to a researcher if he/she breaks invariant logic of",
                        " * the contract you bet reward against.",
                        " */",
                        "contract Factory {",
                        "  function deployContract() returns (address);",
                        "}",
                        "contract Target {",
                        "  function checkInvariant() returns(bool);",
                        "}",
                        "contract Bounty is PullPayment, Killable {",
                        "  Target target;",
                        "  bool public claimed;",
                        "  address public factoryAddress;",
                        "  mapping(address => address) public researchers;",
                        "  event TargetCreated(address createdAddress);",
                        "  function() payable {",
                        "    if (claimed) throw;",
                        "  }",
                        "  modifier withAddress(address _address) {",
                        "    if(_address == 0) throw;",
                        "    _;",
                        "  }",
                        "  function Bounty(address _factoryAddress) withAddress(_factoryAddress){",
                        "    factoryAddress = _factoryAddress;",
                        "  }",
                        "  function createTarget() returns(Target) {",
                        "    target = Target(Factory(factoryAddress).deployContract());",
                        "    researchers[target] = msg.sender;",
                        "    TargetCreated(target);",
                        "    return target;",
                        "  }",
                        "  function checkInvariant() returns(bool){",
                        "    return target.checkInvariant();",
                        "  }",
                        "  function claim(Target target) {",
                        "    address researcher = researchers[target];",
                        "    if (researcher == 0) throw;",
                        "    if (target.checkInvariant()) {",
                        "      throw;",
                        "    }",
                        "    asyncSend(researcher, this.balance);",
                        "    claimed = true;",
                        "  }",
                        "}",
                        "contract InsecureTargetMock {",
                        "  function checkInvariant() returns(bool){",
                        "    return false;",
                        "  }",
                        "}",
                        "contract InsecureTargetFactory {",
                        "  function deployContract() returns (address) {",
                        "    return new InsecureTargetMock();",
                        "  }",
                        "}",
                        "contract SecureTargetMock {",
                        "  function checkInvariant() returns(bool){",
                        "    return true;",
                        "  }",
                        "}",
                        "contract SecureTargetFactory {",
                        "  function deployContract() returns (address) {",
                        "    return new SecureTargetMock();",
                        "  }",
                        "}"
                    ],
                    "del": [
                        "/*",
                        " * Bounty",
                        " * This bounty will pay out if you can cause a CrowdsaleToken's balance",
                        " * to be lower than its totalSupply, which would mean that it doesn't ",
                        " * have sufficient ether for everyone to withdraw.",
                        " */",
                        "contract CrowdsaleTokenBounty is PullPayment {",
                        "  bool public claimed;",
                        "  mapping(address => address) public researchers;",
                        "  function() {",
                        "    if (claimed) throw;",
                        "  }",
                        "  function createTarget() returns(CrowdsaleToken) {",
                        "    CrowdsaleToken target = new CrowdsaleToken();",
                        "    researchers[target] = msg.sender;",
                        "    return target;",
                        "  }",
                        "  function claim(CrowdsaleToken target) {",
                        "    address researcher = researchers[target];",
                        "    if (researcher == 0) throw;",
                        "    if (target.totalSupply() == target.balance) {",
                        "      throw;",
                        "    }",
                        "    asyncSend(researcher, this.balance);",
                        "    claimed = true;",
                        "  }",
                        "}",
                        "/*",
                        " * Bounty",
                        " * This bounty will pay out if you can cause a SimpleToken's balance",
                        " * to be lower than its totalSupply, which would mean that it doesn't ",
                        " * have sufficient ether for everyone to withdraw.",
                        " */",
                        "contract SimpleTokenBounty is PullPayment {",
                        "  bool public claimed;",
                        "  mapping(address => address) public researchers;",
                        "  function() {",
                        "    if (claimed) throw;",
                        "  }",
                        "  function createTarget() returns(SimpleToken) {",
                        "    SimpleToken target = new SimpleToken();",
                        "    researchers[target] = msg.sender;",
                        "    return target;",
                        "  }",
                        "  function claim(SimpleToken target) {",
                        "    address researcher = researchers[target];",
                        "    if (researcher == 0) throw;",
                        "    if (target.totalSupply() == target.balance) {",
                        "      throw;",
                        "    }",
                        "    asyncSend(researcher, this.balance);",
                        "    claimed = true;",
                        "  }",
                        "}"
                    ]
                }
            }
        ]
    },
    "1.2.0": {
        "- Fix ERC20 interface and implementations to [conform to standard](https://github.com/ethereum/EIPs/pull/610).\r": [],
        "- Bugfixes in `VestedToken`.\r": [],
        "- Deprecated `throw` in favor of `require()`, `assert()` and `revert()`.\r": []
    },
    "1.1.0": {
        "- Add a [TokenTimelock contract](https://github.com/OpenZeppelin/zeppelin-solidity/blob/f507a0ea29f44bebb1e3d94fcc97ea5808915dab/contracts/token/TokenTimelock.sol).\r": [
            "https://github.com/OpenZeppelin/zeppelin-solidity/blob/f507a0ea29f44bebb1e3d94fcc97ea5808915dab/contracts/token/TokenTimelock.sol"
        ],
        "- Remove all checks for short address attack (see: https://github.com/OpenZeppelin/zeppelin-solidity/issues/261)\r": []
    },
    "1.0.6": {
        "## Security \r": [],
        "- Add fix for the `approve()` mitigation.\r": [],
        "- Protect `transferFrom` against short hand attack.\r": [],
        "- Fix attack on `VestedToken#grantVestedTokens()`\r": []
    },
    "1.0.5": {
        "- Decouple transferable logic from `VestedToken` as `LimitedTransferToken`.\r": [],
        "- Added new ownership helpers `HasNoEther`, `HasNoContracts`, `NoOwner`.\r": [],
        "- Added `ReentrancyGuard` to prevent contract from calling itself, directly or indirectly.\r": [],
        "- New `PausableToken` token with pausable transfers (it's a `Pausable` instance)\r": [],
        "- Make SafeMath a library.\r": [],
        "- External audit security fixes. (Audit link will be published soon).\r": []
    },
    "1.0.4": {}
}